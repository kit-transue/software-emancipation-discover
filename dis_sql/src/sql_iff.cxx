/*************************************************************************
* Copyright (c) 2015, Synopsys, Inc.                                     *
* All rights reserved.                                                   *
*                                                                        *
* Redistribution and use in source and binary forms, with or without     *
* modification, are permitted provided that the following conditions are *
* met:                                                                   *
*                                                                        *
* 1. Redistributions of source code must retain the above copyright      *
* notice, this list of conditions and the following disclaimer.          *
*                                                                        *
* 2. Redistributions in binary form must reproduce the above copyright   *
* notice, this list of conditions and the following disclaimer in the    *
* documentation and/or other materials provided with the distribution.   *
*                                                                        *
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   *
* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, *
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       *
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   *
*************************************************************************/
/*
 * S Q L _ I F F . C
 *
 * 1997 Software Emancipation Technology, Inc.
 *
 * Created Nov. 1997 Mark B. Kaminsky
 *
 * This file contains the routines to produce an ELS (External
 * Language Support) IFF (Internal Format File) for programs in
 * SQL (Structured Query Language).
 *
 * This process is run from a driver (sql_driver.c) routine which
 * opens the input program and calls iff_openfile() below to open
 * the IFF output and then iff_file() to output the first entry (with
 * the input filename).  The driver then calls the parser to process
 * the input program.
 *
 * During parsing, symbols (identifiers) are tracked and an internal
 * Abstract Syntax Tree (AST) is built.  This tree also
 * contains infomation about symbol relationships.  The ELS output file
 * consists of keyword entries produced by the scanner as well as symbol
 * and syntax entries generated by the parser.  Once the parsing is
 * is done the driver calls iff_ast() below to walk the tree and
 * produce the required IFF entries.
 *
 * This file also contains iff_error() (and similar routines) to
 * output an error entry in the IFF (and on stderr).  In general,
 * this routine is called anytime there is an error, including parsing,
 * scanning, or by any of their associated routines.
 */

#ifndef ISO_CPP_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#else /* ISO_CPP_HEADERS */
#include <cstdio>
using namespace std;
#include <cstdlib>
#include <cstring>
#endif /* ISO_CPP_HEADERS */

#include "sql_scanner.h"	// token struct
#include "sql_iff.h"		// IFF string defines
#include "sql.yacc.h"		// bison generated token values
#include "sql_ast.h"		// ast_tree struct
#include "sql_sym_enum.h"	// symbol kinds
#include "sql_host.h"		// esql mapping


// map a symbol kind to a ast node kind
EXTERN_C ast_node_kind ast_sym_kind_map (sym_kind sk);  // in sql_ast_map.C

// fill buffer with current line and column
EXTERN_C void format_line_source (char * buffer);	// in sql.l

// track errors found during current run
EXTERN_C int sql_errcount;				// in sql.l

// Produce test output: symbol name in place of number.
// Useful for diff of IF files, since minor grammar changes might cause
// symbol renumbering which makes every line different
EXTERN_C int iff_test_output_flag;			// in sql_driver.C

//
// current output file (IFF)
//
static const char * outfilename = 0;

//
// current input filename (SQL source file)
//
EXTERN_C const char * sql_infilename = 0;

//
// temp buffer for line/column offsets
//
static char line_offset_buffer [80];

//
// Current indent counter
//
// Used to indent ast entries.  It is incremented before
// each deeper tree level and decremented when each level
// it finished.
//
static int indent = 0;

//
// I/O File pointer to IFF output
//
static FILE* iff_fp = 0;

//
// static routines below
//
static int iff_io_error (void);
static int iff_symbol_decl (const SQL_SYM * sym);
static int iff_symbol_entry (const SQL_SYM * sym, int rep_flag);
static int iff_ast_tree (ast_tree * at);
static int iff_indent (void);
static int iff_literal (const char * text, int newline_flag);
static int iff_literal_text (const char * text);
static int iff_ast_loc (ast_loc start, ast_loc end);
static int iff_ast_definition (ast_tree *at);
static int iff_declarations (void);
static void iff_reference_count (ast_tree * at);
static int iff_ast_reference (ast_tree *at);
static int iff_ast_relation (ast_tree * at);
static int iff_ast_relation_node (ast_tree * at);
static int iff_symbol_attribute (const SQL_SYM * sym);
static int iff_one_attribute (int * firstp, const char * attr);
static int iff_error_log (
	unsigned int lineno,
	unsigned int column,
	const char * text,
	const char * msg);
static int iff_error_output (
	FILE *fp,
	unsigned int lineno,
	unsigned int column,
	const char * fname,
	const char * text,
	const char * msg);
static int iff_error_standard (
	FILE *fp,
	unsigned int lineno,
	unsigned int column,
	const char * fname,
	const char * text,
	const char * msg);
static int iff_mapping (void);
static int iff_mapping_record (const char * filename, 
			       const char * label,
			       iffmap *mp);

//
// iff_source_filename - Record input filename for error reporting.
//
// Only stores ptr, which must be valid for life of this file.
EXTERN_C int iff_source_filename (const char * inname)
{
   if (inname) {
      sql_infilename = inname;
   } else {
      sql_infilename = 0;
   }
   return (0);
}

//
// iff_openfile - Open IFF file.
//
// Filemode is either "w" for creating a new file (overwrites any existing)
// or "a" to append to existing file (or create new
// file if it doesn't exist).  If outname is 0 then just
// uses standard output.
//
// Returns -1 if it can't open the file
//
EXTERN_C int iff_openfile (const char * outname, const char * filemode)
{
   if (outname) {
      // set filename global
      outfilename = outname;
      if ((iff_fp = fopen (outfilename, filemode)) == NULL) {
	 return (iff_io_error ());
      }
   } else {
      outfilename = 0;
      iff_fp = stdout;
   }
   return (0);
}

//
// iff_io_error - Print error on stderr.
//
// Called within this module whenever an I/O error
// occurs when writing to (or openning) output file.
// Generally called as part of the return statement,
// i.e. "return (iff_io_error ());", so returns -1.
//
static int iff_io_error (void)
{
   if (outfilename) {
      perror (outfilename);
   } else {
      perror (0);
   }
   return (-1);
}

//
// iff_closefile - Close the IFF.
//
EXTERN_C int iff_closefile (void)
{
   if (iff_fp && outfilename) {
      fclose (iff_fp);
      iff_fp = 0;
      outfilename = 0;
   }
   return (0);
}

//
// iff_error - Output an error message entry in IFF and on stderr.
//
EXTERN_C int iff_error (const char * msg)
{
   int ret_val;

   ret_val = iff_error_log (ilineno, get_icolumn (), 0, msg);

   return (ret_val);
}


//
// iff_error_text - Output an error message entry w/ additional text.
//
EXTERN_C int iff_error_text (const char * text, const char * msg)
{
   int ret_val;

   ret_val = iff_error_log (ilineno, get_icolumn (), text, msg);

   return (ret_val);
}

//
// iff_error_token - Output an error message entry w/ token.
//
EXTERN_C int iff_error_token (const token *t, const char * msg)
{
   int ret_val = 0;
   
   if (t) {
      ret_val = iff_error_log (t->lineno, t->column, t->text, msg);
   } else {
      ret_val = iff_error (msg);
   }
   return (ret_val);
}

//
// iff_error_log - Handle output of error messages
//
//
// Called by above external routinues.  Increments error count.
// Adds input filename.  Sends message to both standard error
// and error log.
static int iff_error_log (
	unsigned int lineno,
	unsigned int column,
	const char * text,
	const char * msg)
{
   int ret_val = 0;
   const char * fname;

   // increment global error count
   sql_errcount++;

   // correct line number if at EOL
   if ((column == 0) && (lineno > 1)) {
      --lineno;
   }

   // Output error to stderr
   ret_val = iff_error_standard (stderr, lineno, column,
				 sql_infilename, text, msg);

   // same message to if file
   if (iff_fp) {
      // produce a cleaner error log by not printing main source filename
      fname = sql_infilename;
      if (! symbol_specification_phase ) {
	 fname = 0;
      }
      ret_val = iff_error_output (iff_fp, lineno, column, fname, text, msg);
   }

   return (ret_val);
}
   
//
// iff_error_output - Actual output of error message
//
static int iff_error_output (
	FILE *fp,
	unsigned int lineno,
	unsigned int column,
	const char * fname,
	const char * text,
	const char * msg)
{
   int ret_val = 0;

   // start to output error
   ret_val = fprintf (fp, "%s %d/%d \"", IFFSTR_ERR, lineno, column);

   // optional filename
   if ((ret_val >= 0) && fname && *fname) {
      ret_val = fprintf (fp, "%s: ", fname);
   }

   // optional token text
   if ((ret_val >= 0) && text && *text) {
      ret_val = fprintf (fp, "%s: ", text);
   }

   if (ret_val >= 0) {
      ret_val = fprintf (fp, "%s\"\n", msg);
   }
   
   if (ret_val < 0) {
      ret_val = iff_io_error ();
   } else {
      fflush (fp);
   }

   return (ret_val);
}

//
// iff_error_standard - Actual output of error message
// (emacs clickable version)
//
static int iff_error_standard (
	FILE *fp,
	unsigned int lineno,
	unsigned int column,
	const char * fname,
	const char * text,
	const char * msg)
{
   int ret_val = 0;

   // start to output error
   if (fname && *fname) {
      ret_val = fprintf (fp, "\"%s\", ", fname);
   }

   // line and column
   if ((ret_val >= 0) && (lineno > 0)) {
      ret_val = fprintf (fp, "line %d: ", lineno);
   }

   if ((ret_val >= 0) && (lineno > 0) && (column > 0)) {
      ret_val = fprintf (fp, "column %d: ", column);
   }

   // optional token text
   if ((ret_val >= 0) && text && *text) {
      ret_val = fprintf (fp, "%s: ", text);
   }

   if (ret_val >= 0) {
      ret_val = fprintf (fp, "%s\n", msg);
   }
   
   if (ret_val < 0) {
      ret_val = iff_io_error ();
   } else {
      fflush (fp);
   }

   return (ret_val);
}


//
// iff_file - Output filename symbol and reference entries.
//
EXTERN_C SQL_SYM * iff_file (const char* filename)
{
   int ret = 0;
   if (filename == NULL) {
      return NULL;
   }
   SQL_SYM * sym = sql_symbol_extern (filename, sk_file);
   if (sym) {
     ret = iff_file_reference (filename);
     if (ret == 0) {
       ret = iff_symbol_decl (sym);
       
       // set defined flag so that symbol is not output again
       // during iff_declarations() phase
       sym->sym_defined = 1;
     }
   }
   return (sym);
}

//
// iff_file_reference - Output a filename reference entry.
//
EXTERN_C int iff_file_reference (const char* filename)
{
   if (fprintf (iff_fp, "%s \"%s\"\n", IFFSTR_SMTFILE, filename) < 0) {
      return (iff_io_error ());
   }
   fflush (iff_fp);
   return (0);
}

//
// iff_language - Output a language entry.
//
// Language of the input source file,
EXTERN_C int iff_language (void)
{
   const char * lang;
   if (esql_mode) {
      lang = IFFSTR_LANG_ESQL;
   } else {
      lang = IFFSTR_LANG_SQL;
   }
   if (fprintf (iff_fp, "%s \"%s\"\n", IFFSTR_SMTLANG, lang) < 0) {
      return (iff_io_error ());
   }
   fflush (iff_fp);
   return (0);
}

//
// iff_keyword - Output a keyword entry.
//
// Unlike most of the IFF output entry routinues, this one is called
// directly by the scanner (and sometimes by the parser)
//
EXTERN_C int iff_keyword (const token * t)
{
   // don't output keywords in specification files
   if (t && ( ! symbol_specification_phase )) {
      if (fprintf (iff_fp, "%s \"%s\" %d/%d %d/%d\n",
	    IFFSTR_SMTKEYWORD, t->text,
		   t->lineno, t->column,
		   t->lineno, (strlen (t->text) + t->column - 1)) < 0) {
	 return (iff_io_error ());
      }
   }
   return (0);
}

//
// iff_symbol_id - Output a symbol id number.
//
static int iff_symbol_id (const SQL_SYM * sym)
{
   int ret_val = 0;
   // if sym_replace is set, this symbol will be replaced by a host
   // symbol, so it is not a sql symbol
   if (sym && ( ! sym->sym_replace )) {
      // check test/debug flag
      if ( ! iff_test_output_flag ) {
	 if (fprintf (iff_fp, " [%d]", sym->sym_number) < 0) {
	    ret_val = iff_io_error ();
	 }
      } else {
	 // debug: used symbol name
	 if (fprintf (iff_fp, " [%s]", sym->sym_key) < 0) {
	    ret_val = iff_io_error ();
	 }
      }
   }
   return (ret_val);
}
      
//
// iff_symbol_decl - Output a symbol declaration entry.
//
// The difference between this and a definition entry is that
// the later also has location information.
//
// A declaration entry is used for those symbols used but not
// defined, generally any external symbol such as a database
// table, built-in function, etc.
//
static int iff_symbol_decl (const SQL_SYM * sym)
{
   int rep_flag = 0;
   if (sym) {
      if (esql_mode && sym->sym_replace) {
	 rep_flag = 1;
      }
      if ( ! rep_flag ) {
	 if (iff_symbol_entry (sym, rep_flag) < 0) {
	    return (-1);
	 }
	 if (fputc ('\n', iff_fp) == EOF) {
	    return (iff_io_error ());
	 }
      }
   }
   return (0);
}

// same but without newline
// called by iff_symbol_decl above and iff_ast_definition
//
static int iff_symbol_entry (const SQL_SYM * sym, int rep_flag)
{
   const SQL_SYM * full_sym;
   const char * s;

   if (sym) {
      if (fprintf (iff_fp, "%s", IFFSTR_SYM) < 0) {
	 return (iff_io_error ());
      }
      
      if (iff_symbol_id (sym) < 0) {
	 return (-1);
      }

      if (fprintf (iff_fp, " %s ",
	    sym_kind_lookup (sym->sym_token_type)) < 0) {
	 return (iff_io_error ());
      }

      if (rep_flag) {
	 if (fprintf (iff_fp, ": %s ", IFFSTR_REP) < 0) {
	    return (iff_io_error ());
	 }
      }

      if (fputc ('"', iff_fp) == EOF) {
	 return (iff_io_error ());
      }

      // use full name
      if (sym->full_sym) {
	 full_sym = sym->full_sym;
      } else {
	 full_sym = sym;
      }
      
      // Don't print colon of host variables in esql
      s = full_sym->sym_key;
      if (esql_mode && (*s == ':')) {
	 ++s;
      }

      if (iff_literal_text (s) < 0) {
	 return (-1);
      }

      // output function name and block for local variables
      if (full_sym->proc_sym) {
	 if (fprintf (iff_fp, " @ ") < 0) {
	    return (iff_io_error ());
	 }

	 if (full_sym->proc_sym->full_sym) {
	    s = full_sym->proc_sym->full_sym->sym_key;
	 } else {
	    s = full_sym->proc_sym->sym_key;
	 }

	 if (iff_literal_text (s) < 0) {
	    return (-1);
	 }

	 if (full_sym->proc_block > 0) {
	    if (fprintf (iff_fp, " { %d }", full_sym->proc_block) < 0) {
	       return (iff_io_error ());
	    }
	 }

      }

      if (fputc ('"', iff_fp) == EOF) {
	 return (iff_io_error ());
      }

   }
   return (0);
}

//
// iff_symbol_relation - Output a symbol relation entry.
//
// A relation is always between two symbols and may also
// include attributes.
//
static int iff_symbol_relation (const SQL_SYM * sym_source,
   const SQL_SYM * sym_target,
   const char* relation_name,
   const char* attributes)
{
   if (sym_source && sym_target) {
      if (fprintf (iff_fp, "%s", IFFSTR_REL) < 0) {
	 return (iff_io_error ());
      }

      if (iff_symbol_id (sym_source) < 0) {
	 return (-1);
      }

      if (fprintf (iff_fp, " \"%s\"", relation_name) < 0) {
	 return (iff_io_error ());
      }

      if (iff_symbol_id (sym_target) < 0) {
	 return (-1);
      }

      if (attributes) {
	 if (fprintf (iff_fp, " %s", attributes) < 0) {
	    return (iff_io_error ());
	 }
      }
      if (fprintf (iff_fp, "\n") < 0) {
	 return (iff_io_error ());
      }
   }

   return (0);
}

//
// iff_include_relation - Output an include relation entry.
//
EXTERN_C int iff_include_relation (const SQL_SYM * sym_source,
				   const SQL_SYM * sym_target)
{
   return (iff_symbol_relation (sym_source, sym_target,
				IFFSTR_REL_INCLUDE, 0));
}

// buffer size for building attribute string
static const int attr_buffer_size = 1024;

//
// iff_relation - Class for current symbol relationship.
//
// Holds current relationship information and then output
// relationship entry once all parts are assembled.
//
// Used to save relationship info found while walking down the AST
// after parsing.
//
// Private members:
// sym_source	- source symbol pointer (child symbol)
// sym_target	- target symbol pointer (parent symbol)
// label	- text label for relation entry (e.g. "type", "argument", etc)
// attr_idx	- current position of text in attr_buffer 
// attr_buffer	- buffer with all attribute labels for this relation
// reverse_symbols_flag - reverse the order of the target and source
//			  symbols when printing relation entry
//
class iff_relation {
   private:
      SQL_SYM * sym_source;
      SQL_SYM * sym_target;
      const char * label;
      int attr_idx;
      char attr_buffer [attr_buffer_size];
      int reverse_symbols_flag;

   public:
      iff_relation (SQL_SYM * sym = 0);
      ~iff_relation ();
      void clear (void);

      SQL_SYM * get_source (void);
      SQL_SYM * set_source (SQL_SYM * sym);
      SQL_SYM * get_target (void);
      SQL_SYM * set_target (SQL_SYM * sym);
      const char * set_label (const char * label_string);
      void add_attribute (const char *attribute, const char* value_str = 0);
      void reverse_symbols (void);
      int output (void);
};

// note: the default C++ class assignment is used (to save and restore
// the relation), so if you add any memory allocation add an operator=
//
iff_relation::iff_relation (SQL_SYM * sym /* = 0 */) :
	sym_source (0),
	sym_target (sym),
	label (0),
	attr_idx (0),
	reverse_symbols_flag (0)
{
   attr_buffer [0] = 0;
}

iff_relation::~iff_relation ()
{
}

// Clear - clear info for next relation.
void iff_relation::clear (void)
{
   sym_source = 0;
   sym_target = 0;
   label = 0;
   attr_idx = 0;
   attr_buffer [0] = 0;
   reverse_symbols_flag = 0;
}

//
// Functions to return or set current values
//

SQL_SYM * iff_relation::get_source (void)
{
   return (sym_source);
}

SQL_SYM * iff_relation::set_source (SQL_SYM * sym)
{
   SQL_SYM * sym_hold = sym_source;
   sym_source = sym;
   return (sym_hold);
}

SQL_SYM * iff_relation::get_target (void)
{
   return (sym_target);
}

SQL_SYM * iff_relation::set_target (SQL_SYM * sym)
{
   SQL_SYM * sym_hold = sym_target;
   sym_target = sym;
   return (sym_hold);
}

const char * iff_relation::set_label (const char * label_string)
{
   const char * label_hold = label;
   label = label_string;
   return (label_hold);
}

//
// add_attribute - Add the attribute text label with an optional value.
//
void iff_relation::add_attribute (const char *attribute,
				  const char* value_str /* = 0 */) {
   int len = strlen (attribute);
   if (value_str) {
      len += strlen (value_str) + 2;	// 2: open + close paren
   }

   // add length (2) for comma + space if this is not first attribute
   if (attr_idx) {
      len += 2;
   }

   // check for string overflow including 0 terminator
   if (attr_idx + len + 1 >= attr_buffer_size) {
      iff_error ("attribute buffer overflow");
   } else {

      // now add comma + space if this is not first attribute
      if (attr_idx) {
	 *(attr_buffer + attr_idx++) = ',';
	 *(attr_buffer + attr_idx++) = ' ';
      }

      if (value_str) {
	 sprintf (attr_buffer + attr_idx, "%s(%s)", attribute, value_str);
      } else {
	 strcat (attr_buffer + attr_idx, attribute);
      }

      // increment buffer index to terminating 0 for next addition
      attr_idx += len;
   }
}

//
// Reverse_symbols - Reverse the order of the target and source
// symbols when printing relation entry.  This is needed for the
// context and call relation.
//
void iff_relation::reverse_symbols (void)
{
   reverse_symbols_flag = 1;
}

//
// Output - Output the relationship entry with stored info.
//
// Note: does not clear info, in general clear() should
// be called immediately after output().
//
int iff_relation::output (void) {
   int ret_val = 0;
   if (sym_source && sym_target && label) {
      if ((sym_source->sym_replace == 0) && (sym_target->sym_replace == 0)) {
	 if (reverse_symbols_flag) {
	    ret_val = iff_symbol_relation (sym_target, sym_source,
					   label, attr_buffer);
	 } else {
	    ret_val = iff_symbol_relation (sym_source, sym_target,
					   label, attr_buffer);
	 }
      }
   }
   return (ret_val);
}

///////////////////////////////////////////////////
// Instance of above class for functions below.  //
///////////////////////////////////////////////////
static iff_relation rel;

//
// iff_ast
//
// Transverse the ast (Abstract Syntax Tree) and
// output symbol entries and the ast entry in the IFF.
//
// Called by the driver after parsing.
//
// Note that some entries are already in the IFF: file,
// keyword, and any errors.
//
EXTERN_C int iff_ast (void)
{
   // calculate symbol reference count and flag defines
   iff_reference_count (ast_root);

   // output symbol definition entries
   iff_ast_definition (ast_root);
   fflush (iff_fp);

   // output symbol declaration entries
   // (symbols used but not defined)
   iff_declarations ();
   fflush (iff_fp);

   // output symbol references entries
   iff_ast_reference (ast_root);
   fflush (iff_fp);

   // output symbol relationship entries
   rel.clear ();
   iff_ast_relation (ast_root);
   fflush (iff_fp);

   // output source mapping info for esql
   if (esql_mode) {
      iff_mapping ();
      fflush (iff_fp);
   }

   //
   // output the AST entry
   //
   // Includes one line per tree node
   //

   // Start of AST entry - output label and open brace
   if (fprintf (iff_fp, "%s {\n", IFFSTR_AST) < 0) {
      return (iff_io_error ());
   }

   // Initialize indent counter.
   //
   // Start first line one space in, because
   // "AST" label begins at start of its line.
   //
   indent = 1;

   // output tree by recursively visiting each node.
   if (iff_ast_tree (ast_root) < 0) {
      // already calls iff_io_error ()
      return (-1);
   }

   // End of AST entry - close brace
   if (fprintf (iff_fp, "}\n") < 0) {
      return (iff_io_error ());
   }

   fflush (iff_fp);
   return (0);
}

//
// iff_ast_tree - Output tree by recursively visiting each node.
//
static int iff_ast_tree (ast_tree * at)
{
   ast_treelist * atl;
   ast_node_kind ank;
   const char * node_name;

   if (!at) {
      return (0);
   }

   // output current node first
   if (at->ank == ank_list) {

      // For a "list" type node: Just do list of children.
      //
      // No additional indentation.
      // Siblings are at same indentation with respect to each other.
      //
      for (atl = at->head; atl; atl = atl->next) {
	 if (iff_ast_tree (atl->ast) < 0) {
	    return (-1);
	 }
      }

   } else if (at->ank != ank_none) {
      
      // Do current indentation
      if (iff_indent () < 0) {
	 return (-1);
      }

      // Get symbol's corresponding ast node kind.
      //
      // There are many ast_node_kinds (almost one for each grammar rule)
      // and only a few symbol_kinds, but each symbol_kind has a
      // corresponding ast_node_kind.
      //
      ank = at->ank;
      if ((ank == ank_symbol) && (at->sym)) {
	 if (at->sym->sym_replace) {
	    // host variable -- replaced by ifext processing later
	    // in the model build
	    node_name = IFFSTR_HOSTVAR;
	 } else {
	    node_name = sym_kind_lookup (at->sym->sym_token_type);
	 }
      } else {
	 node_name = ast_node_kind_lookup (ank);
      }

      // Node label
      if (fprintf (iff_fp, "%s", node_name) < 0) {
	    return (iff_io_error ());
	 }

      // Node's symbol number if any.
      //
      // Output ":rep" for nodes that will be replaced in IF post processing
      //
      // Output ":def" label and symbol for nodes flaged as declaration
      // definitions, Otherwise:
      // Don't output symbol number in definition nodes since that symbol
      // is for SYM entries.  Outputting the symbol here would indicate
      // that the whole definition was the symbol.  The symbol for AST
      // is the reference symbol in the definition's subnode.
      //

      // :def label
      if (at->info.decldef && at->sym) {
	 if (esql_mode && at->info.replace) {
#if 0 // :rep not used here anymore
	    if (fprintf (iff_fp, " : %s, %s",
			 IFFSTR_REP, IFFSTR_DEF) < 0) {
	       return (iff_io_error ());
	    }
#endif
	 } else {
	    if (fprintf (iff_fp, " : %s",
			 IFFSTR_DEF) < 0) {
	       return (iff_io_error ());
	    }
	 }
#if 0 // :rep not used here anymore
      } else if (esql_mode && at->info.replace) {
	 if (fprintf (iff_fp, " : %s", IFFSTR_REP) < 0) {
	    return (iff_io_error ());
	 }
#endif
      }

      // symbol number
      if (at->sym) {
	 if ((at->info.decldef) ||
	      (( ! at->info.defined ) && (at->info.reference & REFMASK_AST))) {
	    if (iff_symbol_id (at->sym) < 0) {
	       return (-1);
	    }
	 }
      }

      // node line and column offset pair
      if (iff_ast_loc (at->start, at->end) < 0) {
	 return (-1);
      }

      //
      // now recursively output children
      //
      if (at->head) {
	 // enclose subtree within braces
	 if (fprintf (iff_fp, " {\n") < 0) {
	    return (iff_io_error ());
	 }

	 // one more ident space for children at next level 
	 indent++;

	 // List of children.
	 //
	 // Siblings are at same indentation with respect to each other.
	 //
	 for (atl = at->head; atl; atl = atl->next) {
	    if (iff_ast_tree (atl->ast) < 0) {
	       return (-1);
	    }
	 }

	 // Done with children (and children's children...) -- Restore indent
	 indent--;

	 // On a newline since iff_ast_tree() always terminates line.
	 // Output closing brace in same column as start of this node's label
	 if (iff_indent () < 0) {
	    return (-1);
	 }

	 if (fprintf (iff_fp, "}\n") < 0) {
	    return (iff_io_error ());
	 }
      } else {
	 // no children - just output braces on same line as label
	 if (fprintf (iff_fp, " {}\n") < 0) {
	    return (iff_io_error ());
	 }
      }

   } else if (at->text) {
      // Do current indentation
      if (iff_indent () < 0) {
	 return (-1);
      }

      // literal text node - output quoted text
      if (iff_literal (at->text, 1) < 0) {
	 return (-1);
      }
   }
   return (0);
}

//
// iff_indent - Do current indentation
//
static int iff_indent (void)
{
   int i;

   for (i = indent; i > 0; --i) {
      if (fputc (' ', iff_fp) == EOF) {
	 return (iff_io_error ());
      }
   }
   return (0);
}

//
// iff_literal - Output a literal quoted string.
//
static int iff_literal (const char * text, int newline_flag)
{

   // starting double-quote for literal
   if (fputc ('"', iff_fp) == EOF) {
      return (iff_io_error ());
   }

   if (iff_literal_text (text) < 0) {
      return (-1);
   }

   // ending double-quote for literal
   if (fputc ('"', iff_fp) == EOF) {
      return (iff_io_error ());
   }

   // add newline
   if (newline_flag) {
      if (fputc ('\n', iff_fp) == EOF) {
	 return (iff_io_error ());
      }
   }
   return (0);
}
//
// iff_literal_text - Output a literal string.
//
// Puts a backslash in front of embedded quotes and backslashes.
//
static int iff_literal_text (const char * text)
{
   const char * s;

   // output text
   // add a backslash before double-quotes and backslashes
   for (s = text; *s; ++s) {
      if (*s == '\n') {
	 if (fputc ('\\', iff_fp) == EOF) {
	    return (iff_io_error ());
	 }
	 if (fputc ('n', iff_fp) == EOF) {
	    return (iff_io_error ());
	 }
      } else {	 
	 if ((*s == '"') || (*s == '\\')) {
	    if (fputc ('\\', iff_fp) == EOF) {
	       return (iff_io_error ());
	    }
	 }
	 if (fputc (*s, iff_fp) == EOF) {
	    return (iff_io_error ());
	 }
      }
   }

   return (0);
}

//
// iff_ast_loc - Output line/column number location pair (start end)
//
// Line numbers are one-relative, so 0 indicates that no location
// information is known and therefore not output.
//
static int iff_ast_loc (ast_loc start, ast_loc end)
{
   if (start.lineno) {
      if (fprintf (iff_fp, " %d/%d", start.lineno, start.column) < 0) {
	 return (iff_io_error ());
      }

      if (end.lineno) {
	    if (fprintf (iff_fp, " %d/%d", end.lineno, end.column) < 0) {
	       return (iff_io_error ());
	    }
      }
   }
   return (0);
}

//
// iff_ast_definition - Output symbol definitions (recursive) for tree
//
// Definitions are flaged with "defined".  Also outputs attributes
// associated with this symbol.
//
static int iff_ast_definition (ast_tree *at)
{
   ast_treelist * atl;
   int rep_flag = 0;

   if ( ! at ) {
      return (0);
   }

   if (at->info.defined && at->sym) {
      if (esql_mode && at->sym->sym_replace) {
	 rep_flag = 1;
      }
      if ( ! rep_flag ) {
	 if (iff_symbol_entry (at->sym, rep_flag) < 0) {
	    return (-1);
	 }
	 if (iff_ast_loc (at->start, at->end) < 0) {
	    return (-1);
	 }
	 if (fputc ('\n', iff_fp) == EOF) { return (iff_io_error ()); }

	 if (iff_symbol_attribute (at->sym) < 0) {
	    return (-1);
	 }
      }
   }

   // now recursively output symbol definitions for subtrees
   for (atl = at->head; atl; atl = atl->next) {
      if (iff_ast_definition (atl->ast) < 0) {
	 return (-1);
      }
   }
   return (0);
}

//
// iff_declarations
//
// Output symbol declarations for all symbols used but not defined.
// Also output each symbol's attributes.
//
// Goes through symbol table searching for any symbol used
// (symbol number not zero and referenced somewhere) but not flaged as
// defined in the program.
//
// Note that the "defined" flag in the symbol table means: "this symbol
// is defined somewhere".  Whereas the "defined" flag in a syntax tree
// node means "this symbol is defined right HERE".
//
// Note also that the attributes here are symbol attributes (e.g.
// x is host variable - "x" is a symbol with a symbol attribute "host").
// Not to be confused with relation attributes (e.g. x is argument
// 4 of y - "argument" is a relation (between x and y) with a 
// relation attribute of 4).
//
static int iff_declarations (void)
{
   SQL_SYM * sym;

   // Initalize symbol table "next symbol" to start of table
   sql_symbol_init_list ();

   // go through whole symbol table
   while (sym = sql_symbol_next ()) {
      if (sym->sym_number && sym->ref_count && ( ! sym->sym_defined)) {

	 // Only output once (with full entry)
	 if ( ! sym->full_sym ) {
	    // Output symbol declaration
	    if (iff_symbol_decl (sym) < 0) {
	       return (-1);
	    }
	 }

	 // Output any symbol attributes
	 if (iff_symbol_attribute (sym) < 0) {
	    return (-1);
	 }
      }
   }
   return (0);
}

//
// iff_reference_count - Recursively walk syntax tree and count
// symbol references and flag defined symbols.
//
// This is used later to output symbols that are not defined
// but referenced (in iff_declarations).
//
static void iff_reference_count (ast_tree * at)
{
   ast_treelist * atl;
   SQL_SYM * sym;

   if ( ! at ) {
      return;
   }

   // increment reference count for this symbol
   if (at->sym) {
      if (at->sym->full_sym) {
	 sym = at->sym->full_sym;
      } else {
	 sym = at->sym;
      }

      sym->ref_count++;

      // set defined flag
      if (at->info.defined) {
	 sym->sym_defined = 1;
      }    
   }

   // now recursively walk child trees and update ref_count
   for (atl = at->head; atl; atl = atl->next) {
      iff_reference_count (atl->ast);
   }
}

//
// iff_symbol_attribute - Output symbol attributes for one symbol.
//
static int iff_symbol_attribute (const SQL_SYM * sym)
{
   // check bit mask for any attributes and if found output
   // an attribute entry.
   if (sym && sym->attr_mask && ( ! sym->sym_replace )) {
      // "first" is used to flag that the comma separator is
      // not needed for the first attribute
      int first = 1;

      // Start entry.
      if (fprintf (iff_fp, "%s", IFFSTR_ATR) < 0) {
	 return (iff_io_error ());
      }

      if (iff_symbol_id (sym) < 0) {
	 return (-1);
      }

      if (sym->attr_mask & ATTRMASK_HOST) {
	 if (iff_one_attribute (&first, IFFSTR_ATTR_HOST) < 0) {
	    return (-1);
	 }
      }
      if (sym->attr_mask & ATTRMASK_HOSTIND) {
	 if (iff_one_attribute (&first, IFFSTR_ATTR_HOSTIND) < 0) {
	    return (-1);
	 }
      }
      if (sym->attr_mask & ATTRMASK_CURSOR) {
	 if (iff_one_attribute (&first, IFFSTR_ATTR_CURSOR) < 0) {
	    return (-1);
	 }
      }
      if (sym->attr_mask & ATTRMASK_LOOPIDX) {
	 if (iff_one_attribute (&first, IFFSTR_ATTR_LOOPIDX) < 0) {
	    return (-1);
	 }
      }

      // terminate entry.
      if (fputc ('\n', iff_fp) == EOF) {
	 return (iff_io_error ());
      }
   }
   return (0);
}

//
// iff_one_attribute - Output one attribute label in a comma separated list.
//
static int iff_one_attribute (int * firstp, const char * attr)
{
   // no comma before first one
   if (*firstp) {
      // Clear "first" flag so next attributes (if any) get comma.
      *firstp = 0;
      if (fprintf (iff_fp, " %s", attr) < 0) {
	 return (iff_io_error ());
      }
   } else {
      if (fprintf (iff_fp, ", %s", attr) < 0) {
	 return (iff_io_error ());
      }
   }
   return (0);
}

//
// iff_ast_reference - Recursively output all symbol references.
//
// A symbol reference is any use of the symbol's name in the program,
// except for its definition (test of defined flag).  Also don't
// output reference entries of keyword symbols (like VARCHAR2), since they
// have their own entries with the rest of the keywords.
//
static int iff_ast_reference (ast_tree *at)
{
   ast_treelist * atl;

   if ( ! at ) {
      return (0);
   }

   if (( ! at->info.defined ) &&
       (at->info.reference & REFMASK_SMT) &&
       ( ! at->info.keyword ) &&
       at->sym &&
       ( ! at->sym->sym_replace )) {
      if (fprintf (iff_fp, "%s", IFFSTR_SMT) < 0) {
	 return (iff_io_error ());
      }

      if (iff_symbol_id (at->sym) < 0) {
	 return (-1);
      }

      if (iff_ast_loc (at->start, at->end) < 0) {
	 return (-1);
      }
      if (fputc ('\n', iff_fp) == EOF) { return (iff_io_error ()); }
   }

   for (atl = at->head; atl; atl = atl->next) {
      if (iff_ast_reference (atl->ast) < 0) {
	 return (-1);
      }
   }
   return (0);
}

//
// iff_ast_relation - Recursively output symbol relationships.
//
// Walks down syntax tree getting relation information found
// at tree nodes.  After finding the child symbol that relates
// to a parent symbol it outputs a relation entry.
//
// Relationships and their attributes need not be set
// in the child symbol tree node, but can be any non-symbol node between
// the parent symbol node and the child symbol node.  However, a
// relation is between two (and only two) symbols, so only
// non-symbol nodes can be in-between.  Also relations between a
// parent and child cannot be set in the parent's node, because
// that is the place for relations between the parent and its
// parent.
//
static int iff_ast_relation (ast_tree * at)
{
   ast_treelist * atl;
   iff_relation rel_save;

   if ( ! at ) {
      return (0);
   }

   // Find and set any relationship information for this node.
   // If this is node has a symbol, output a relation entry
   // for relations between this node and its parent (target)
   if (iff_ast_relation_node (at) < 0) {
      return (-1);
   }

   // Save current relation state since it may be cleared
   // or changed while walking down a tree branch.
   // The relation state is restored before processing
   // a parallel branch.
   rel_save = rel;

   // Process each child tree
   for (atl = at->head; atl; atl = atl->next) {
      if (iff_ast_relation (atl->ast) < 0) {
	 return (-1);
      }

      // Finished subtree branch:
      // restore current state before processing next branch
      rel = rel_save;
   }
   return (0);
}

//
// iff_ast_relation_node 
//
// Set relation info (in instance of iff_relation class above) found
// in this tree node.  Output relation entry it this is the child
// symbol endpoint of a relation.
//
static int iff_ast_relation_node (ast_tree * at)
{
   char buffer [80];

   if ( ! at ) {
      return (0);
   }

   // Check for relation attributes and set.
   // Note that some attributes have values the rest are
   // booleans (their label in the entry implies true)
   //
   if (at->info.relation_attr_mask) {
      if (at->info.relation_attr_mask & RELMASK_ARG) {
	 sprintf (buffer, "%d", at->info.arg);
	 rel.add_attribute (IFFSTR_ATTR_ARG, buffer);
      }
      if (at->info.relation_attr_mask & RELMASK_CONST) {
	 rel.add_attribute (IFFSTR_ATTR_CONST);
      }
      if (at->info.relation_attr_mask & RELMASK_INPUT) {
	 rel.add_attribute (IFFSTR_ATTR_INPUT);
      }
      if (at->info.relation_attr_mask & RELMASK_OUTPUT) {
	 rel.add_attribute (IFFSTR_ATTR_OUTPUT);
      }
      if (at->info.relation_attr_mask & RELMASK_PCTROWTYPE) {
	 rel.add_attribute (IFFSTR_ATTR_PCTROWTYPE);
      }
      if (at->info.relation_attr_mask & RELMASK_PCTTYPE) {
	 rel.add_attribute (IFFSTR_ATTR_PCTTYPE);
      }
      if (at->info.relation_attr_mask & RELMASK_PRIVATE) {
	 rel.add_attribute (IFFSTR_ATTR_PRIVATE);
      }
      if (at->info.relation_attr_mask & RELMASK_PUBLIC) {
	 rel.add_attribute (IFFSTR_ATTR_PUBLIC);
      }
      if (at->info.relation_attr_mask & RELMASK_RETURN) {
	 rel.add_attribute (IFFSTR_ATTR_RETURN);
      }
      if (at->info.relation_attr_mask & RELMASK_SCALE) {
	 sprintf (buffer, "%d", at->info.scale);
	 rel.add_attribute (IFFSTR_ATTR_SCALE, buffer);
      }
      if (at->info.relation_attr_mask & RELMASK_SIZE) {
	 sprintf (buffer, "%d", at->info.size);
	 rel.add_attribute (IFFSTR_ATTR_SIZE, buffer);
      }
   }

   // check for relationship kind
   if (at->info.relation) {

      switch (at->info.rk) {
	 case rk_type:
	    rel.set_label (IFFSTR_REL_TYPE);
	    break;

	 case rk_context:
	    rel.set_label (IFFSTR_REL_CONTEXT);
	    rel.reverse_symbols ();
	    break;

	 case rk_call:
	    rel.set_label (IFFSTR_REL_CALL);
	    rel.reverse_symbols ();
	    break;

	 case rk_arg:
	    rel.set_label (IFFSTR_REL_ARG);
	    break;

	 default:
	    break;
      }
   }

   // Check for symbol.  Output relation entry for this symbol
   // and its parent.  Then set this symbol as the parent for
   // any child in a subtree.
   if (at->sym) {
      rel.set_source (at->sym);

      if (rel.output () < 0) {
	 return (-1);
      }

      rel.clear ();
      rel.set_target (at->sym);
   }

   return (0);
}

// iff_mapping ---
// Output "map fixed" and "map copy" records
//
static int iff_mapping (void)
{
   const char * filename = iff_map_get_src_filename ();
   int retval = 0;
   
   if (filename && hostfilename) {
      if (retval >= 0) {
	 retval = iff_mapping_record (filename,
				      IFFSTR_MAPCOPY, 
				      iff_map_get_copy_head ());
      }
      
      if (retval >= 0) {
	 retval = iff_mapping_record (filename,
				      IFFSTR_MAPFIXED, 
				      iff_map_get_fixed_head ());
      }
   }
   return (retval);
}

// iff_mapping_lines ---
// Output "map lines" records
//
EXTERN_C int iff_mapping_lines (const char * filename, 
			      int start_line, int end_line, int dest_line)
{
   int retval = 0;
   retval = fprintf (iff_fp, "%s \"%s\" \"%s\" { %d %d, %d }\n",
		     IFFSTR_MAPLINES, filename, hostfilename,
		     start_line, end_line, dest_line);
   return (retval);
}  

// iff_mapping_record ---
// Outout all map records in the passed map list
//
static int iff_mapping_record (const char * filename, 
			       const char * label,
			       iffmap *mp)
{
   int first;
   int retval = 0;

   for (first = 1; mp && (retval >= 0); mp = mp->next) {
      if (first) {
	 // map header
	 first = 0;
	 retval = fprintf (iff_fp, "%s \"%s\" \"%s\" {\n",
			   label, filename, hostfilename);
      }
      if (retval >= 0) {
	 // one entry per line
	 retval = fprintf (iff_fp, " %d/%d %d/%d, %d/%d %d/%d\n",
			   mp->src_lineno_start,
			   mp->src_column_start,
			   mp->src_lineno_end,
			   mp->src_column_end,
			   mp->dest_lineno_start,
			   mp->dest_column_start,
			   mp->dest_lineno_end,
			   mp->dest_column_end);
      }
   }

   // at least one was output so do close brace
   if (!first) {
      retval = fprintf (iff_fp, "}\n");
   }

   // only file i/o errors
   if (retval < 0) {
      retval = iff_io_error ();
   }
   return (retval);
}

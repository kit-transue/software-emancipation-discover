<!DOCTYPE html><html>
<head>
<title></title>
<style type="text/css">
<!--
.xflip {
    -moz-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: fliph;
}
.yflip {
    -moz-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: flipv;
}
.xyflip {
    -moz-transform: scaleX(-1) scaleY(-1);
    -webkit-transform: scaleX(-1) scaleY(-1);
    -o-transform: scaleX(-1) scaleY(-1);
    transform: scaleX(-1) scaleY(-1);
    filter: fliph + flipv;
}
-->
</style>
</head>
<body>
<a name=1></a><img src="AccessGuide-1_1.png"/><br/>
<hr/>
<a name=2></a>DIScover 7.5<br/>
Access Guide<br/>
<hr/>
<a name=3></a><img src="AccessGuide-3_1.png"/><br/>
<img src="AccessGuide-3_2.png"/><br/>
<b>Table of Contents</b><br/>
<b>Chapters</b><br/>
<a href="AccessGuides.html#7"><b>1</b></a><br/>
<a href="AccessGuides.html#7"><b>Welcome to Access  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1<br/></b></a><a href="AccessGuides.html#8">About This Guide  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   2<br/></a><a href="AccessGuides.html#9">Related Documentation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   3<br/></a><a href="AccessGuides.html#11">Typographical Conventions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   5<br/></a><a href="AccessGuides.html#12">What’s New in This Release   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6<br/>Roles  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6<br/>Assumptions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6<br/></a><a href="AccessGuides.html#13">Getting Help   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   7<br/></a><a href="AccessGuides.html#14">Professional Services   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   8<br/></a><a href="AccessGuides.html#15">Documentation Feedback   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   9<br/></a><a href="AccessGuides.html#16">Where To Go From Here  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   10</a><br/>
<a href="AccessGuides.html#17"><b>2</b></a><br/>
<a href="AccessGuides.html#17"><b>Understanding Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11<br/></b></a><a href="AccessGuides.html#18">About Access  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   12<br/></a><a href="AccessGuides.html#19">Applications of Access  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   13<br/>Samples of Access Programming  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   13</a><br/>
<a href="AccessGuides.html#19">Lines of Code in a Model  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   13<br/></a><a href="AccessGuides.html#21">Include File Naming Conventions  . . . . . . . . . . . . . . . . . . . . . . . .   15<br/></a><a href="AccessGuides.html#22">Static Functions Declared in Header Files . . . . . . . . . . . . . . . . . .   16</a><br/>
<a href="AccessGuides.html#23"><b>3</b></a><br/>
<a href="AccessGuides.html#23"><b>Getting Started With Access . . . . . . . . . . . . . . . . . . . . . . . 17<br/></b></a><a href="AccessGuides.html#24">Interactive Access Sessions on UNIX . . . . . . . . . . . . . . . . . . . . . . . . . .   18</a><br/>
<a href="AccessGuides.html#24">Using Access in a Viewer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   18<br/></a><a href="AccessGuides.html#25">Starting Access Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   19<br/></a><a href="AccessGuides.html#26">Interpreting the Access Buffer   . . . . . . . . . . . . . . . . . . . . . . . . . . .   20<br/></a><a href="AccessGuides.html#27">Autoloading Access Commands   . . . . . . . . . . . . . . . . . . . . . . . . .   21</a><br/>
<a href="AccessGuides.html#28">Access from the UNIX Command Line  . . . . . . . . . . . . . . . . . . . . . . . .   22</a><br/>
<a href="AccessGuides.html#28">Connecting to a model_server Using dish2   . . . . . . . . . . . . . . . .   22</a><br/>
<a href="AccessGuides.html#29">User Interface Customization on UNIX   . . . . . . . . . . . . . . . . . . . . . . .   23</a><br/>
<a href="AccessGuides.html#29">Browser Menu Creation Commands  . . . . . . . . . . . . . . . . . . . . . .   23<br/></a><a href="AccessGuides.html#30">Menu Creation Example   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   24<br/></a><a href="AccessGuides.html#31">Interface Commands   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   25</a><br/>
<a href="AccessGuides.html#31">Interactive Access Sessions on Windows   . . . . . . . . . . . . . . . . . . . . . .   25</a><br/>
<a href="AccessGuides.html#33">Autoloading Access Commands   . . . . . . . . . . . . . . . . . . . . . . . . .   27</a><br/>
<a href="AccessGuides.html#34">Access Menu   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   28</a><br/>
<a href="AccessGuides.html#35">Open DISH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   29<br/></a><a href="AccessGuides.html#36">Utilities  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   30<br/>Action  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   30</a><br/>
<i><b>i</b></i><br/>
<hr/>
<a name=4></a><i>Table of Contents</i><br/>
<a href="AccessGuides.html#38">Convert  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   32<br/>AST  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   32<br/></a><a href="AccessGuides.html#39">TPM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   33<br/></a><a href="AccessGuides.html#40">Category  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   34<br/></a><a href="AccessGuides.html#41">Query   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   35<br/>Filter   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   35<br/></a><a href="AccessGuides.html#42">Project  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   36<br/>Report  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   36</a><br/>
<a href="AccessGuides.html#43"><b>4</b></a><br/>
<a href="AccessGuides.html#43"><b>Access Fundamentals . . . . . . . . . . . . . . . . . . . . . . . . . . . .  37<br/></b></a><a href="AccessGuides.html#44">Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   38</a><br/>
<a href="AccessGuides.html#44">Symbols   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   38<br/>Instances  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   38<br/></a><a href="AccessGuides.html#45">AST Nodes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   39<br/>Data Cells  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   39<br/>Data Type Conversions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   39</a><br/>
<a href="AccessGuides.html#46">Attributes and Attribute Expressions   . . . . . . . . . . . . . . . . . . . . . . . . .   40</a><br/>
<a href="AccessGuides.html#47">Simple Attribute Expressions: Attributes  . . . . . . . . . . . . . . . . . .   41<br/>Attribute Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   41<br/></a><a href="AccessGuides.html#48">Useful Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   42<br/></a><a href="AccessGuides.html#49">Metric Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   43<br/></a><a href="AccessGuides.html#50">Compound Attribute Expressions  . . . . . . . . . . . . . . . . . . . . . . . .   44<br/>Shortcuts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   44<br/></a><a href="AccessGuides.html#51">Tcl Variables   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   45</a><br/>
<a href="AccessGuides.html#52">Sets   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   46</a><br/>
<a href="AccessGuides.html#52">Set Creation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   46<br/></a><a href="AccessGuides.html#53">Set Semantics  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   47<br/>Iteration   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   47<br/>About the Print Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   47</a><br/>
<a href="AccessGuides.html#54">Procedures  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   48</a><br/>
<a href="AccessGuides.html#54">Project Structure, or Browse Mode Queries  . . . . . . . . . . . . . . . .   48<br/></a><a href="AccessGuides.html#55">Entity and Relationship Queries . . . . . . . . . . . . . . . . . . . . . . . . . .   49</a><br/>
<a href="AccessGuides.html#57">Access Specific Commands  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   51</a><br/>
<a href="AccessGuides.html#57">Set Operations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   51<br/></a><a href="AccessGuides.html#59">Miscellaneous Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   53</a><br/>
<a href="AccessGuides.html#61">Groups   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   55</a><br/>
<a href="AccessGuides.html#61">Group Commands   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   55<br/></a><a href="AccessGuides.html#62">Group Subcommands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   56<br/>Importing and Exporting Groups . . . . . . . . . . . . . . . . . . . . . . . . .   56</a><br/>
<a href="AccessGuides.html#63">Closure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   57</a><br/>
<a href="AccessGuides.html#65"><b>5</b></a><br/>
<a href="AccessGuides.html#65"><b>Tree Pattern Matching  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  59<br/></b></a><a href="AccessGuides.html#66">Abstract Syntax Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   60<br/></a><a href="AccessGuides.html#67">AST Nodes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   61</a><br/>
<a href="AccessGuides.html#67">Converting Entities  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   61</a><br/>
<i><b>ii</b></i><br/>
a c c e s s     g u i d e<br/>
<hr/>
<a name=5></a><img src="AccessGuide-5_1.png"/><br/>
<i>Table of Contents</i><br/>
<a href="AccessGuides.html#68">Automatic Conversions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   62</a><br/>
<a href="AccessGuides.html#68">Displaying the AST . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   62<br/></a><a href="AccessGuides.html#69">Attributes of AST Nodes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   63</a><br/>
<a href="AccessGuides.html#71">Accessing Symbol Attributes   . . . . . . . . . . . . . . . . . . . . . . . . . . . .   65</a><br/>
<a href="AccessGuides.html#71">Tree Subcommands   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   65<br/></a><a href="AccessGuides.html#74">Navigation in Attribute Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . .   68</a><br/>
<a href="AccessGuides.html#75">Tree Navigation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   69</a><br/>
<a href="AccessGuides.html#76">Find and Search Attribute Functions  . . . . . . . . . . . . . . . . . . . . . . . . . .   70<br/></a><a href="AccessGuides.html#77">Attribute Iterators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   71<br/></a><a href="AccessGuides.html#78">Variable Capture in Attribute Expressions  . . . . . . . . . . . . . . . . . . . . .   72<br/></a><a href="AccessGuides.html#79">Attribute Expression Actions   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   73<br/>Writing Efficient TPM Expressions   . . . . . . . . . . . . . . . . . . . . . . . . . . .   73</a><br/>
<a href="AccessGuides.html#79">Optimize the Scope of Your Searches   . . . . . . . . . . . . . . . . . . . . .   73<br/>Manage the ASTs in Memory  . . . . . . . . . . . . . . . . . . . . . . . . . . . .   73<br/></a><a href="AccessGuides.html#80">Simple Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   74<br/>Advanced Applications  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   74</a><br/>
<a href="AccessGuides.html#85"><b>6</b></a><br/>
<a href="AccessGuides.html#85"><b>Change Propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79<br/></b></a><a href="AccessGuides.html#86">Event Sequence  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   80<br/>Diff Initialization and Finalization  . . . . . . . . . . . . . . . . . . . . . . . . . . . .   80<br/></a><a href="AccessGuides.html#87">Making Changes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   81<br/></a><a href="AccessGuides.html#88">Applying Diffs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   82<br/></a><a href="AccessGuides.html#91">diff_tpm_all  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   85</a><br/>
<a href="AccessGuides.html#93"><b>7</b></a><br/>
<a href="AccessGuides.html#93"><b>Source Mode Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87<br/></b></a><a href="AccessGuides.html#94">SMT Structure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   88<br/>Obtaining an SMT Node   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   88<br/></a><a href="AccessGuides.html#95">SMT Navigation   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   89<br/></a><a href="AccessGuides.html#96">SMT Attributes   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   90<br/></a><a href="AccessGuides.html#97">Printing the SMT Example   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   91<br/></a><a href="AccessGuides.html#98">SMT/CP Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   92</a><br/>
<a href="AccessGuides.html#99">SMT Change Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   93<br/>Auxiliary Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   93</a><br/>
<b>Appendixes</b><br/>
<a href="AccessGuides.html#101"><b>A</b></a><br/>
<a href="AccessGuides.html#101"><b>Access Commands   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95<br/></b></a><a href="AccessGuides.html#102">Project Commands  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   96</a><br/>
<a href="AccessGuides.html#102">Query Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   96<br/></a><a href="AccessGuides.html#105">Set Operation Commands  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   99<br/></a><a href="AccessGuides.html#106">Group Operation Commands  . . . . . . . . . . . . . . . . . . . . . . . . . . .   100<br/></a><a href="AccessGuides.html#107">Auxiliary Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   101<br/></a><a href="AccessGuides.html#108">Kind Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   102<br/></a><a href="AccessGuides.html#110">Integer Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   104<br/></a><a href="AccessGuides.html#111">Boolean Attributes   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   105<br/></a><a href="AccessGuides.html#114">String Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   108<br/></a><a href="AccessGuides.html#116">Metric Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   110</a><br/>
<i><b>iii</b></i><br/>
<hr/>
<a name=6></a><i>Table of Contents</i><br/>
<a href="AccessGuides.html#118">Applying Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   112</a><br/>
<a href="AccessGuides.html#118">Attribute Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   112</a><br/>
<a href="AccessGuides.html#119">C Function Attribute Expressions   . . . . . . . . . . . . . . . . . . . . . . .   113<br/></a><a href="AccessGuides.html#120">Miscellaneous Commands and Expressions . . . . . . . . . . . . . . .   114<br/></a><a href="AccessGuides.html#121">Interface Commands   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   115</a><br/>
<b>B</b><br/>
<a href="AccessGuides.html#123"><b>Attribute Expression Grammar   . . . . . . . . . . . . . . . . . . .  117<br/></b></a><a href="AccessGuides.html#124">Typographical Conventions for Backus-Naur Form  . . . . . . . . . . . .   118</a><br/>
<a href="AccessGuides.html#124">TPM Expression Syntax  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   118<br/>TPM Expression Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   118</a><br/>
<b>C</b><br/>
<a href="AccessGuides.html#129"><b>AST_node Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  123<br/></b></a><a href="AccessGuides.html#130">AST_node Attribute Codes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   124<br/></a><a href="AccessGuides.html#135">Samples for C++, Java, and SQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   129</a><br/>
<b>D</b><br/>
<a href="AccessGuides.html#147"><b>Access Quick Reference . . . . . . . . . . . . . . . . . . . . . . . . .  141</b></a><br/>
<b>E</b><br/>
<a href="AccessGuides.html#153"><b>Glossary of Terms  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  147</b></a><br/>
<i><b>iv</b></i><br/>
a c c e s s     g u i d e<br/>
<hr/>
<a name=7></a><img src="AccessGuide-7_1.png"/><br/>
<img src="AccessGuide-7_2.png"/><br/>
<b>Welcome to Access</b><br/>
<i>1</i><br/>
Access, the TCL-based programming language behind many DIScover operations, is key to advanced deployment of <br/>your DIScover system. <br/>
This chapter discusses the following topics:<br/>
<br/>
<a href="AccessGuides.html#8">“About This Guide” on page 2</a><br/>
<br/>
<a href="AccessGuides.html#9">“Related Documentation” o</a>n<a href="AccessGuides.html#9"> page 3</a><br/>
<br/>
<a href="AccessGuides.html#11">“Typographical Conventions”</a> on <a href="AccessGuides.html#11">page 5</a><br/>
<br/>
<a href="AccessGuides.html#12">“What’s New in This Release”</a> on<a href="AccessGuides.html#12"> page 6</a><br/>
<br/>
<a href="AccessGuides.html#12">“Roles” o</a>n<a href="AccessGuides.html#12"> page 6</a><br/>
<br/>
<a href="AccessGuides.html#12">“Assumptions” on page 6</a><br/>
<br/>
<a href="AccessGuides.html#13">“Getting Help” o</a>n <a href="AccessGuides.html#13">page 7</a><br/>
<br/>
<a href="AccessGuides.html#14">“Professional Services”</a> on<a href="AccessGuides.html#14"> page 8</a><br/>
<br/>
<a href="AccessGuides.html#15">“Documentation Feedback” o</a>n<a href="AccessGuides.html#15"> page 9</a><br/>
<br/>
<a href="AccessGuides.html#16">“Where To Go From Here” o</a>n<a href="AccessGuides.html#16"> page 10</a><br/>
<i><b>1</b></i><br/>
<hr/>
<a name=8></a><i>Chapter 1: Welcome to Access</i><br/>
<b>About This Guide</b><br/>
The following section details individual chapter content:<br/>
<br/>
<b>Chapter 2:<a href="AccessGuides.html#17"> “Understanding Access” (page 11)</a></b><br/>
Defines Access, offers a brief history of the tool, and outlines some of <br/>its key applications. The chapter concludes with samples of Access <br/>programming that use the DIScover learn environment. <br/>
<br/>
<b>Chapter 3:<a href="AccessGuides.html#23"> “Getting Started With Access” (page 17)</a></b><br/>
Explains how to use Access in Unix and Windows environments. <br/>
<br/>
<b>Chapter 4:<a href="AccessGuides.html#43"> “Access Fundamentals” (page 37</a></b><b>)</b><br/>
Presents key Access concepts such as available data types, attributes <br/>and attribute expressions, sets and groups, and common procedures. <br/>
<br/>
<b>Chapter 5:<a href="AccessGuides.html#65"> “Tree Pattern Matching” (page 59</a></b><b>)</b><br/>
Explains DIScover Tree Pattern Matching (TPM) technology and <br/>how it can be used to analyze vast regions of code for potential <br/>programming flaws. It includes a discussion of the Abstract Syntax <br/>Tree (AST), the data structure that serves as a foundation for all TPM <br/>technology. It presents TPM find procedures and conventions, as well <br/>as tips for writing effective TPM expressions.<br/>
<br/>
<b>Chapter 6:<a href="AccessGuides.html#85"> “Change Propagation” (page 79)</a></b><br/>
Explains how to use TPM technology to automate global changes to <br/>your source code. It includes a discussion of Access diff files, how to <br/>view, merge and apply them, and resolve conflicts that may occur <br/>during a change procedure. <br/>
<br/>
<b>Chapter 7:<a href="AccessGuides.html#93"> “Source Mode Queries” (page 87)</a></b><br/>
Presents the key concept of the Source Mode Tree (SMT), the <br/>mechanism DIScover uses to map between the source text and <br/>the elements in the information model. The chapter also includes a <br/>discussion of SMT navigation, attributes, and standard operations.<br/>
<br/>
<b>Appendix A:<a href="AccessGuides.html#101"> “Access Commands” (page 95)</a></b><br/>
Presents a comprehensive list of available Access commands and <br/>attribute expressions.<br/>
<br/>
<b>Appendix B:<a href="AccessGuides.html#123"> “Attribute Expression Grammar” (page 117)</a></b><br/>
Presents typographical conventions for working with Access and <br/>outlines TPM expression syntax and variables.<br/>
<i><b>2</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=9></a><img src="AccessGuide-9_1.png"/><br/>
<i>Related Documentation</i><br/>
<br/>
<b>Appendix <a href="AccessGuides.html#129">C: “AST_node Attributes” (page 123</a></b><b>)</b><br/>
Provides a comprehensive list of ast_node attribute codes as well as <br/>samples for C++, Java, and SQL programming languages.<br/>
<br/>
<b>Appendix D:<a href="AccessGuides.html#147"> “Access Quick Reference” (page 141)</a></b><br/>
Provides a key to most commonly used Access commands, queries, <br/>and attributes.<br/>
<br/>
<b>Appendix E:<a href="AccessGuides.html#153"> “Glossary of Terms” (page 147</a></b><b>)</b><br/>
Describes common DIScover terms.<br/>
<b>Related Documentation</b><br/>
To provide you with the most convenient means of retrieving information, <br/>product documentation is available in several formats: print, Adobe <br/>Acrobat’s Portable Document Format (PDF), and online help.<br/>
<b>Documentation</b><br/>
<b>Print</b><br/>
<b>PDF</b><br/>
<b>Online</b><br/>
DIScover <br/>
Yes<br/>
Yes<br/>
Yes<br/>
Installation and Administration Guide<br/>
DIScover User <br/>
No<br/>
Yes<br/>
Yes<br/>
Guide for Windows<br/>
DIScover User <br/>
No<br/>
Yes<br/>
Yes<br/>
Guide for UNIX<br/>
DIScover <br/>
No<br/>
Yes<br/>
Yes<br/>
Access Guide<br/>
Release Notes<br/>
No<br/>
No<br/>
Yes<br/>
PDF files are located in the \pdf subdirectory of the distribution CD. To <br/>view them, you must have Adobe Acrobat Reader™ installed on your <br/>machine. You can install the reader by running the setup program in the <br/>\acrobat subdirectory on the CD. Once you have installed the reader, <br/>whenever you open a PDF file the reader starts automatically.<br/>
<i><b>3</b></i><br/>
<hr/>
<a name=10></a><img src="AccessGuide-10_1.png"/><br/>
<img src="AccessGuide-10_2.png"/><br/>
<i>Chapter 1: Welcome to Access</i><br/>
You can access online help from within the Model Browser in the following <br/>ways:<br/>
<br/>
Selecting <b>Help &gt; Contents</b>.<br/>
<br/>
Press <b>F1</b>.<br/>
<b>NOTE</b><br/>
The online help is <i>not</i> context-sensitive.<br/>
From the Model Browser online help, you can display the Access online <br/>help by clicking <br/>
. To display the Model Browser online help again, click <br/>
 in the Access online help.<br/>
In addition to the <i>DIScover</i> <i>Enterprise Edition Access Guide</i>, the other <br/>documentation included in this release is as follows: <br/>
<br/>
<i>DIScover Installation and Administration Guide</i> <br/>provides installation instructions for DIScover; an overview of <br/>DIScover concepts and features; and information on creating, <br/>building, and managing information models.<br/>
<br/>
<i>DIScover User Guide for Windows</i> explains how to <br/>use all the features of the DIScover Model Browser and <br/>Developer XPress client on the Windows platform.<br/>
<br/>
<i>DIScover User Guide for UNIX</i> explains how to <br/>use all the features of the DIScover Model Browser and <br/>Developer XPress client on the UNIX platform.<br/>
<br/>
Online release notes provide the most up-to-date details about this <br/>release. You should review these notes as they may contain <br/>information that only became available after the printed <br/>documentation went to press. You can read the release notes in the <br/>CD Browser or as HTML documents in a Web browser.<br/>
<i><b>4</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=11></a><img src="AccessGuide-11_1.png"/><br/>
<i>Typographical Conventions</i><br/>
<b>Typographical Conventions</b><br/>
Throughout this guide, the following typographical conventions identify <br/>the features, functions, and components of DIScover: <br/>
<b>Items in Documentation</b><br/>
<b>Appear as</b><br/>
Menus, commands<br/>
<b>Tools &gt; Caliper</b><br/>
Drop-down menus<br/>
the <b>Session</b> command<br/>
Dialog boxes, features<br/>
<b>Edit Options, Cancel, OK</b><br/>
Screen information, messages<br/>
Enter the new group name:<br/>
Environment Variables<br/>
<i>TMPDIR</i><br/>
Path names<br/>
c:\scrint\work<br/>
New terms<br/>
appear in <i>italics</i> the first time<br/>
Keyboard keys<br/>
appear in caps, for example ENTER<br/>
Keyboard shortcuts<br/>
Keyboard: ALT, I, N<br/>
<b>NOTE</b><br/>
A note provides you with information that supplements the key points of the <br/>subject. A note may also supply information that applies only in particular <br/>cases.<br/>
<b>IMPORTANT</b><br/>
An important note provides you with information that is essential for <br/>completing a task.<br/>
<b>CAUTION</b><br/>
A caution note advises you about situations that have the potential to result in <br/>a loss of data.<br/>
<i><b>5</b></i><br/>
<hr/>
<a name=12></a><i>Chapter 1: Welcome to Access</i><br/>
<b>What’s New in This Release</b><br/>
For more detailed information on the following features, see the <br/>CodeIntegrityWhatsNew.pdf located in the \pdf subdirectory of the <br/>distribution CD.<br/>
<br/>
simplified build scripts<br/>
<br/>
more robust installation<br/>
<br/>
administration GUI<br/>
<br/>
incremental model builds<br/>
<br/>
additional impact queries<br/>
<br/>
integration with MKS Integrity Manager<br/>
<br/>
print/save/export capabilities<br/>
<b>Roles</b><br/>
There are two main roles when using DIScover: The <i>administrator</i> <br/>installs and configures DIScover, builds and validates information <br/>models, starts and stops servers, performs regular housekeeping for model <br/>builds, clears out old models, and sets up new DIScover users. The <br/><i>user</i> is anyone who needs to work with DIScover information models.<br/>
<b>Assumptions</b><br/>
Before using DIScover, we assume the following about your <br/>knowledge and experience:<br/>
<br/>
You fully understand the hardware platforms and operating systems <br/>you are installing DIScover on, that is, Windows, Solaris, and <br/>HP-UX.<br/>
<br/>
You understand the programming languages used in your source <br/>code, that is, ANSI C/C++, Visual C++, K&amp;R C, Java, Oracle SQL, <br/>Informix SQL, and Sybase SQL.<br/>
<br/>
You understand the compilers used to build your software projects, <br/>that is, Microsoft Visual C++, Sun cc, Sun WorkShop C++, GNU C/<br/>C++, HP cc, HP aC++, and Sun SDK Java.<br/>
<i><b>6</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=13></a><img src="AccessGuide-13_1.png"/><br/>
<i>Getting Help</i><br/>
<b>Getting Help</b><br/>
<i><b>7</b></i><br/>
<hr/>
<a name=14></a><i>Chapter 1: Welcome to Access</i><br/>
<i><b>8</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=15></a><img src="AccessGuide-15_1.png"/><br/>
<i><b>9</b></i><br/>
<hr/>
<a name=16></a><i>Chapter 1: Welcome to Access</i><br/>
<b>Where To Go From Here</b><br/>
<b>To Do This …</b><br/>
<b>See …</b><br/>
Understand how Access works.<br/>
<a href="AccessGuides.html#17">“Understanding Access” on page 11</a><br/>
Start Access.<br/>
<a href="AccessGuides.html#23">“Getting Started With Access” </a>on <br/><a href="AccessGuides.html#23">page 17</a><br/>
Learn the fundamentals of Access.<br/>
<a href="AccessGuides.html#43">“Access Fundamentals” on page 37</a><br/>
Analyze vast regions of source code <br/>
<a href="AccessGuides.html#65">“Tree Pattern Matching” on page 59</a><br/>
for potential programming flaws.<br/>
Automate tedious and error-prone <br/>
<a href="AccessGuides.html#85">“Change Propagation” on page 79</a><br/>
operations on source code.<br/>
Identify information model entities from <br/>
<a href="AccessGuides.html#93">“Source Mode Queries” on page 87</a><br/>
text selections in your editor.<br/>
Learn all available Access commands <br/>
<a href="AccessGuides.html#101">“Access Commands” on page 95</a><br/>
and attribute descriptions.<br/>
Learn attribute-expression grammar.<br/>
<a href="AccessGuides.html#123">“Attribute Expression Grammar”</a> on <br/><a href="AccessGuides.html#123">page 117</a><br/>
View AST_node attributes.<br/>
<a href="AccessGuides.html#129">“AST_node Attributes” on page 123</a><br/>
View the quick reference for common <br/>
<a href="AccessGuides.html#147">“Access Quick Reference”</a> on <br/>
Access commands, queries, and <br/>
<a href="AccessGuides.html#147">page 141</a><br/>
attributes.<br/>
Learn DIScover terms.<br/>
<a href="AccessGuides.html#153">“Glossary of Terms”</a> <a href="AccessGuides.html#153">on page 147</a><br/>
<i><b>10</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=17></a><img src="AccessGuide-17_1.png"/><br/>
<img src="AccessGuide-17_2.png"/><br/>
<b>Understanding Access</b><br/>
<i>2</i><br/>
<b>KEY TERMS: </b>Tcl, tree pattern matching, change propagation<br/>
Access is a Tcl-based language that allows you to write scripts to perform <br/>complex operations with DIScover. You can invoke these scripts in <br/>numerous ways: attach them to menu items, call them in a Caliper session, <br/>or connect them to particular DIScover events like checkin. You can <br/>design scripts to write output to files, to groups, to DIScover <br/>Browsers and viewers, and more. In addition, you can create scripts that <br/>calculate new attributes that can be used in list filters and reports, as well <br/>as in Access scripts.<br/>
This chapter covers the following topics:<br/>
<br/>
<a href="AccessGuides.html#18">“About Access” o</a>n<a href="AccessGuides.html#18"> page 12</a><br/>
<br/>
<a href="AccessGuides.html#19">“Applications of Access”</a> on<a href="AccessGuides.html#19"> page 13</a><br/>
<br/>
<a href="AccessGuides.html#19">“Samples of Access Programming” o</a>n<a href="AccessGuides.html#19"> page 13</a><br/>
<i><b>11</b></i><br/>
<hr/>
<a name=18></a><i>Chapter 2: Understanding Access</i><br/>
<b>About Access</b><br/>
Access is more than an important tool in the DIScover family. It underlies the <br/>functionality of database queries and set operations, plus the <br/>specializations of:<br/>
<br/>
Tree Pattern Matching, used to examine and traverse the parse tree<br/>
<br/>
Change Propagation, used to make automated changes to source <br/>
Access scripts can be used again and again; the possibilities are endless. <br/>For example, you can apply the same kind of analysis used in one project <br/>to another project. Or, you can apply an existing automated tool that you <br/>use every day to transform software to newly purchased source code <br/>bases. Scripts written by one developer can be distributed to others, <br/>leveraging that developer’s expertise in a problem domain.<br/>
If the needs of your organization are particularly specialized, Access <br/>provides the mechanism for tailoring DIScover to those needs. For <br/>example, an embedded environment’s debugger may have limitations on <br/>setting breakpoints that mean that the conditional operator should not be <br/>used, that an if statement should be used instead. You can write an Access <br/>script to detect this and add it to the Quality Assessment Report, if <br/>necessary. Or, if your organization has a sophisticated checklist for impact <br/>analysis or code reviews, you can support these in an automatic fashion <br/>using Access.<br/>
Because Access scripts can be applied to the code base at any time, they <br/>offer advantages over manual changes for long-duration projects. Consider <br/>a porting project that extends over a couple of months. One team of <br/>developers would have to check each file for non-portable constructs, fix <br/>issues found in that file, and then move on to the next. Over the course of <br/>the project, developers assigned to other projects have the opportunity to <br/>reintroduce non-portable constructs. With an Access script that detects the <br/>constructs found in the first pass, the porting team can periodically <br/>revalidate their work.<br/>
The fast turnaround time of Change Propagation scripts offers tremendous <br/>advantages, making it possible to change a large number of files in a short <br/>time. This often reduces the need for merges because a file spends less time <br/>checked out, and it can offer the potential of scheduling changes: you can <br/>develop and test the Change Propagation script without actually <br/>submitting the changes. Then, when your team is ready for those changes <br/>(say, early in the next release cycle), you can introduce them quickly and <br/>efficiently.<br/>
<i><b>12</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=19></a><img src="AccessGuide-19_1.png"/><br/>
<i>Applications of Access</i><br/>
<b>Applications of Access</b><br/>
Access was originally developed to address the large-scale Y2K problem. <br/>Since then, it has been used to provide a customizable impact analysis <br/>functionality and provide the foundation for all the queries in Quality <br/>Assessment Reporting. It serves as the foundation for Tree Pattern <br/>Matching technology, Change Propagation, and Dormant Analysis.<br/>
<b>Samples of Access Programming</b><br/>
The following samples of Access programming are used with the DIScover Learn environment. <br/>
<b>NOTE</b><br/>
When developing scripts, it is easiest if you work on a model that is not too big: <br/>it is helpful to be able to scroll back to see your last couple of queries and to <br/>correlate the query with the result set. As you progress in expertise, you will <br/>develop ways of interacting with large result sets, and, of course, when <br/>running scripts on your production model the question of what fits on the <br/>screen becomes secondary to the problem at hand. <br/>
<b>Lines of Code in </b><br/>
Open an Access prompt. If you are running a model server, do either of the <br/>following:<br/>
<b>a Model</b><br/>
<br/>
Use dish2 -hosts, dish2 -list <i>host</i>, and dish2 <i>service</i> <br/>-connect <i>host</i> to get an Access prompt.<br/>
<br/>
See the following chapters on platform-specific ways of connecting to <br/>a model server.<br/>
Once at the Access prompt (a % sign), type:<br/>
roots<br/>
<i><b>13</b></i><br/>
<hr/>
<a name=20></a><i>Chapter 2: Understanding Access</i><br/>
You should see output similar to the following; it will include a list of the <br/>top-level projects in your model:<br/>
 1  (proj)  /extract_private<br/>
 2  (proj)  /xip_private<br/>
 3  (proj)  /ttt_private<br/>
 4  (proj)  /package_private<br/>
 5  (proj)  /xcalentool_private<br/>
 6  (proj)  /extract_shared<br/>
 7  (proj)  /xip_shared<br/>
 8  (proj)  /ttt_shared<br/>
 9  (proj)  /package_shared<br/>
10  (proj)  /xcalentool_shared<br/>
11  (proj)  /sysinclude<br/>
Check to see how many files are in this model. Type:<br/>
size [defines -files /]<br/>
311<br/>
The Access prompt is provided by a Tcl interpreter; you can enter any Tcl <br/>command:<br/>
for {set i 0} {$i &lt; 10} {incr i} {puts $i}<br/>
1<br/>
2<br/>
...<br/>
foreach x {2 5 10 3} {puts $x}<br/>
2<br/>
5<br/>
10<br/>
3<br/>
Now that you have established your bearings, it is time to do something <br/>useful. Enter the following five lines (three commands) at the interpreter <br/>prompt:<br/>
set total_loc 0<br/>
foreach x [defines -files /] {<br/>
incr total_loc [apply met_LOC $x]<br/>
}<br/>
puts $total_loc<br/>
76450<br/>
This example introduces a couple of features of Access. The set, puts, and <br/>incr commands are all standard Tcl. Considering the rest in turn:<br/>
defines -files /<br/>
<i><b>14</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=21></a><img src="AccessGuide-21_1.png"/><br/>
<i>Samples of Access Programming</i><br/>
The defines query is analogous to the root level queries in the Browser. It <br/>takes an optional first argument (in this case, -files) that filters the result <br/>based on type (other options include -functions, -variables, -macros, <br/>and so on). Subsequent arguments to defines make up a “scope”— the <br/>domain the query is applied to. The domain must be a file or project; in this <br/>case, it is the root scope (or everything).<br/>
foreach<br/>
The result of the defines function is a special DIScover “set” that <br/>efficiently handles large numbers of objects. Tcl’s foreach command has <br/>been overloaded to Access this special DIScover set. In practice, it <br/>behaves as you would expect Tcl’s foreach to behave: it iterates through <br/>each of the members of the set, setting the variable x to a handle for each of <br/>the members in turn.<br/>
apply met_LOC<br/>
Access provides a facility (apply) for accessing attributes of Information <br/>Model symbols. These may be attributes like metrics (in this case, lines of <br/>code, but could be met_CC (cyclomatic complexity), met_RETURNS <br/>(number of return statements), or others), or can describe the entity’s <br/>defining file, arguments, and so on.<br/>
<b>Include File </b><br/>
set all_files [defines -files /]<br/>
1  (module)  /extract/src/sys2.c<br/>
<b>Naming </b><br/>
2  (module)  /extract/src/sys1.c<br/>
<b>Conventions</b><br/>
...<br/>
311  (module)  /sysinclude/ctype.h<br/>
set included_files [get_include_files $all_files]<br/>
1  (module)  /extract/src/global_vars.h<br/>
2  (module)  /extract/src/proto.h<br/>
...<br/>
237  (module)  /sysinclude/bytesex.h<br/>
<i><b>15</b></i><br/>
<hr/>
<a name=22></a><i>Chapter 2: Understanding Access</i><br/>
These two commands may be too simple to appear interesting. However, <br/>you can filter the result to identify header files that have non-standard <br/>extensions:<br/>
set hfiles [filter {match(&#34;*.h&#34;)} $included_files]<br/>
1  (module)  /extract/src/global_vars.h<br/>
2  (module)  /extract/src/proto.h<br/>
...<br/>
202  (module)  /sysinclude/bytesex.h<br/>
set unusual_header_files [set_subtract $included_files <br/>
$hfiles]<br/>
1  (module)  /ttt/include/square.H<br/>
2  (module)  /ttt/include/player.H<br/>
...<br/>
34  (module)  /xcalentool/src/std_icon.xbm<br/>
35  (module)  /xcalentool/src/month.cursor<br/>
<b>Static </b><br/>
Header files are meant to be shared. Static declarations, however, are not <br/>shared. It is unusual to combine the two, and it may be of interest to find <br/>
<b>Functions </b><br/>
all the symbols declared static in included files. In the next example, the <br/>
<b>Declared in </b><br/>
included_files variable previously set are used.<br/>
<b>Header Files</b><br/>
set declares [get_declares $included_files]<br/>
1  (var)  glob_var1<br/>
2  (var)  glob_var2<br/>
3  (funct)  DB_e<br/>
...<br/>
296  (struct)  streambuf<br/>
set static_in_include [filter static $declares]<br/>
As in the first example that used the metric_LOC attribute, this example <br/>makes use of an attribute (static). Instead of applying the attribute as a <br/>function, in this case it is used as a simple “attribute-expression”—the first <br/>parameter to the filter command.<br/>
Hopefully, this sample did not report any hits. There are a couple of <br/>variations you could try to make the output more interesting:<br/>
<br/>
Look for static entities declared in source files:<br/>
filter static [set.subtract<br/>
$all.files   $included_files]<br/>
<br/>
Look for non-static entities declared in a single header file:<br/>
filter {! static} [get_declares main.h]<br/>
<i><b>16</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=23></a><img src="AccessGuide-23_1.png"/><br/>
<img src="AccessGuide-23_2.png"/><br/>
<b>Getting Started With <br/>Access</b><br/>
<i>3</i><br/>
<b>KEY TERMS: </b>interactive Access session, dish, access mode, access buffer, <br/>
model_server <br/>
This chapter provides instructions for launching Access on UNIX and <br/>Windows, including working within an interactive session and from the <br/>command line in both environments. It also provides information on <br/>customizing your UNIX user interface to add menu items and <br/>functionality. <br/>
This chapter covers:<br/>
<br/>
<a href="AccessGuides.html#24">“Interactive Access Sessions on UNIX” </a>on <a href="AccessGuides.html#24">page 18</a><br/>
<br/>
<a href="AccessGuides.html#28">“Access from the UNIX Command Line” on page 22</a><br/>
<br/>
<a href="AccessGuides.html#29">“User Interface Customization on UNIX” </a>on<a href="AccessGuides.html#29"> page 23</a><br/>
<br/>
<a href="AccessGuides.html#31">“Interactive Access Sessions on Windows” on page 25</a><br/>
<br/>
<a href="AccessGuides.html#34">“Access Menu” o</a>n<a href="AccessGuides.html#34"> page 28</a><br/>
<i><b>17</b></i><br/>
<hr/>
<a name=24></a><img src="AccessGuide-24_1.png"/><br/>
<i>Chapter 3: Getting Started With Access</i><br/>
<b>Interactive Access Sessions on UNIX</b><br/>
Before you can do anything with Access, you need to be able to start it. <br/>This section shows you how to use Access interactively.<br/>
<b>Using Access in </b><br/>
In DIScover, Access is available from an Emacs session in the Viewer. <br/>You need to open an Emacs session and invoke Access mode. Access mode <br/>
<b>a Viewer</b><br/>
uses Tcl mode as its foundation, incorporating Tcl functionality with the <br/>functionality of Access. As a result, you can use Access mode as you would <br/>use Tcl mode in any Emacs session.<br/>
For example, if you have the DIScover Browser open, and you want <br/>to start Access.<br/>
<b>To start Access</b><br/>
In the Browser, select <b>Access &gt; Open Dish.</b><br/>
The Viewer appears with an Emacs session. Emacs splits into two buffers. <br/>One Emacs buffer’s status line now shows (DISH:open).<br/>
At this point, you can enter Access commands and send them to the <br/>interpreter.<br/>
<i><b>18</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=25></a><img src="AccessGuide-25_1.png"/><br/>
<i>Interactive Access Sessions on UNIX</i><br/>
Alternatively, you can open Dish using the <b>Viewer</b> menu. <br/>
<b>1 </b>In the Browser, select <b>Viewer &gt; New Viewer.</b><br/>
The Viewer appears with an Emacs session. <br/>
<b>2 </b>Type: <br/>
Esc-x dish<br/>
<b>NOTE</b><br/>
If you already have a Viewer session open, you can execute step 3 at any time.<br/>
<b>3 </b>Press ENTER.<br/>
The Viewer appears with the Emacs session.<br/>
<b>Starting Access </b><br/>
Alternatively, you can choose to put a buffer in Access mode. From an <br/>Access buffer, you can send components to the Access interpreter; Code <br/>
<b>Mode</b><br/>
Integrity shows the interpreter in an opposite buffer.<br/>
<b>To put a buffer in Access mode</b><br/>
<b>1 </b>In an Emacs buffer, execute the Access mode function by typing:<br/>
Esc-x dis-tcl-mode<br/>
<b>2 </b>Press ENTER.<br/>
<i><b>19</b></i><br/>
<hr/>
<a name=26></a><img src="AccessGuide-26_1.png"/><br/>
<img src="AccessGuide-26_2.png"/><br/>
<i>Chapter 3: Getting Started With Access</i><br/>
The active Emacs buffer changes to Access mode, adding a <br/><b>Dis-Tcl-Mode</b> Emacs menu.<br/>
<b>Interpreting the </b><br/>
In an Access buffer, you can construct commands or Tcl-style functions <br/>(known as procedures) and send them to the interpreter. The <b>Dis-Tcl-Mode</b> <br/>
<b>Access Buffer</b><br/>
menu lets you send parts or all of the lines in the buffer to the interpreter.<br/>
<i><b>20</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=27></a><img src="AccessGuide-27_1.png"/><br/>
<img src="AccessGuide-27_2.png"/><br/>
<i>Interactive Access Sessions on UNIX</i><br/>
Each option in this menu corresponds with an Emacs command. The <b>Send <br/>Buffer</b> option, for example, corresponds with the Emacs command <br/>
<b>dis-tcl-send-buffer</b>, which you can also execute with <b>Esc-x </b><br/>
<b>dis-tcl-send-buffer</b>. For a complete list of Emacs Access menu <br/>commands, see the Emacs on-line help (<b>C-h a dis</b>).<br/>
Once you start sending data to the interpreter, Emacs opens the interpreter <br/>in a second buffer. This buffer shows the final output from your Access <br/>instructions, for example:<br/>
This example shows the tail end of the output for the four Access <br/>commands in the top buffer. The output shows the kind, name, and lines of <br/>code (a metric) for each file in the /ttt_shared project. <br/>
<b>Autoloading </b><br/>
Access lets you automatically load options as you start DIScover. This <br/>can be useful in setting up specific sets ahead of time, or configuring the <br/>
<b>Access </b><br/>
DIScover user interfac<a href="AccessGuides.html#29">e (see “User Interface Customization on UNIX” </a><br/>
<b>Commands</b><br/>
on<a href="AccessGuides.html#29"> page 23).</a><br/>
<b>To autoload a file of Access commands</b><br/>
<b>1 </b>Create a file in your home account named ~/.CODEINTEGRITY.dis.<br/>
<i><b>21</b></i><br/>
<hr/>
<a name=28></a><i>Chapter 3: Getting Started With Access</i><br/>
<b>2 </b>Populate the file with Access commands, for example:<br/>
add_menu constructor {method&amp;&amp;scope==cname}<br/>
add_menu destructor {method&amp;&amp;cname[0]==’~’}<br/>
#comment<br/>
#add_menu two arg(2)<br/>
<b>Access from the UNIX Command Line</b><br/>
When you work with Access interactively, you automatically connect to <br/>the model server that supports your browser and viewer. Your DIScover administrator is responsible for maintaining models and <br/>starting/stopping model servers using DISIM. However, the following <br/>instructions are provided in the event that you want or need to start a <br/>model server on your own.<br/>
<b>To start a model_server as a server on UNIX</b><br/>
<b>1 </b>Open the command console.<br/>
<b>2 </b>Enter the following to set the <i>ADMINDIR</i> environment variable:<br/>
setenv ADMINDIR &lt;path to model&gt;<br/>
<b>3 </b>Set the other environment variables referenced in the PDF file of the <br/>
model by entering:<br/>
setenv &lt;environment variable&gt; &lt;required field&gt;<br/>
Examples:<br/>
sharedSrcRoot &lt;path to source files&gt;<br/>
sharedModelRoot &lt;path to model&gt;<br/>
privateSrcRoot &lt;path to private source files&gt;<br/>
privateModelRoot &lt;path to private model&gt;<br/>
<b>4 </b>Start model_server by typing the following into the command line:<br/>
model_server -prefs &lt;path to the *.prefs file&gt; -pdf <br/>
&lt;path to the *.pdf file&gt; -home &lt;home_project_name&gt; <br/>
-server -server_name CODEINTEGRITY:&lt;server_name&gt; &amp;<br/>
<b>Connecting to a </b><br/>
dish2 is a small client program that connects to model servers and <br/>provides a command line to an Access interpreter.<br/>
<b>model_server <br/>Using dish2</b><br/>
<b>To connect to model_server with dish2 on UNIX and Windows</b><br/>
<b>1 </b>Open the command console.<br/>
<i><b>22</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=29></a><img src="AccessGuide-29_1.png"/><br/>
<i>User Interface Customization on UNIX</i><br/>
<b>2 </b>Enter the following command, which lists all model services on the <br/>
specified host(s).<br/>
dish2 -list &lt;host1&gt; &lt;host2&gt; ...<br/>
<b>3 </b>To connect model_server with dish2, enter into the command <br/>
console:<br/>
dish2 &lt;service&gt; -connectpset &lt;host1&gt;<br/>
The dish2 command prompt (%) displays.<br/>
<b>User Interface Customization on UNIX</b><br/>
Access provides a series of commands to perform the following operations:<br/>
<br/>
add menu items to the Browser<br/>
<br/>
use selections from scan mode as part of Access queries<br/>
<br/>
send output to the Browser<br/>
With these capabilities and Access, you can create an interface with an <br/>external tool and make it available via the Browser. This section shows you <br/>what these Access commands are and how they work.<br/>
<b>Browser Menu </b><br/>
Access menu commands let you add new menus to the Browser as well as <br/>to select existing menus in the Browser. These select menus are:<br/>
<b>Creation </b><br/>
<br/>
<b>Commands</b><br/>
<b>Category </b><br/>
<br/>
<b>Query </b><br/>
<br/>
<b>Action </b><br/>
The following table shows a list of Access menu commands:<br/>
<b>Menu Command</b><br/>
<b>Description</b><br/>
<b>add_menu</b><br/>
Adds a menu to the Browser’s menu bar; allows cascading <br/>menus.<br/>
add_menu <br/>
menu_name.submenu_1_name.submenu_2_nam<br/>
e<br/>
<b>add_item</b><br/>
Adds an item to one of the Browser menus where <br/>command_string is the action initiated by the item.<br/>
add_item menu item_name command_string<br/>
<b>add_separat</b><br/>
Adds a separator to the specified menu. <br/>
<b>or</b><br/>
add_separator menu<br/>
<i><b>23</b></i><br/>
<hr/>
<a name=30></a><img src="AccessGuide-30_1.png"/><br/>
<i>Chapter 3: Getting Started With Access</i><br/>
The <b>add_menu</b> command has its own syntax:<br/>
add_menu <i>tag</i><br/>
Its associated command, <b>add_item</b>, uses similar syntax:<br/>
add_item <i>menu</i> <i>tag command</i> [<i>selection</i>] [<i>display</i>]<br/>
In these commands:<br/>
<br/>
<i>menu</i> (add_item only) is the parent menu name.<br/>
<br/>
<i>tag</i> refers to the name you want to appear in the menu.<br/>
<br/>
<i>command</i> refers to the Access command you want the menu operation <br/>to invoke (you can use Tcl procedures).<br/>
<br/>
<i>selection</i> (optional) is a Browser-based selection that acts as input <br/>for an Access command. Choose from the selection options to specify <br/>which Browser functionality Access uses:<br/>
<br/>
-selection, (default) the current selection in the Browser<br/>
<br/>
-scope, the scope as established in the <b>Project</b> text field<br/>
<br/>
-filter, all entities in the current selection’s column<br/>
<br/>
-none, no selection<br/>
<br/>
-optional, the current selection, allows no selection<br/>
<br/>
<i>display</i> (optional) refers to Access command output destination. <br/>Works only with the Browser; display options include:<br/>
<br/>
-result shows output in the <b>Results</b> column<br/>
<br/>
-element shows output in the <b>Elements</b> column<br/>
If you do not specify a column, Access sends output to the last, non-<br/>active column (sending it to the <b>Results</b> column if data just appeared <br/>in the <b>Elements</b> column).<br/>
Non-Information Model results appear in the status bar at the bottom <br/>of the Browser.<br/>
<b>Menu Creation </b><br/>
The following example uses built-in functions; you may instead call your <br/>own procedures:<br/>
<b>Example</b><br/>
add_item Access.roots roots<br/>
add_item Access.contents contents<br/>
<i><b>24</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=31></a><img src="AccessGuide-31_1.png"/><br/>
<i>Interactive Access Sessions on Windows</i><br/>
<b>Interface </b><br/>
There is an additional set of commands that serve to communicate with the <br/>Browser or a user. These commands are:<br/>
<b>Commands</b><br/>
<b>Interface </b><br/>
<b>Description</b><br/>
<b>Command</b><br/>
<b>get_selecti</b><br/>
Places the entities selected in the Browser <b>Elements</b> or <br/>
<b>on</b><br/>
<b>Results</b> columns into the current set.<br/>
get_selection<br/>
<b>set_result</b><br/>
Copies the contents of the specified set into the Browser’s <br/>Results column.<br/>
set_result <i>set_name</i><br/>
<b>msg</b><br/>
Generates a message relevant to the current operation in <br/>the Browser’s status bar.<br/>
msg <i>options</i><br/>
<b>emacs_comma</b><br/>
Executes an Emacs command.<br/>
<b>nd</b><br/>
emacs_command <i>command</i> <i>args</i><br/>
<b>open_view</b><br/>
Opens the source of the specified entity.<br/>
open_view <i>entity_name</i><br/>
<b>prompt</b><br/>
Generates a prompt dialog box (with the information text <br/>contained in <i>text_string</i>) that accepts text input.<br/>
prompt <i>text_string</i><br/>
These commands use the following syntax:<br/>
get selection<br/>
set_result [set1 set2 ...]<br/>
emacs_command (emacs-command)<br/>
msg -error &#34;text&#34;<br/>
open_view [set1 set2 ...]<br/>
prompt [ -title message_text] [-errmsg error_text]<br/>
<b>Interactive Access Sessions on Windows</b><br/>
On Windows operating systems such as NT and 2000, DIScover <br/>interprets Access commands through two mechanisms:<br/>
<br/>
the <b>Access</b> menu in the Browser<br/>
<br/>
a standalone shell attached to a DIScover Server<br/>
<i><b>25</b></i><br/>
<hr/>
<a name=32></a><img src="AccessGuide-32_1.png"/><br/>
<img src="AccessGuide-32_2.png"/><br/>
<i>Chapter 3: Getting Started With Access</i><br/>
The <b>Access</b> menu provides a shell you can perform Access operations <br/>through. Standalone shells, however, work outside of typical DIScover sessions. You can attach any number of client shells to a DIScover Server. This section shows you how to start an Access standalone <br/>shell and how to start an Access shell within the Model Browser.<br/>
Starting Access requires that:<br/>
<br/>
you have a DIScover model server session already running<br/>
<br/>
your network has a parent server established if you are connecting to a <br/>DIScover model server over the network<br/>
<b>To start Access from the Model Browser</b><br/>
<b>1 </b>Launch the Model Browser.<br/>
<b>2 </b>Click <br/>
. <br/>
An Access shell opens.<br/>
<b>3 </b>You can now type an Access command in the available command line <br/>
of the Access window.<br/>
<i><b>26</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=33></a><img src="AccessGuide-33_1.png"/><br/>
<i>Interactive Access Sessions on Windows</i><br/>
<b>To start Access using a command prompt</b><br/>
<b>1 </b>Open the command prompt.<br/>
<b>2 </b>Type the following into the command line to connect to a service on <br/>
the specified host(s):<br/>
dish2 &lt;service&gt; -connect &lt;host1&gt; &lt;host2&gt;<br/>
If you do not know which service or host to connect to, use the <br/>following commands: <br/>
<br/>
dish2 -hosts reports hosts.<br/>
<br/>
dish2 -list &lt;host&gt; lists all services available on specified <br/>host(s).<br/>
<br/>
dish2 -help lists commands.<br/>
The dish2 command prompt (%) displays. This command line accepts <br/>all Access and Tcl commands. <br/>
<b>3 </b>Enter each command one line at a time, and press ENTER to make <br/>
Access interpret it, for example:<br/>
% roots<br/>
1  (proj)  /xip_private<br/>
2  (proj)  /ttt_private<br/>
3  (proj)  /package_private<br/>
4  (proj)  /xip_shared<br/>
5  (proj)  /ttt_shared<br/>
6  (proj)  /package_shared<br/>
7  (proj)  /sysinclude<br/>
<b>Autoloading </b><br/>
Access lets you automatically load options as you start DIScover. This <br/>can be useful in setting up specific sets ahead of time, or configuring the <br/>
<b>Access </b><br/>
DIScover user interface.<br/>
<b>Commands</b><br/>
<b>To autoload a file of Access commands:</b><br/>
<b>1 </b>Check to see that the environment variable %HOME% is set in the control <br/>
panel and that it points to a writable directory.<br/>
<b>2 </b>Create a file in the directory pointed to by %HOME% called <br/>
CODEINTEGRITY.dis.<br/>
<b>3 </b>Populate the file with Access commands, for example:<br/>
add_attribute constructor {method&amp;&amp;scope==cname}<br/>
add_attribute destructor {method&amp;&amp;cname[0]==’~’}<br/>
#comment<br/>
#add_attribute two arg(2)<br/>
%<br/>
<i><b>27</b></i><br/>
<hr/>
<a name=34></a><i>Chapter 3: Getting Started With Access</i><br/>
<b>Access Menu</b><br/>
The Model Browser provides an <b>Access</b> menu as a shortcut to some of the <br/>most common Access-driven features and functionality. It is not necessary <br/>to establish an interactive Access session prior to invoking these <br/>commands—you can use them while working in the Browser alone, or you <br/>can launch an interactive session from the menu itself and toggle between <br/>the Browser and an Access shell. <br/>
<b>IMPORTANT</b><br/>
Access is a powerful tool. It is important to understand the features you are <br/>using before using <b>Access</b> menu options such as <b>Actions</b> and <b>TPM</b> while in the <br/>Browser. <br/>
As described in <a href="AccessGuides.html#29">“User Interface Customization on UNIX” o</a>n<a href="AccessGuides.html#29"> page 23, y</a>ou <br/>can customize the <b>Access</b> menu and its submenus to arrange items in a <br/>specific order, and include custom queries and actions. Customizable <br/>menu options are described in more detail the following sections. <br/>
Any changes you make are saved for the current session only. If you want <br/>to make permanent changes to these submenus that persist from session to <br/>session, you must modify the appropriate _menu.dis script contained in <br/>the $PSETHOME/lib directory. All these files contain commands for the <br/>Access submenu items.<br/>
<br/>
action_menu.dis contains actions for the <b>Action</b> submenu<br/>
<br/>
util_menu.dis for the <b>Util</b> submenu <br/>
<br/>
convert_menu.dis for the <b>Convert</b> submenu<br/>
<br/>
ast_menu.dis for the <b>AST</b> submenu<br/>
<br/>
tpm_menu.dis for the <b>TPM</b> submenu<br/>
<br/>
category_menu.dis for the <b>Category</b> submenu<br/>
<br/>
query_menu.dis for the <b>Query</b> submenu<br/>
<br/>
filter_menu.dis for the <b>Filter</b> submenu<br/>
<br/>
project_menu.dis for the <b>Project</b> submenu<br/>
<br/>
report_menu.dis for the <b>Report</b> submenu<br/>
<i><b>28</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=35></a><img src="AccessGuide-35_1.png"/><br/>
<img src="AccessGuide-35_2.png"/><br/>
<i>Access Menu</i><br/>
If you want to modify the order of the Access menu submenus, for <br/>example, look at the load_menus.dis file. This file loads all submenus, <br/>and you can change the default behavior there. You can add your own <br/>submenus there also (in order to load them automatically at the start, for <br/>example). <br/>
<b>IMPORTANT</b><br/>
You should write your custom changes to a file named discover.user.dis <br/>and store it in your home directory instead of modifying the original <br/>_menu.dis files. DIScover then automatically creates a <b>User</b> submenu in <br/>the <b>Access</b> menu and your script will be called when you select the <b>User</b> menu <br/>item. <br/>
<b>Open DISH</b><br/>
The first Access menu option, <b>Open DISH,</b> is the only standalone command <br/>that does not include submenus. <b>Open DISH</b> launches an Access shell, or <br/>viewer, you can run Access commands in. The DISH client looks like a <br/>regular DIScover Viewer window, complete with a Minibrowser on <br/>the right side. As you work within DISH, the Minibrowser provides the <br/>capability to continue working with Browser elements and files:<br/>
<i><b>29</b></i><br/>
<hr/>
<a name=36></a><i>Chapter 3: Getting Started With Access</i><br/>
Notice that the DISH window itself has an internal Emacs menu that helps <br/>you to control your Access session. A single click of the menu name <br/>displays the menu options for the selected menu. <br/>
<br/>
<b>Buffers</b> allows you to manipulate the view of buffers and frames in the <br/>active DISH session. Double click this menu to display the available <br/>buffers and frames.<br/>
<br/>
<b>File</b> allows you to work with files and directories; save, kill, and print <br/>buffers; create bookmarks; and perform functions such as emerge, <br/>compare, and apply patches.<br/>
<br/>
<b>Edit</b> allows you to manipulate and search for text within your session. <br/>
<br/>
<b>Complete</b><br/>
<br/>
<b>In/Out</b> allows you to navigate and control input and output.<br/>
<br/>
<b>Signals</b> allows you to communicate with your session during <br/>processing, and offers such commands as break, continue, kill, quit, <br/>and so on. <br/>
The remaining Access menu options and their features are discussed next.<br/>
<b>Utilities</b><br/>
Options from the <b>Utilities</b> menu require a selection in the main Browser <br/>window.<br/>
<b>Utilities</b> menu options include:<br/>
<br/>
<b>Display in Minibrowser</b> displays selected items in the Minibrowser <br/>window. This option is convenient when you want to browse the <br/>source code for selected entities.<br/>
<br/>
<b>Show Attributes</b> opens a viewer and shows all the attributes of the <br/>selected entity. The list of attributes is a general inventory of all <br/>attributes stored in the model. Values appear for those attributes <br/>which are relevant to your selection. This option is a convenient way <br/>to examine metrics for an entity.<br/>
<br/>
<b>Copy</b> copies selected entity to another pane.<br/>
<b>Action</b><br/>
The <b>Action</b> menu allows you to execute a number of Access operations, <br/>including commands, scripts, grouping, printing, and grep.<br/>
<i><b>30</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=37></a><img src="AccessGuide-37_1.png"/><br/>
<img src="AccessGuide-37_2.png"/><br/>
<img src="AccessGuide-37_3.png"/><br/>
<i>Access Menu</i><br/>
<b>Action</b> menu options include:<br/>
<br/>
<b>Access command</b> displays a dialog box where you can enter an Access <br/>command. The results of your command execution are shown in the <br/>minibuffer of the Browser window or in the <b>Results</b> pane.<br/>
<br/>
<b>Load .dis script</b> displays a dialog box where you can type the name of <br/>a stored Access script. For example, you can type the name of an <br/>available script that runs a custom query. You must specify the full <br/>path to the script; these are most often in the $PSETHOME/lib/ <br/>directory.<br/>
<br/>
<b>Print to file</b> displays a dialog box where you can specify the name of <br/>the text file that you want to save the list of selected elements/entities <br/>to. This command saves all currently displayed fields.<br/>
<br/>
<b>Capture group</b> provides another method for quickly storing selected <br/>entities to a group. First select entities in the Browser, then select <br/><b>Access &gt; Actions &gt; Capture group</b>. A New Group window appears for <br/>you to type the name of the new group you want to create.<br/>
<br/>
<b>Grep for references</b> allows you to look for the selected entity name in <br/>your source code. It shows the same results as a <b>Show &gt; Instances</b> <br/>Browser query.<br/>
<i><b>31</b></i><br/>
<hr/>
<a name=38></a><img src="AccessGuide-38_1.png"/><br/>
<i>Chapter 3: Getting Started With Access</i><br/>
<br/>
<b>Grep for regexp</b> displays a dialog box where you can type a regular <br/>expression to search for in your source code.<br/>
<br/>
<b>Retrieve group n</b> provides a quick way to display the members of the <br/>last stored group. Group members appear in the <b>Results</b> column of the <br/>Browser.<br/>
<b>Convert</b><br/>
The <b>Convert</b> menu provides a means for locating the entities, instances, <br/>and AST nodes of selected elements.<br/>
<b>Convert</b> menu options include:<br/>
<br/>
<b>Convert to entity</b> displays the entity related to the selected instance in <br/>the <b>Elements</b> column of the Browser.<br/>
<br/>
<b>Convert to instance</b> displays the instances of the selected entity in the <br/><b>Results</b> column of the Browser.<br/>
<br/>
<b>Convert to AST node</b> displays the AST node for the selected entity or <br/>instance in the <b>Results</b> column of the Browser. You can then double <br/>click the AST node to bring it into a Viewer window. This option is <br/>helpful when you want to view the Abstract Syntax Tree for a selected <br/>entity or instance.<br/>
<b>AST</b><br/>
The <b>AST</b> menu allows you to browse the abstract syntax tree to find the <br/>related nodes for selected entities.<br/>
<i><b>32</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=39></a><img src="AccessGuide-39_1.png"/><br/>
<img src="AccessGuide-39_2.png"/><br/>
<i>Access Menu</i><br/>
<b>AST</b> menu options include:<br/>
<br/>
<b>Find nodes in files</b> requires that you first select a file from the <b>Elements</b> <br/>pane. This option presents a dialog box where you can enter a valid <br/>TPM expression to execute a search for a desired node in the selected <br/>file.<br/>
If you have not selected a file, DIScover displays an error <br/>message asking you to first select a file.<br/>
<br/>
<b>Find nodes of symbols</b> executes a search for the related node of a <br/>selected entity. Matching nodes display in the <b>Results</b> pane.<br/>
<br/>
<b>Force nodes valid</b>—for nodes that do not have a region of text <br/>associated with them (for example, implicit type conversions), this <br/>option finds the nearest enclosing region.<br/>
<br/>
<b>Get parent node</b> navigates the AST to find the parent node of a <br/>selected node. Requires the selection of a previously identified node.<br/>
<br/>
<b>Get child node</b> navigates the AST to find all children of the selected <br/>parent node. Requires the selection of a previously identified node.<br/>
<br/>
<b>Show AST tree</b> opens a viewer that displays the portion of the AST <br/>that contains the selected entity.<br/>
<b>TPM</b><br/>
The <b>TPM</b> menu provides shortcuts to tree pattern matching features, <br/>specifically, working with diff files. For more information about diffs, see <br/><a href="AccessGuides.html#86">“Diff Initialization and Finalization” on page 80 an</a>d the following sections <br/>in Chapter 6:<a href="AccessGuides.html#85"> “Change Propagation” o</a>n <a href="AccessGuides.html#85">page 79.</a><br/>
<b>TPM</b> menu options include:<br/>
<br/>
<b>Files with diffs</b> returns files a TPM/CP operation has requested a <br/>change for.<br/>
<br/>
<b>View/Merge diffs</b> opens the Merge user interface to view diffs.<br/>
<br/>
<b>Apply diffs</b> makes changes to your source code according to the diffs <br/>present.<br/>
<br/>
<b>Remove diffs</b> removes pending diff files.<br/>
<i><b>33</b></i><br/>
<hr/>
<a name=40></a><img src="AccessGuide-40_1.png"/><br/>
<img src="AccessGuide-40_2.png"/><br/>
<i>Chapter 3: Getting Started With Access</i><br/>
<b>Category</b><br/>
The <b>Category</b> menu contains special case <b>Category</b> pane queries and allows <br/>you to create custom menu options for your Browser. By default, DIScover offers a list of entity categories in the <b>Category</b> pane. If you want <br/>to display additional entity categories, such as operators or something <br/>custom, you can use the <b>Category</b> menu to do so.<br/>
<b>Category</b> menu options include:<br/>
<br/>
<b>Create</b> presents a dialog box where you can type a string that specifies <br/>the name and search action for a custom <b>Category</b> pane query.<br/>
<br/>
<b>Operators</b> executes a search for overloaded operators in the selected <br/>project and displays results in the <b>Elements</b> pane. <br/>
<br/>
<b>Constructors</b> executes a search for constructors in the selected project <br/>and displays results in the <b>Elements</b> pane.<br/>
<br/>
<b>Cname match</b> displays a dialog box where you can type a search string <br/>that specifies the cname pattern you want to match. Matches display <br/>in the <b>Results</b> column.<br/>
<i><b>34</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=41></a><img src="AccessGuide-41_1.png"/><br/>
<img src="AccessGuide-41_2.png"/><br/>
<img src="AccessGuide-41_3.png"/><br/>
<i>Access Menu</i><br/>
<b>Query</b><br/>
The <b>Query</b> menu allows you to create custom queries using Access <br/>commands. <br/>
<br/>
<b>Create</b> displays a dialog box where you can type a new query name <br/>and query action string.<br/>
<br/>
<b>Declarations</b> displays the declarations for the selected entity in the <br/><b>Results</b> pane.<br/>
<b>Filter</b><br/>
The <b>Filter</b> menu allows you to create custom filters and access filters that <br/>display pre-defined subsets of information in the Browser.<br/>
<b>Filter</b> menu options include:<br/>
<br/>
<b>Create</b> displays a dialog box where you can type a custom filter string <br/>to run against the selected search scope.<br/>
<br/>
<b>Operator</b> filters the list of selected entities to display only overloaded <br/>operators in the <b>Results</b> pane.<br/>
<br/>
<b>Public</b> filters the list of selected entities to display only those classified <br/>as public in the <b>Results</b> pane.<br/>
<br/>
<b>Constructor</b> filters the list of selected entities to display only <br/>constructors in the <b>Results</b> pane. <br/>
<br/>
<b>Destructor</b> filters the list of selected entities to display only destructors <br/>in the <b>Results</b> pane.<br/>
<i><b>35</b></i><br/>
<hr/>
<a name=42></a><i>Chapter 3: Getting Started With Access</i><br/>
<b>Project</b><br/>
The <b>Project</b> menu allows you to view the related project data for selected <br/>files and entities. All output is displayed in the <b>Results</b> pane.<br/>
<b>Project</b> menu options include:<br/>
<br/>
<b>Home</b> displays the project that sets the current Browser scope. <br/>
<br/>
<b>Writable</b> displays all available projects that are writable.<br/>
<br/>
<b>Roots</b> displays all root directories contained in the current project.<br/>
<br/>
<b>Parent</b> displays parent of the current project.<br/>
<br/>
<b>Contents</b> displays file or subprojects that live directly under selected <br/>project.<br/>
<br/>
<b>Modules</b> displays all modules defined by a project or its subprojects.<br/>
<b>Report</b><br/>
The <b>Report</b> menu provides you with high-level information about selected <br/>files and projects.<br/>
<b>Report</b> menu options include:<br/>
<br/>
<b>Recursive include report</b> displays a Viewer window that shows you <br/>the number of #includes for each file in your selected group of files <br/>or project. <br/>
<br/>
<b>Inventory</b> displays a Viewer window that shows you a high level <br/>content of a selected file without having to examine the actual source <br/>code.<br/>
<i><b>36</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=43></a><img src="AccessGuide-43_1.png"/><br/>
<img src="AccessGuide-43_2.png"/><br/>
<b>Access Fundamentals</b><br/>
<i>4</i><br/>
<b>KEY TERMS: </b>symbol, instance, ast node, data cell, data type conversion, attribute, <br/>
attribute expression, set, closure <br/>
This chapter introduces the core components of Access. These <br/>components may be divided into three broad categories:<br/>
<br/>
data types that represent the objects in the information model<br/>
<br/>
commands that provide access to these objects, query the model for <br/>relations, and provide customization<br/>
<br/>
attribute expressions, which expose details about the individual <br/>objects<br/>
Access forms the basis for technologies such as Tree Pattern Matching, <br/>Change Propagation, and Dormant Analysis. It covers:<br/>
<br/>
<a href="AccessGuides.html#44">“Data Types”</a> on<a href="AccessGuides.html#44"> page 38</a><br/>
<br/>
<a href="AccessGuides.html#46">“Attributes and Attribute Expressions” on page 40</a><br/>
<br/>
<a href="AccessGuides.html#52">“Sets” o</a>n<a href="AccessGuides.html#52"> page 46</a><br/>
<br/>
<a href="AccessGuides.html#54">“Procedures” o</a>n<a href="AccessGuides.html#54"> page 48</a><br/>
<br/>
<a href="AccessGuides.html#61">“Groups” o</a>n<a href="AccessGuides.html#61"> page 55</a><br/>
<br/>
<a href="AccessGuides.html#63">“Closure” o</a>n<a href="AccessGuides.html#63"> page 57</a><br/>
<i><b>37</b></i><br/>
<hr/>
<a name=44></a><i>Chapter 4: Access Fundamentals</i><br/>
<b>Data Types</b><br/>
Access operates on the information in DIScover models. It is <br/>important to understand what kind of information the model contains.<br/>
<b>Symbols</b><br/>
<i>Symbols</i> are the primary keys to the elements in the DIScover model; <br/>they are the handle to objects that make up the macro structure of <br/>programs: files, functions, macros, typedefs, and so on. In practical terms, <br/>symbols are those things that show up in the <b>Categories</b> column of the <br/>Browser: files, functions, classes, and so on. A given symbol may appear in <br/>multiple places in the model: a function has a definition, may have <br/>multiple declarations, and may be called or otherwise referenced in <br/>numerous places in the code. All these occurrences are references to the <br/>same symbol. Symbols represent logical things—they may be most closely <br/>associated with a particular piece of source (their definition, for example), <br/>but they are not created by the source code.<br/>
For elements with non-local scope (macros, functions, global variables, and <br/>so on), DIScover creates separate symbols for objects with the same <br/>name. For instance, your model may have two functions named main. <br/>Each instance of main is given its own symbol and shows up separately in <br/>the Browser, in the <b>Elements</b> column.<br/>
Elements with local scope are consolidated as much as possible without <br/>losing type information: all string literals, %s\n, are assigned to the same <br/>symbol. For local variables, variables with the same name and type are <br/>assembled into the same symbol: there is one symbol for int i, another <br/>for float i, a third for long i, and so on, no matter how many <br/>occurrences of int i, for example, actually exist in the source.<br/>
<b>NOTE</b><br/>
Symbols and their relations to the rest of the model are indexed in pmods. This <br/>improves the efficiency of queries involving symbols when they are run against <br/>an entire model.<br/>
<b>Instances</b><br/>
Most symbols appear more than once in the source: a function that is <br/>defined in one source file may be declared in one or more header files, and <br/>is called from other functions, and may even be called multiple times from <br/>one function. Each appearance of a symbol is an <i>instance</i>.<br/>
<i><b>38</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=45></a><img src="AccessGuide-45_1.png"/><br/>
<i>Data Types</i><br/>
The connection between symbol and instance is one way: an instance <br/>represents only a region of the source text; it does not refer back to the <br/>symbol it spans. For this reason, you cannot query for attributes or <br/>relations for an instance. Instances are primarily used to help the user <br/>navigate to a particular place in the source.<br/>
Under some conditions, it is possible to convert an instance into a node in <br/>the Abstract Syntax Tree (see the following section).<br/>
<b>AST Nodes</b><br/>
Parsed source code is translated into an Abstract Syntax Tree (AST). Each <br/>node of the AST (representing atomic operations like <b>add</b>, and <b>declare <br/>variable</b>, or aggregate operations like <b>function body</b>) is stored in the <br/>information model as an <i>AST node</i>. Like symbols, AST nodes represent <br/>logical constructs, that my or may not appear explicitly in the source text. <br/>Where they do appear, a mapping is established between them and the <br/>node. <br/>
<b>Data Cells</b><br/>
When data storage (like variables, function parameters, and return values) <br/>takes part in a data transfer, a <i>data cell</i> is created to track how that storage is <br/>used. One data cell is created per “level of indirection” associated with the <br/>use of the storage—one cell for the value in the storage location, a second if <br/>its address is taken, a third if it is de-referenced once, and so on.<br/>
<b>Data Type </b><br/>
Objects of the types listed previously are pointers into the information <br/>model. Access commands take these types as arguments and, as a result, <br/>
<b>Conversions</b><br/>
are able to access more information than just the object’s name. When an <br/>Access command is passed an argument with a type different from the <br/>type it is expecting, it attempts to convert that argument into the required <br/>type. Most of these type conversions are discussed later; however, Access <br/>provides a mechanism for converting between strings and symbols—the <br/>primary currency of most Access operations.<br/>
The most reliable way to convert from a string to a symbol is to use the <br/>object’s etag attribute. The etag is a string representation that encodes the <br/>object’s name, location, and type to uniquely identify the object.<br/>
While reliable, etags can be awkward to use without already having the <br/>object. Given the following constructs, Access looks in the information <br/>model for an element that matches the specification. If more than one <br/>element matches, Access only returns one:<br/>
<br/>
/proj: scope or project<br/>
<br/>
func(): extern C function called func, or a C++ function with no <br/>arguments<br/>
<i><b>39</b></i><br/>
<hr/>
<a name=46></a><i>Chapter 4: Access Fundamentals</i><br/>
<br/>
func(char *): C++ function called func that takes char* as an <br/>argument<br/>
<br/>
func: C function called func<br/>
<br/>
var: variable named var<br/>
<br/>
string: string literal string<br/>
<br/>
macro: macro<br/>
<b>NOTE</b><br/>
Integer strings (for example, “5”) are not converted into constants, but are <br/>instead interpreted as indices into arra<a href="AccessGuides.html#52">ys (see “Sets” on page 46).</a><br/>
It is important to understand the limitations of string-to-symbol <br/>conversion when writing Access scripts. Where conversion is required, <br/>keep in mind that conversion may only return one element where multiple <br/>elements are required (for example, in automating dormant code analysis, <br/>remember that the information model may contain several applications <br/>with a function main.).<br/>
Scripts executed from interactive sessions usually receive the user’s <br/>selection from a DIScover group or a selection from the user interface. <br/>In these cases, the input is already in the form of a DIScover set, and <br/>no conversion is required.<br/>
<b>Attributes and Attribute Expressions</b><br/>
Every instance of the data types can have associated attributes. Functions <br/>have names and might be declared private, variables may be declared <br/>const or may be local, a file may be header file or a source file, and so on. <br/>You can access these <i>attributes</i> (name, private-ness, const-ness, local-ness, <br/>header-ness) using<i> attribute expressions</i>. Attribute expressions are another <br/>key component of Access and TPM. The most straightforward use of an <br/>attribute expression is in the <b>apply</b> command:<br/>
apply attribute-expression element<br/>
<i><b>40</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=47></a><img src="AccessGuide-47_1.png"/><br/>
<i>Attributes and Attribute Expressions</i><br/>
<b>Simple Attribute </b><br/>
The simplest attribute expression returns the value of a single attribute. In <br/>this case, the attribute expressions consists solely of the attribute name. The <br/>
<b>Expressions: </b><br/>
etag attribute has already been introduced, but name and kind have <br/>
<b>Attributes</b><br/>
perhaps more obvious meanings:<br/>
apply name main<br/>
main<br/>
apply kind main<br/>
func<br/>
apply etag main<br/>
/ttt/src/main.C@funct@main<br/>
Unlike other Access commands that return elements of the information <br/>model, Tcl attribute expressions (and attributes) return strings. There is no <br/>guarantee that the returned string (except in the case of an etag) converts <br/>back to meaningful elements in the information model.<br/>
Attributes like kind and name return string values; other attributes may <br/>return booleans (where 0=false, 1=true) or integers.<br/>
<b>(Boolean)</b><br/>
apply func main<br/>
1<br/>
apply variable main<br/>
0<br/>
<b>(String)</b><br/>
apply args main<br/>
(int,char**)<br/>
<b>(Integer)</b><br/>
apply numargs main<br/>
2<br/>
<b>Attribute </b><br/>
Certain functions may be used in attribute expressions. Functions are <br/>distinct from attributes in that they take arguments that modify their <br/>
<b>Functions</b><br/>
behavior. The arg(<i>int</i>) function takes an integer as an argument:<br/>
apply arg(1) main<br/>
int<br/>
apply arg(2) main<br/>
char**<br/>
Some attribute functions take attribute names as parameters:<br/>
apply count(args,’*’) main<br/>
2<br/>
<i><b>41</b></i><br/>
<hr/>
<a name=48></a><i>Chapter 4: Access Fundamentals</i><br/>
<b>Useful </b><br/>
A description of all attributes is presented later in this chapter. Following <br/>are notes on attributes of interest:<br/>
<b>Attributes</b><br/>
<br/>
kind returns the type of the element for any given element. For <br/>symbols, the more specific subtype is returned.<br/>
<br/>
name returns the name of the element. This name is fully qualified: in <br/>the case functions with C++ linkage, it includes the classname of the <br/>enclosing class and the types of the arguments the function takes.<br/>
<br/>
cname returns the name stripped of any scope, class scope, and <br/>argument types:<br/>
apply cname Board::save(char*)<br/>
Board::save(char*)<br/>
apply name Board::save(char*)<br/>
save<br/>
<br/>
regexp(<i>expression</i>[, <i>attribute</i>]) returns true if attribute <br/>matches the regular expression, expression. If expression is <br/>omitted, the regular expression is applied to the attribute name:<br/>
apply regexp(&#34;a.*n&#34;) main<br/>
1<br/>
apply regexp(&#34;^a.*n&#34;) main<br/>
0<br/>
apply {regexp(&#34;in&#34;, type)} main<br/>
1<br/>
<br/>
match(<i>pattern</i>[, <i>attribute</i>]) returns true if <i>attribute</i> matches <br/>the glob-style pattern <i>pattern</i>. The glob style pattern matching used <br/>is the same as the Tcl <b>match</b> command; it derives from many <br/>command interpreters’ filename pattern matching: an asterisk, *, <br/>matches zero or more characters; a question mark, ?, matches a single <br/>character; and the expression [<i>a</i>-<i>n</i>] matches characters between <i>a</i> <br/>and <i>n</i>—for example:<br/>
apply {match(“in*”, type)} main<br/>
1<br/>
apply {match(“in”, type)} main<br/>
0<br/>
<br/>
args returns the argument list for a function. The arguments are <br/>returned for C functions, even though the arguments are not part of <br/>the function signature:<br/>
args main<br/>
(int,char**)<br/>
<br/>
type returns the type of a variable, or the return type of a function:<br/>
type main<br/>
int<br/>
<i><b>42</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=49></a><img src="AccessGuide-49_1.png"/><br/>
<i>Attributes and Attribute Expressions</i><br/>
# grabbing a variable named “x” at random:<br/>
kind x<br/>
var<br/>
type x<br/>
double<br/>
<b>Metric </b><br/>
The <b>met_LOC</b> attribute was used in the Access sample <a href="AccessGuides.html#19">“Lines of Code in a <br/>Model” on page 13</a>. Metrics attributes return an integer indicating the <br/>
<b>Attributes</b><br/>
metric for that element. In most cases the value -1 is returned to indicate <br/>that this metric could not be calculated for the entity.<br/>
The following list of sample metrics illustrates some of the metrics that are <br/>of general interest; see Appendix C:<a href="AccessGuides.html#129"> “AST_node Attributes”</a> on<a href="AccessGuides.html#129"> page 123 <br/></a>for the complete list:<br/>
<br/>
met_CC: cyclomatic complexity<br/>
<br/>
met_RETURNS: number of return statements<br/>
<br/>
met_DEPTH: depth of nested control structures<br/>
<br/>
met_FANIN: number of parent classes (a met_FANIN greater than one <br/>indicates multiple inheritance)<br/>
A number of boolean attributes is of general interest and requires little <br/>explanation:<br/>
<br/>
static<br/>
<br/>
virtual<br/>
<br/>
volatile<br/>
<br/>
public<br/>
<br/>
private<br/>
<br/>
function<br/>
<br/>
local<br/>
<br/>
inline<br/>
<br/>
variable<br/>
<br/>
global<br/>
<i><b>43</b></i><br/>
<hr/>
<a name=50></a><i>Chapter 4: Access Fundamentals</i><br/>
<b>Compound </b><br/>
Compound attribute expressions may be constructed by combining <br/>attributes as primitives with logical, arithmetic, and comparison unary and <br/>
<b>Attribute </b><br/>
binary operators. Integer constants are permitted, and string literals may <br/>
<b>Expressions</b><br/>
be used by enclosing the string in quotes. All the attributes in an attribute <br/>expression are applied to the same element, for example:<br/>
apply {name == &#34;main&#34;} main<br/>
1<br/>
apply {type == &#34;main&#34;} main<br/>
0<br/>
apply {type == &#34;main&#34; || numargs &gt; 1} main<br/>
1<br/>
apply {name == fn} main<br/>
Could not find attribute: fn<br/>
Parentheses may be used to group operations. Non-empty and not zero <br/>(“0”) is considered “true” in boolean operations. If attribute expressions <br/>are strung together without a binary operator to join them, the value of the <br/>attribute expression is the same as if the subexpressions were logically <br/>ended:<br/>
apply {name numargs &gt; 1} main<br/>
is the same as<br/>
apply {name &amp;&amp; (numargs &gt; 1)} main<br/>
which would only be false if main had no name (!) or took fewer than two <br/>arguments.<br/>
<b>Shortcuts</b><br/>
Access installs a Tcl error handler that attempts to interpret a command as <br/>an application of an attribute if the command fails. As a result, many <br/>attributes may be used as Tcl commands:<br/>
type main<br/>
int<br/>
args main<br/>
(int,char**)<br/>
<i><b>44</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=51></a><img src="AccessGuide-51_1.png"/><br/>
<i>Attributes and Attribute Expressions</i><br/>
However, this does not work if the attribute has the same name as a Tcl <br/>command:<br/>
apply global main<br/>
1<br/>
global main<br/>
(main is now a reference to a global variable)<br/>
apply file /ttt/src/TicTacToeGame.C<br/>
1<br/>
file /ttt/src/TicTacToeGame.C<br/>
bad option &#34;/ttt/src/TicTacToeGame.C&#34;: must be atime,<br/>
attribute, <br/>
It also does not work for attribute functions or compound attribute <br/>expressions:<br/>
arg(1) main<br/>
invalid command name &#34;arg(1)&#34;<br/>
    while executing<br/>
&#34;arg(1) main&#34;<br/>
{met_CC &gt; 1} main<br/>
invalid command name &#34;met_CC &gt; 1&#34;<br/>
    while executing<br/>
&#34;{met_CC &gt; 1} main&#34;<br/>
In addition, it only applies the attribute to the first argument in a list or set <br/>(more on sets later):<br/>
apply cname exit main<br/>
exit main<br/>
cname exit main<br/>
exit<br/>
In an attribute expression, a string literal (in quotes) by itself is taken to <br/>mean cname == &#34;string&#34;.<br/>
<b>Tcl Variables</b><br/>
Under some circumstances it is possible to refer to Tcl variables in attribute <br/>expressions. For details, see Appendix<a href="AccessGuides.html#123"> B:“Attribute Expression Grammar” <br/></a>on<a href="AccessGuides.html#123"> page 117.</a> However, because the attribute expression syntax and <br/>evaluation differ from Tcl, it is generally better to write helper Tcl <br/>functions than to learn an additional set of rules for evaluation and <br/>expansion.<br/>
<i><b>45</b></i><br/>
<hr/>
<a name=52></a><i>Chapter 4: Access Fundamentals</i><br/>
<b>Sets</b><br/>
Operands of Access commands (symbols, instances, and other objects) can <br/>be grouped together into sets, where they are stored and operated upon. <br/>Access commands take sets as arguments, and return sets as results. Sets <br/>provide a more efficient mechanism for storing large numbers of elements <br/>than do Tcl-based containers such as lists or arrays.<br/>
<b>NOTE</b><br/>
The Tcl string representation of these sets takes the form _DI_n, where <i>n</i> is an <br/>integer; this string is used as a handle into DIScover data structures. In the <br/>sense that the string representation is a handle to a richer but inaccessible data <br/>structure, DIScover sets are similar to Tcl file handles. DIScover sets <br/>are passed by reference, and are reference counted and garbage collected.<br/>
<b>Set Creation</b><br/>
DIScover sets may be obtained in a variety of ways. Most often, they <br/>are created automatically by Access when returning the results of a query <br/>or when passing a set of elements from the user interface to an Access <br/>command. Sets can be created explicitly in Access using the following <br/>commands:<br/>
<br/>
<b>nil_set</b> creates a new, empty set.<br/>
<br/>
<b>new_set</b> creates a new set containing the elements in the parameter <br/>list. This command is used infrequently; instead, you should use <br/><b>set_copy</b> when converting a non-empty list of elements into a new <br/>set, and <b>nil_set</b> when requesting an empty set.<br/>
<br/>
<b>set_copy original-set</b> creates a duplicate of the set specified on <br/>the parameter list<br/>
A set can also be created from a single element, if an element is provided <br/>where a set is required. Elements in turn can be created from strings, with <br/>the caveat noted earlier.<br/>
<i><b>46</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=53></a><img src="AccessGuide-53_1.png"/><br/>
<i>Sets</i><br/>
<b>Set Semantics</b><br/>
As a data container, you should think of Access sets as arrays, not as sets. <br/>Elements in sets are ordered and may contain duplicates. Members are <br/>accessible using integer offsets using the syntax, setname/index1 <br/>[setname/index2...]. Indices begin at 1, not 0. <br/>
<b>NOTE</b><br/>
There is an alternate syntax for identifying elements in a set: use the set name <br/>followed by a list of integers. Even the set name is optional—if omitted, the <br/>integers are applied to the result of the last command. This abbreviated syntax <br/>is best relegated to interactive Access sessions.<br/>
Access sets are passed by reference and are reference counted. The <br/>standard Tcl mechanisms for creating new references to objects—the <b>set</b> <br/>command and passing variables as arguments to procedures—work with <br/>sets. The only way to modify a set is to add elements to it using <b>sappend</b>. <br/>Sets are not copy-on-write; changes made using <b>sappend</b> are seen in all <br/>variables that reference that set. Use <b>set_copy</b> to create a “deep-copy” of a <br/>set.<br/>
<b>Iteration</b><br/>
The Tcl <b>foreach</b> command has been overloaded to understand Access <br/>sets. If an Access set handle is passed as the second argument to <b>foreach</b>, <br/>the iterator variable is set to a value that represents each member of the set <br/>in turn.<br/>
<b>About the Print </b><br/>
In pure Tcl interactive interpreters, the interpreter prints the string value of <br/>the last statement before returning to the interactive prompt. DISH, the <br/>
<b>Procedure</b><br/>
DIScover interpreter, overrides this behavior, so if the last command <br/>returned is an Access set, the interpreter prints a representation of the set’s <br/>contents using the Access <b>print</b> procedure. The output of the print <br/>procedure may be modified using the <b>printformat</b> command.<br/>
The print procedure is perhaps unconventional in that it does not return <br/>the string it prints: its operation is entirely a side effect. As a result, it is not <br/>possible to capture a formatted string by running the print procedure. <br/>Although its output can be redirected to a file using “&gt;” or “&gt;&gt;”, the fact <br/>that the print command is sensitive to state set by <b>printformat</b> means <br/>that it is unreliable for production output—it is better used for diagnostics <br/>in an interactive session. If programs need to capture information about an <br/>element or set of elements, it is better to do so explicitly by querying the <br/>members’ attributes.<br/>
<i><b>47</b></i><br/>
<hr/>
<a name=54></a><i>Chapter 4: Access Fundamentals</i><br/>
<b>Procedures</b><br/>
Access provides Tcl procedures that perform the same operations as are <br/>available from the user interface, such as where used, where defined, <br/>show_sub_classes, and so on. These take sets as arguments and return <br/>sets as results.<br/>
<b>Project </b><br/>
A simple introduction to Access procedures is the <b>roots</b> command. <b>roots</b> <br/>takes no arguments, and returns a list of top-level modules. This is the <br/>
<b>Structure, or </b><br/>
same information displayed when you start DIScover:<br/>
<b>Browse Mode </b><br/>
<b>roots</b><br/>
<b>Queries</b><br/>
1 (proj) /xip_private<br/>
2 (proj) /ttt_private<br/>
3 (proj) /package_private<br/>
4 (proj) /xip_shared<br/>
5 (proj) /ttt_shared<br/>
6 (proj) /package_shared<br/>
7 (proj) /sysinclude<br/>
You can query the structure beneath a project using the <b>subprojects</b> <br/>command. Subprojects takes an argument: the parent project whose <br/>members you want to see:<br/>
<b>subprojects /ttt_shared</b><br/>
1  (proj)  /ttt_shared/FrameDocs<br/>
2  (proj)  /ttt_shared/Relations<br/>
3  (proj)  /ttt_shared/Subsystems<br/>
4  (proj)  /ttt_shared/bin<br/>
5  (proj)  /ttt_shared/doc<br/>
6  (proj)  /ttt_shared/include<br/>
7  (proj)  /ttt_shared/src<br/>
Note that in this command, a string (&#34;/ttt_shared&#34;) was passed that was <br/>converted into a project by the subprojects command. Alternatively, the <br/>array index could have been used:<br/>
subprojects [roots] 5<br/>
<i><b>48</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=55></a><img src="AccessGuide-55_1.png"/><br/>
<i>Procedures</i><br/>
Or in an interactive session, if the last command run was <b>roots</b>, then you <br/>can use the shortcut of specifying the result only by the index into the set—<br/>the set is assumed to be the last result:<br/>
roots<br/>
subprojects 5<br/>
If passed a set containing multiple elements, the <b>subprojects</b> command <br/>queries each element in turn:<br/>
subprojects [roots]<br/>
(return includes subprojects of /ttt_shared, /xip_shared, /<br/>sysinclude, on so on).<br/>
Other commands that describe the project structure are:<br/>
<br/>
<b>contents scope</b> returns the project structure specified by the scope <br/>(project), such as / (root) or /project name.<br/>
<br/>
<b>modules [-level n] scope</b>returns the set of modules (files) <br/>defined under the project scope. If the level is specified, modules <br/>returns only the indicated level.<br/>
<br/>
<b>parent module</b>returns the parent project that contains module.<br/>
<b>Entity and </b><br/>
The most familiar queries are those that are used in scan mode queries, or <br/>those not about the project structure but about the project contents and the <br/>
<b>Relationship </b><br/>
relationships between entities that make up the projects:<br/>
<b>Queries</b><br/>
defines and uses<br/>
defines /ttt_shared<br/>
uses main<br/>
<b>defines</b> and <b>uses</b> take a selector: a list of data kind(s) prefixed with “-”. <br/>See the table of kind attributes in Appendix<a href="AccessGuides.html#129"> C: “AST_node Attributes” on <br/>page 123. A</a>t present, only the first three characters are significant, meaning <br/>that it is possible to use queries that are similar to the Browser. The selector <br/>-all, which returns all kinds, is the default.<br/>
uses -functions main<br/>
However, it is best to use the names listed in the kinds table.<br/>
<i><b>49</b></i><br/>
<hr/>
<a name=56></a><i>Chapter 4: Access Fundamentals</i><br/>
Multiple kinds may be specified:<br/>
<b>uses -macro -funct main</b><br/>
 1  (funct)  fprintf<br/>
 2  (macro)  NULL<br/>
 3  (funct)  fopen<br/>
 4  (funct)  write_ct_file<br/>
 5  (funct)  getenv<br/>
 6  (funct)  strcpy<br/>
 7  (macro)  stderr<br/>
 8  (funct)  fclose<br/>
 9  (funct)  exit<br/>
10  (funct)  read_mt_file<br/>
11  (funct)  strcat<br/>
<b>NOTE</b><br/>
Non-symbol kinds (data cells, AST nodes, instances, and so on.) are not <br/>indexed, and so uses/defines queries on these kinds does not return results.<br/>
<b>Command where and Its Subcommands</b><br/>
The <b>where</b> command takes a required parameter: <br/>declared|defined|referenced|used|included.<br/>
<b>Other Commands</b><br/>
Refer to Appendix A:<a href="AccessGuides.html#101"> “Access Commands” on page 95 for </a>a complete list <br/>of Access commands. A few are mentioned here to give the flavor of how <br/>DIScover queries map to Access commands:<br/>
friend_of<br/>
get_include_files<br/>
get_member_data<br/>
get_member_functions<br/>
get_super_classes<br/>
get_sub_classes<br/>
instances<br/>
<i><b>50</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=57></a><img src="AccessGuide-57_1.png"/><br/>
<i>Access Specific Commands</i><br/>
<b>Access Specific Commands</b><br/>
The following sections detail common Access-specific commands; <br/>however, a comprehensive list of all Access commands appears in <br/>Appendix A: <a href="AccessGuides.html#101">“Access Commands”</a> on<a href="AccessGuides.html#101"> page 95.</a><br/>
<b>apply</b><br/>
apply attribute-expression set<br/>
When passed a set of elements (instead of a single element), apply <br/>concatenates the result of applying the attribute expression to each element <br/>in turn. Duplicates are removed from the resulting set prior to returning. <br/>The resulting set is ordered alphabetically, so there is no guarantee of a <br/>relation between the order of the input set and the output.<br/>
<b>filter</b><br/>
filter attribute-expression set<br/>
filter applies attribute-expression to each member of set and <br/>creates a return set that contains only those members for which attribute <br/>expression returned true. “True” is non-zero for numeric values and non-<br/>empty for string values.<br/>
<b>sort</b><br/>
sort [-a|-d] attribute-list set<br/>
sort orders the members of set in the default ascending (-a) or <br/>descending (-d) option order, according to the value of the attribute <br/>attribute applied to each member. Note that sort takes only an attribute—<br/>not an attribute expression—as an argument. If you need to sort on an <br/>attribute-expression, or on an attribute function, you must define a new <br/>attribute that captures the complex expression in a single attribute.<br/>
<b>Set Operations</b><br/>
The following set operations take sets as arguments and return new sets. <br/>The original sets (the arguments) are unchanged.<br/>
<b>set_intersect</b><br/>
set_intersect A B<br/>
This command returns the intersection of sets A and B. Duplicates are <br/>removed.<br/>
<b>set_subtract</b><br/>
set_subtract A B<br/>
<i><b>51</b></i><br/>
<hr/>
<a name=58></a><i>Chapter 4: Access Fundamentals</i><br/>
This command returns the members of set A that are not in set B. <br/>Duplicates in either set A or set B are removed prior to the subtraction: if A <br/>contains two copies of one entity and set B contains one copy of the same <br/>entity, the result is empty, not one copy of the entity.<br/>
<b>set_union</b><br/>
set_union A B<br/>
This command returns the union of sets A and B. The result set contains <br/>unique elements, even if A or B contain multiple instances of an element.<br/>
<b>set_unique</b><br/>
set_unique set<br/>
This command returns a set that contains only one instance of the entities <br/>contained in the set.<br/>
<b>size</b><br/>
size set<br/>
This command returns the number of elements in the set. Applied to an <br/>element, <b>size</b> returns one: the element is converted into a set with one <br/>element.<br/>
<b>print</b><br/>
print set<br/>
<b>print</b> expects as an argument a set of elements. For each element, it prints <br/>an index number and the element using the state set by the <b>printformat</b> <br/>command. It returns nothing.<br/>
<b>Printformat</b><br/>
printformat [-s [-a|-d]] format_string attribute-list<br/>
Like <b>sort</b>, the <b>printformat</b> command does not take attribute <br/>expressions. The format string can contain the following placeholders that <br/>are substituted for the corresponding attribute:<br/>
<br/>
%s, replace /string with value<br/>
<br/>
%S, (same as %s), capitalize the first character<br/>
<br/>
%b, if attribute is true, print name of attribute; otherwise, print <br/>nothing.<br/>
<br/>
%B, (same as %b), capitalize the first character in the attribute<br/>
<br/>
-s, sort<br/>
<i><b>52</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=59></a><img src="AccessGuide-59_1.png"/><br/>
<i>Access Specific Commands</i><br/>
<br/>
-a, sort ascending<br/>
<br/>
-d, sort descending<br/>
The %b attribute may be used to generate more meaningful output for <br/>boolean attributes like “virtual” or “static”, for example:<br/>
printformat %b%s constant name<br/>
uses main<br/>
returns<br/>
1  _IO_stderr_<br/>
2  fprintf<br/>
...<br/>
18  fclose<br/>
19  w<br/>
20  r<br/>
21  constant 1<br/>
22  constant 0<br/>
Note that <b>print</b> inserts a space after attributes it prints to prevent them <br/>from running together. This also allows you to combine multiple attributes <br/>easily without having extra spaces appear if the booleans do not match:<br/>
printformat %b%b%b%s macro constant funct name<br/>
<b>NOTE</b><br/>
The format expression %s%s kind name is probably easier if you are just <br/>trying to identify the element’s type.<br/>
The -s modifier causes print to sort its results in either ascending (-a) or <br/>descending (-d) order. This also reorders the result set.<br/>
You may use string literals in the format string to decorate the output.<br/>
<b>Miscellaneous </b><br/>
<b>Describe Access-command </b><br/>
<b>Commands</b><br/>
describe Access-command <br/>
<i><b>53</b></i><br/>
<hr/>
<a name=60></a><i>Chapter 4: Access Fundamentals</i><br/>
Available from Access sessions within an interactive environment (as one <br/>started in the Browser), this command prints a short description and usage <br/>for the command <b>Access-command.</b> This lightweight form of online help <br/>can be useful during interactive sessions:<br/>
describe where<br/>
ast code: where<br/>
returns<br/>
codeintegrity command: where<br/>
Collective command for &#34;where&#34; queries<br/>
where [ declared | defined | included | referenced | <br/>
used ] entity_name ...<br/>
<b>Info Commands</b><br/>
info commands [glob-pattern]<br/>
This command is not a true Access command, but the Tcl <b>info</b> commands <br/>includes the list of Access commands added to the interpreter. If a pattern <br/>is specified, the result is filtered for commands that match the pattern. It is <br/>useful in conjunction with <b>describe</b>.<br/>
<b>Info Attributes</b><br/>
info attributes [glob-pattern]<br/>
This command returns the complete list of Access attributes. (Access adds <br/>the “attributes” selector to the Tcl <b>info</b> command.) If glob-pattern is <br/>specified, return only those attributes that match glob-pattern.<br/>
<b>&gt; Filename</b><br/>
&gt; filename command <br/>
This command redirects the output of command to filename. The contents <br/>of filename are overwritten. This command should only be used to <br/>capture output from the <b>print</b> command (or tree print), which does not <br/>return the string it prints; in other cases more traditional forms of output <br/>work equally well.<br/>
<b>&gt;&gt; Filename</b><br/>
&gt;&gt; filename command <br/>
This command is similar to &gt;, but appends its output to filename.<br/>
<i><b>54</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=61></a><img src="AccessGuide-61_1.png"/><br/>
<i>Groups</i><br/>
<b>Groups</b><br/>
Access provides a facility for manipulating DIScover groups—those <br/>named collections accessible from the group manager and other <br/>components of the user interface. Like Access sets, groups can contain <br/>multiple elements. Groups can be passed to Access procedures, and can be <br/>the object of set operations; in both cases, they are automatically converted <br/>into Access sets. Unlike sets, they are named. Also unlike sets, they are not <br/>reference counted, but continue to exist until they are deleted or until <br/>session in which they are created ends. Groups created using Access <br/>appear in the Group Manager, and may be saved permanently (either <br/>using the Group Manager or using an Access command).<br/>
<b>Group </b><br/>
<b>Group New</b><br/>
<b>Commands</b><br/>
The <b>group new</b> command creates a new group. It takes two arguments: <br/>the name of the new group and its contents. For example:<br/>
group new my_group main<br/>
creates a new group called “my_group”. You can verify this by opening <br/>the group manager. You can view its contents by using the group manager <br/>or the <b>print</b> command (see next).<br/>
<b>Group Print</b><br/>
The <b>print group</b> command displays the content of a group in terms of <br/>the symbol kind and name. Its output depends on the specified print <br/>format, for example:<br/>
print my_group<br/>
(funct) main<br/>
<b>Group Get</b><br/>
The internal data representation of groups is different than the <br/>representation for Access sets. The contents of a group may be retrieved in <br/>set format using the <b>group get</b> command. This set is a copy of the <br/>elements in the set, and not the group itself:<br/>
sappend [group get my_group] main<br/>
This command does not change the size of my_group. <br/>
In Access commands that are expecting an Access set, and the name of a <br/>group is passed instead, Access uses <b>group get</b> in its place. The <br/>exceptions are in commands that modify sets, as in <b>sappend</b>.<br/>
<i><b>55</b></i><br/>
<hr/>
<a name=62></a><i>Chapter 4: Access Fundamentals</i><br/>
Although this conversion makes groups and sets appear to behave in a <br/>similar fashion, groups are different from Access sets. The <b>group get</b> <br/>command creates a copy of the group’s contents, but changes made to this <br/>set—<b>sappend</b>, for example—are not seen in the group itself.<br/>
<b>Group </b><br/>
<br/>
<b>info</b> displays all the groups that are available <br/>
<b>Subcommands</b><br/>
<br/>
<b>new</b> creates a new group<br/>
<br/>
<b>delete</b> permanently removes a group and its contents<br/>
<br/>
<b>tmp</b> specifies that the group in question is available only for the <br/>current session<b> </b><br/>
<br/>
<b>save</b> permanently stores the group<br/>
<br/>
<b>saveas</b> creates another group with the same content as the current <br/>group<br/>
<br/>
<b>replace</b> changes the contents of an existing group with new contents<br/>
<br/>
<b>rename</b> changes the name of a group<br/>
<br/>
<b>set</b> assigns elements to the group<br/>
<br/>
<b>get</b> retrieves the group contents<br/>
<br/>
<b>size</b> displays the number of members in a group<br/>
<br/>
<b>exists</b> tests the existence of a specified group name<br/>
<br/>
<b>add</b> adds elements to an existing group<br/>
<br/>
<b>remove</b> removes specified elements from an existing group.<br/>
<b>Importing and </b><br/>
Saved groups are written to text files according the specification made in <br/>the groupsPath preference in the Preferences file. When importing or <br/>
<b>Exporting </b><br/>
exporting groups, it is tempting to read or write these group files directly. <br/>
<b>Groups</b><br/>
Usually it is more reliable to create or export the groups using an Access <br/>procedure, for the following reasons:<br/>
<br/>
When importing new groups, new group files are not seen until DIScover is restarted.<br/>
<br/>
When importing new groups, most external applications do not have <br/>access to all the information encoded in a group file. Access provides <br/>more control over the conversion of strings to objects than the group <br/>file does.<br/>
<i><b>56</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=63></a><img src="AccessGuide-63_1.png"/><br/>
<i>Closure</i><br/>
<br/>
When exporting groups, an Access script provides better formatting <br/>capabilities than the group file.<br/>
<br/>
Import/export procedures are not sensitive to changes in the group <br/>file format.<br/>
<b>Closure</b><br/>
The DIScover Browser provides a <b>closure</b> button that modifies the <br/>operation of queries: when closure is selected, the results of a query are <br/>appended to the initial set and the query is run again. This process <br/>continues until the result set does not grow.<br/>
The closure operation is not built into Access queries; instead a <br/>query_closure procedure is defined that uses the set operations to <br/>implement closure. Its syntax is:<br/>
query_closure int query src<br/>
This command starts by running the query on src, and repeats it on the <br/>union of the input and the resulting set until the result does not change. At <br/>most, it makes number of iterations specified by int.<br/>
Depending on your query, it may be more efficient to implement your own <br/>closure.<br/>
<i><b>57</b></i><br/>
<hr/>
<a name=64></a><i>Chapter 4: Access Fundamentals</i><br/>
<i><b>58</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=65></a><img src="AccessGuide-65_1.png"/><br/>
<img src="AccessGuide-65_2.png"/><br/>
<b>Tree Pattern Matching</b><br/>
<i>5</i><br/>
<b>KEY TERMS: </b>Abstract Syntax Tree, Change Propagation, node, attribute, attribute <br/>
expression, attribute iterators, tree subcommands, tree navigation <br/>
This chapter explains the DIScover Tree Pattern Matching (TPM). <br/>TPM extends Access to provide access to Abstract Syntax Trees (ASTs)—<br/>complete parse trees constructed and saved while building the information <br/>model. By searching these parse trees for specific constructs, TPM can find <br/>many different constructions of interest, from most of the Quality <br/>Assessment Report queries to issues specific to your organization like <br/>coding standards violations, portability or threading concerns, <br/>internationalization, and the like.<br/>
TPM is the ideal tool for many large-scale code transformation tasks, and <br/>can analyze vast regions of code for potential programming flaws. TPM <br/>can identify and catalog almost any type of programming construct found <br/>within your source code.<br/>
This chapter covers the following topics:<br/>
<br/>
<a href="AccessGuides.html#66">“Abstract Syntax Trees” o</a>n<a href="AccessGuides.html#66"> page 60</a><br/>
<br/>
<a href="AccessGuides.html#67">“AST Nodes” </a>on<a href="AccessGuides.html#67"> page 61</a><br/>
<br/>
<a href="AccessGuides.html#68">“Displaying the AST” o</a>n<a href="AccessGuides.html#68"> page 62</a><br/>
<br/>
<a href="AccessGuides.html#69">“Attributes of AST Nodes”</a> on<a href="AccessGuides.html#69"> page 63</a><br/>
<br/>
<a href="AccessGuides.html#71">“Tree Subcommands” on page 65</a><br/>
<br/>
<a href="AccessGuides.html#74">“Navigation in Attribute Expressions” </a>on<a href="AccessGuides.html#74"> page 68</a><br/>
<br/>
<a href="AccessGuides.html#76">“Find and Search Attribute Functions” on page 70</a><br/>
<br/>
<a href="AccessGuides.html#77">“Attribute Iterators”</a> on<a href="AccessGuides.html#77"> page 71</a><br/>
<br/>
<a href="AccessGuides.html#78">“Variable Capture in Attribute Expressions”</a> on<a href="AccessGuides.html#78"> page 72</a><br/>
<br/>
<a href="AccessGuides.html#79">“Attribute Expression Actions”</a> on<a href="AccessGuides.html#79"> page 73</a><br/>
<br/>
<a href="AccessGuides.html#79">“Writing Efficient TPM Expressions” on page 73</a><br/>
<i><b>59</b></i><br/>
<hr/>
<a name=66></a><img src="AccessGuide-66_1.png"/><br/>
<i>Chapter 5: Tree Pattern Matching</i><br/>
<b>Abstract Syntax Trees</b><br/>
During the parsing phase of source compilation—after preprocessing in <br/>the case of C/C++—the syntactic structure of the program emerges. Parts <br/>of this structure are decorated with attributes that capture the meaning of <br/>the parts: variable references are resolved to their storage areas, the type of <br/>objects is defined or clarified, calls to functions are noted, and implicit <br/>operations like type conversions or calls to constructors are made explicit. <br/>DIScover creates this structure as an abstract syntax tree, and stores <br/>this AST for later analysis.<br/>
The AST is a highly structured representation of a body of source code. It <br/>encapsulates all of the syntactical properties of the source in a format that <br/>can be formally manipulated. Each element or node in the tree represents a <br/>syntactical component and may have one or more subnodes. Direct <br/>descendants of a node are known as <i>children</i>. Children of the same node are <br/>known as <i>siblings</i>. An entire program can be described by the AST, starting <br/>from such high-level notions as file or function all the way down to such <br/>things as integer constant. The following illustrates some equivalent code <br/>fragments, and their corresponding AST:<br/>
Ca = x + 5 <br/>
Pascala := x + 5 <br/>
COBOLadd x, 5 giving a <br/>
Tclset a [ expr $x + 5 ] <br/>
ASTassign(a, add(x , 5)) <br/>
The preceding AST can be visualized logically as follows:<br/>
<i><b>60</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=67></a><img src="AccessGuide-67_1.png"/><br/>
<i>AST Nodes</i><br/>
The AST is stored as a strict tree. A root node is created for each file, and <br/>the ASTs for elements defined in those files are created as children of the <br/>file’s root node. The root node is called the <i>ast_root</i>.<br/>
<b>NOTE</b><br/>
Although the AST is called an abstract syntax tree, it is not always completely <br/>language independent (abstract). There is a number of cases where nodes are <br/>added to represent particular facets of a language; these cases are often <br/>important to TPM users. In checking coding standards in C, for example, it <br/>may be important to be able to distinguish between a then clause that is a <br/>single statement and a then clause that is a single statement enclosed in a curly <br/>brace block. In this case, the block is captured in the AST, even though its <br/>structure without the block is sufficient to understand the action of the <br/>program. The ast_root that describes the root of the file is another example of <br/>an artifact introduced to assist the TPM developer but that is not important for <br/>the action of the program.<br/>
<b>AST Nodes</b><br/>
The nodes of the AST are called—not surprisingly—AST nodes. These <br/>nodes are the primary operand of virtually all TPM functions and <br/>attributes.<br/>
The tree structure of the AST makes it possible to navigate from a node to <br/>its parent, siblings, or children. But such navigation requires a starting <br/>node.<br/>
<b>Converting </b><br/>
Chapte<a href="AccessGuides.html#43">r 2: “Access Fundamentals” </a>on<a href="AccessGuides.html#43"> page 37 int</a>roduces four basic Access <br/>data types: symbols, instances, ast_nodes, and data_cells.<br/>
<b>Entities</b><br/>
The <b>data</b> command attempts to convert entities from one type to another. <br/>Its syntax is:<br/>
data [symbol|instance|node|cell] <i>entity</i><br/>
For a file, <b>data node file</b> returns an ast_root node that serves as a <br/>parent for all the otherwise-independent roots (like function definitions or <br/>top-level declarations) in a file.<br/>
For a function, <b>data node function</b> returns the root node of that <br/>function definition.<br/>
<i><b>61</b></i><br/>
<hr/>
<a name=68></a><i>Chapter 5: Tree Pattern Matching</i><br/>
<b>data node</b> may, under some circumstances, also be applied to an instance. <br/>In this case, the AST node that spans the instance’s source text region is <br/>returned. For example, <b>data node instance-of-function</b> should <br/>return the AST node that represents the call to the function.<br/>
Conversion of instances to nodes is efficient if not completely reliable.<br/>
AST nodes may be converted to their corresponding symbol using the <br/><b>data symbol</b> command.<br/>
See also the s.symbol_attribute syntax in an attribute expression.<br/>
<b>Automatic </b><br/>
Some Access functions perform conversions automatically as required. For <br/>example, the <b>tree</b> commands require an AST node and attempt to convert <br/>
<b>Conversions</b><br/>
each of their arguments to AST nodes prior to running the command.<br/>
Many symbol attributes convert ast_nodes to the corresponding symbol <br/>before applying the attribute. The reverse does not apply: attributes that <br/>return attributes of an ast_node do not convert a symbol to its ast_node <br/>even if such a conversion is possible. Instead, they report an empty value.<br/>
<b>Displaying the AST</b><br/>
The Access command <b>tree print</b> takes an ast_node and prints a <br/>graphical representation of the node and its descendants, for example:<br/>
tree print [data node main]<br/>
returns<br/>
function_def 13809 4976 : ‘int main (arg ...  warning <br/>
*/ }’<br/>
  ast_declspec 13809 3 : ‘int’<br/>
  function_decl 13813 17 : ‘main (argc, argv)’<br/>
  | global_id 13813 4 : ‘main’<br/>
  | parm_decl 13835 9 : ‘int argc;’<br/>
  | | ast_declspec 13835 3 : ‘int’<br/>
  | | local_id 13839 4 : ‘argc’<br/>
  | parm_decl 13849 12 : ‘char **argv;’<br/>
  |   ast_declspec 13849 4 : ‘char’<br/>
  |   local_id 13856 4 : ‘argv’<br/>
  ast_block 13862 4923 : ‘{     int fil ...  warning */ <br/>
<i><b>62</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=69></a><img src="AccessGuide-69_1.png"/><br/>
<i>Attributes of AST Nodes</i><br/>
}’<br/>
    list_decl 13868 15 : ‘int file_count;’<br/>
    | ast_declspec 13868 3 : ‘int’<br/>
    | var_decl 13872 11 : ‘file_count;’<br/>
    |   local_id 13872 10 : ‘file_count’<br/>
    list_decl 13925 12 : ‘int proglen;’<br/>
    | ast_declspec 13925 3 : ‘int’<br/>
    | var_decl 13929 8 : ‘proglen;’<br/>
    |   local_id 13929 7 : ‘proglen’<br/>
[...]<br/>
Here you see the function definition for main: its return type followed by <br/>its signature, which in turn is made up of its name and full specifications of <br/>its parameters. The body of the function follows, starting with the local <br/>variable declarations.<br/>
The <b>tree print</b> command is essential for understanding and debugging <br/>TPM scripts. C++ in particular is a rich language with many subtleties; <br/>often the easiest way to build a TPM expression to match a construct is to <br/>take a sample of that construct to understand its exact structure.<br/>
<b>Attributes of AST Nodes</b><br/>
Chapter 2:<a href="AccessGuides.html#43"> “Access Fundamentals” o</a>n<a href="AccessGuides.html#43"> page 37 i</a>ntroduces attributes that <br/>have meaning when applied to symbols. TPM adds attributes that are <br/>applicable to AST nodes; you can access these attributes the in same way <br/>you do the attributes of symbols:<br/>
apply kind [data node main]<br/>
ast<br/>
All AST nodes are of kind “ast”—kind does not subclass AST nodes the <br/>way it does symbols. Instead, the attribute ast_code returns the sub-type <br/>of the node:<br/>
apply ast_code [data node main]<br/>
function_def<br/>
The ast_code attribute is used by the <b>tree print</b> command; ast_codes <br/>may be global_id, list_decl, local_id, for_stmt, and so on.<br/>
The attribute ast_info is made up of the ast_code, the byte offset of the <br/>text, its length, and the source text elided to fit on one line:<br/>
apply ast_info [data node main]<br/>
function_def 13809 4976 ‘int main (arg ...<br/>
warning */<br/>
\}’<br/>
<i><b>63</b></i><br/>
<hr/>
<a name=70></a><i>Chapter 5: Tree Pattern Matching</i><br/>
When displaying AST nodes in an interactive Access session, ast_info is <br/>a useful printformat attribute:<br/>
printformat %s ast_info<br/>
Each ast_code corresponds to a boolean attribute. The attribute returns 1 <br/>(true) if the node is of that ast_code; otherwise, 0.<br/>
apply function_def [data node main]<br/>
1<br/>
apply loop_stmt [data node main]<br/>
0<br/>
These attributes do not automatically convert their arguments from <br/>symbols to AST nodes:<br/>
apply function_def [data symbol [data node main]]<br/>
0<br/>
Similar types of AST structures can be described by the same AST category <br/>code. For example, if statements (if_stmt) and loop statements <br/>(loop_stmt) are both members of the same general category—statements <br/>(ast_stmt). The category for a particular AST can be obtained with the <br/>astcategory attribute and can be used as a boolean attribute, just like <br/>concrete AST codes.<br/>
AST nodes maintain their mapping to source text. The ast_text for a <br/>node returns the section of text that corresponds to the parse tree for that <br/>node:<br/>
apply ast_text main<br/>
{int main (argc, argv)<br/>
    int argc;<br/>
    char **argv;<br/>
{<br/>
    int file_count;     /* number of files to process */<br/>
    int proglen;       /* length of progname */<br/>
    int optc;          /* current option */<br/>
    EXPAND(argc, argv); /* wildcard expansion if <br/>
necessary*/<br/>
. . .<br/>
return exit_code; /* just to avoid lint warning */<br/>
}}<br/>
<b>NOTE</b><br/>
The extra pair of curly braces in the preceding example is provided by Tcl to <br/>indicate that this is a single string and not a list.<br/>
<i><b>64</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=71></a><img src="AccessGuide-71_1.png"/><br/>
<i>Tree Subcommands</i><br/>
<b>Accessing </b><br/>
Recall that ast_nodes are different from symbols, and many symbol <br/>attributes return empty when applied to ast_nodes. This is true for the <br/>
<b>Symbol </b><br/>
args attribute, for example:<br/>
<b>Attributes</b><br/>
apply args main<br/>
(int,char**)<br/>
apply args [data node main]<br/>
{}<br/>
apply args [data symbol [data node main]]<br/>
(int,char**)<br/>
When creating an attribute expression that applies to ast_nodes, it is often <br/>useful to be able to access the attributes for the symbol that corresponds to <br/>the data node. You can query symbol attributes by preceding the attribute <br/>name with “s.”: this converts the ast_node to a symbol (temporarily) and <br/>returns the value of the attribute:<br/>
apply s.args [data node main]<br/>
(int,char**)<br/>
<b>Tree Subcommands</b><br/>
In the preceding section, the <b>apply</b> command was used to access the <br/>attributes of the function_def node associated with the symbol “main”. <br/>In this case, the AST node for this function_def was readily available by <br/>converting the symbol “main”. However, for most of the nodes in the tree, <br/>such a ready conversion from the indexed, pre-related world of symbols is <br/>not available. Instead, queries on AST nodes typically involve navigating a <br/>portion of the AST looking for nodes of interest. The <b>tree</b> command <br/>provides an interface for examining all the nodes in a subtree, starting with <br/>a defined node and visiting all of its descendants.<br/>
If passed something other than an AST node (or set of AST nodes), the <br/><b>tree</b> command attempts to convert its arguments into AST nodes prior to <br/>navigating the subtrees.<br/>
<b>tree print</b><br/>
tree print ast_nodes<br/>
This command, already introduced, navigates the tree starting with the <br/>node it is passed. It formats the output to show the tree structure, with <br/>increasing levels of indentation to indicate children, and vertical lines tying <br/>together siblings.<br/>
<i><b>65</b></i><br/>
<hr/>
<a name=72></a><i>Chapter 5: Tree Pattern Matching</i><br/>
<b>tree find</b><br/>
<b>tree find</b> is the workhorse of TPM. Its syntax is:<br/>
tree find attribute-expression ast_nodes<br/>
<b>tree find</b> examines the AST nodes in ast_nodes and all of their <br/>descendants. It applies the attribute expression to each node, and if the <br/>attribute-expression returns true, that node is added to the return set.<br/>
Before using <b>tree find</b> in an interactive session, set the printformat to <br/>ast_info:<br/>
printformat %s ast_info<br/>
This makes the results returned in interactive Access sessions much more <br/>readable.<br/>
From the index, you can determine that main uses a number of functions:<br/>
uses -functions [data symbol main]<br/>
returns 21 functions.<br/>
But using the <b>tree find</b> command, you can find those exact calls:<br/>
tree find call_expr [data node main]<br/>
returns<br/>
 1  call_expr 14095 17 ‘basename(argv[0])’<br/>
 2  call_expr 14128 16 ‘strlen(progname)’<br/>
 3  call_expr 0 0 ‘’<br/>
 . . .<br/>
34  call_expr 17301 14 ‘do_exit(ERROR)’<br/>
35  call_expr 17637 74 ‘fprintf(stder ...,progname)’<br/>
36  call_expr 17795 80 ‘fprintf(stder ... name,optarg)’<br/>
37  call_expr 17885 14 ‘do_exit(ERROR)’<br/>
38  call_expr 18530 26 ‘treat_file(argv[optind++])’<br/>
39  call_expr 18597 13 ‘treat_stdin()’<br/>
40  call_expr 18663 15 ‘do_list(-1, -1)’<br/>
41  call_expr 18709 18 ‘do_exit(exit_code)’<br/>
<i><b>66</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=73></a><img src="AccessGuide-73_1.png"/><br/>
<i>Tree Subcommands</i><br/>
There are some things to note about this output. First, the number of call <br/>expressions is greater than the number of functions called. In this excerpt, <br/>there are two calls to fprintf and three calls to do_exit. This should not <br/>be surprising in light of the differences between the symbols in the index <br/>and the detail in the AST. Second, the third call_expr has no starting <br/>offset and no length: it cannot be mapped to the source text. In this case, <br/>this is because the function call is the result of the expansion of the macro <br/>“strequ”. This does not imply that no information is available about that <br/>call. In fact, the opposite is true:<br/>
tree print 3<br/>
call_expr 0 0<br/>
  global_id 0 0<br/>
  minus_expr 14226 18 : ‘progname+proglen-4’<br/>
  | plus_expr 14226 16 : ‘progname+proglen’<br/>
  | | global_id 14226 8 : ‘progname’<br/>
  | | local_id 14235 7 : ‘proglen’<br/>
  | global_id 14243 1 : ‘4’<br/>
  convert_expr 0 0<br/>
    global_id 0 0<br/>
The first child—the global_id—is the function called; its cname attribute <br/>is interesting. While easier ways of getting at this node are presented <br/>shortly, it is already possible to obtain (albeit imprecisely) the attribute for <br/>this node (and a few others):<br/>
printformat %s%s cname ast_info<br/>
tree find global_id 3<br/>
returns<br/>
1  strcmp global_id 0 0 ‘’<br/>
2  progname global_id 14226 8 ‘progname’<br/>
3  4 global_id 14243 1 ‘4’<br/>
4  .exe global_id 0 0 ‘’<br/>
<b>tree filter</b><br/>
The syntax for <b>tree filter</b> is the same as <b>tree find:</b> tree filter <br/>attribute-expression scope, and its semantics are quite similar: it <br/>returns a set of nodes that match the attribute expression. However, unlike <br/><b>tree find</b>, <b>tree filter</b> does not consider the descendents of scope: it <br/>only considers those nodes that are explicitly passed.<br/>
The only difference between <b>filter</b> and <b>tree filter</b> is that <b>tree <br/>filter</b> converts its arguments to AST nodes before filtering through <br/>application of the attribute expression.<br/>
<i><b>67</b></i><br/>
<hr/>
<a name=74></a><i>Chapter 5: Tree Pattern Matching</i><br/>
<b>tree navigate</b><br/>
<b>tree navigate</b> is very similar to <b>tree filter</b>; it applies attribute-<br/>
expression to each node in <b>scope</b>, and returns a node for each time the <br/>attribute-expression succeeds. The navigate comes in because the <br/>returned node may not be a node in <b>scope</b>, but instead may be related to it <br/>in a way described by an extended attribute expression. The semantics of <br/>tree navigate are discussed later in this chapter.<br/>
<b>Navigation in Attribute Expressions</b><br/>
<a href="AccessGuides.html#50">“Compound Attribute Expressions”</a> on <a href="AccessGuides.html#50">page 44</a> explains that there is a <br/>current element (each element passed to apply, or a node and each of its <br/>descendents in a <b>tree find</b> command) against which each attribute in the <br/>attribute expression is applied.<br/>
TPM introduces new attributes that have the side-effect of changing the <br/>element that the attributes in the attribute expression are applied against. <br/>This permits the creation of attribute expressions that can examine the <br/>context of a node, and not just the node itself.<br/>
These attributes are:<br/>
<br/>
-&gt; move down to current node’s first child<br/>
<br/>
&lt;- move to current node’s parent<br/>
<br/>
, move to current node’s next sibling<br/>
<br/>
-- move to current node’s previous sibling<br/>
Like all attributes, these return a value. All these navigation commands are <br/>booleans: they return one or zero to indicate success or failure. It is not <br/>considered a failure to move from a node that has no children to the node’s <br/>child, or to a parent node when there is no parent, or to a sibling node with <br/>no sibling. Such attempts simply change the current node to nil. Attempts <br/>to navigate from nil are considered failures.<br/>
There are two navigation-related attributes:<br/>
<br/>
. does not change current node. Succeeds if current node is non-nil<br/>
<br/>
nil succeeds if current node is nil<br/>
<i><b>68</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=75></a><img src="AccessGuide-75_1.png"/><br/>
<i>Navigation in Attribute Expressions</i><br/>
Following is an example of a TPM expression to find function declarations <br/>in /xip that take int as their first argument:<br/>
tree find {function_decl -&gt; , type == &#34;int&#34;} /xip<br/>
returns<br/>
1  InterfaceInit function_decl 1966 26 ‘InterfaceInit <br/>
(argc, argv)’<br/>
2  main function_decl 4743 17 ‘main (argc, argv)’<br/>
3  NewImageWin function_decl 7637 21 <br/>
‘NewImageWin(pipe_num)’<br/>
4  CanvasRectShadow function_decl 4410 39 <br/>
‘CanvasRectSha ... idth, height)’<br/>
5  CanvasLineShadow function_decl 4744 34 <br/>
‘CanvasLineSha ...  y1 , x2, y2)’<br/>
During evaluation of the attribute expression, most nodes are immediately <br/>thrown away since the attribute function_decl applied to them failed. <br/>For those that succeed, the current node is moved (via the -&gt; attribute) to <br/>the child of the function declaration: to the name of the function. The <br/>current node is again moved—this time via the comma attribute—to the <br/>first parameter of the function. The type of this parameter is compared to <br/>&#34;int&#34; and succeeds for those that match the criteria.<br/>
<b>Tree Navigation</b><br/>
In <b>tree filter</b> and <b>tree find</b> expressions, the result set is the set of <br/>nodes that match the attribute expression. For <b>tree navigate</b>, the result <br/>set is the set of nodes that were current when the attribute expression <br/>succeeded. For example, if you captured the results of the “functions that <br/>take int as their first parameter” query, and wanted to know the name of <br/>that parameter when the function was declared, <b>tree navigate</b> can be <br/>used to capitalize on the work already done by the <b>tree find</b> operation:<br/>
set interesting_functions [tree find {function_decl -&gt; <br/>
, type == &#34;int&#34;} /xip<br/>
tree navigate {-&gt; , -&gt; ,} $interesting_functions<br/>
returns<br/>
1  argc local_id 2000 4 ‘argc’<br/>
2  argc local_id 4768 4 ‘argc’<br/>
3  pipe_num local_id 7667 8 ‘pipe_num’<br/>
4  x local_id 4458 1 ‘x’<br/>
5  x1 local_id 4787 2 ‘x1’<br/>
<i><b>69</b></i><br/>
<hr/>
<a name=76></a><i>Chapter 5: Tree Pattern Matching</i><br/>
However, the preceding example demonstrates inefficiency in two ways. <br/>First, with some creative work, the variable names could have been <br/>determined in the first pass using <b>tree find</b>, for example:<br/>
tree find {local_id type == &#34;int&#34; &lt;- parm_decl -- <br/>
global_id &lt;- function_decl }    /xip<br/>
But this scans all the nodes in /xip; something that has already been done <br/>in the original <b>tree find</b>. If you are looking for both answers—the <br/>functions and their parameter names—it is much more efficient to find <br/>one, then get to the other via tree navigation. Second, a TPM expression is <br/>probably not the best way to find the functions that take an &#34;int&#34; as their <br/>first parameter; this is already stored in the signature of the function, <br/>which is available from Access queries. An Access query would avoid <br/>scanning the tree altogether, leaving only a relatively efficient tree navigate <br/>to find the names of the parameters.<br/>
<b>Find and Search Attribute Functions</b><br/>
<b>Find</b><br/>
<b>find</b>(attribute-expression) examines the current node and all its <br/>descendants, and returns the number of descendents that match the <br/>attribute expression. Side-effects, like changing the current node, are seen <br/>inside the attribute-expression, but once the attribute expression <br/>succeeds (or fails), the current node is restored: changes made inside <br/>attribute-expression are not visible to an enclosing expression.<br/>
When used as a boolean check, it is more efficient to use <br/><b>find1</b>(attribute-expression). Like <b>find</b>, <b>find1</b> navigates the <br/>subtree of the current node, applying attribute-expression, but <br/>returns as soon as the first match is made against attribute-<br/>expression. <br/>
<b>Search</b><br/>
<b>search</b>(attribute-expression)is similar to <b>find</b> in that it traverses a <br/>subtree and returns a count of nodes that match attribute-expression. <br/>While <b>find</b> considers only the current node and its descendants, <b>search</b> <br/>considers the current node, the current node’s &#34;later&#34; siblings, and all their <br/>descendents.<br/>
<b>search1</b>(attribute-expression) is provided for efficiency when only <br/>a boolean match is required. It returns 1 if a match is found; otherwise, 0.<br/>
<i><b>70</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=77></a><img src="AccessGuide-77_1.png"/><br/>
<i>Attribute Iterators</i><br/>
In general, <b>find1</b> and <b>search1</b> should be preferred over find and search. <br/>It is only necessary to traverse all possible nodes when you are counting on <br/>a side-effect of your traversal (occurring only in attribute actions, <br/>introduced later).<br/>
<b>Attribute Iterators</b><br/>
Sometimes when writing a TPM expression, the target tree you are trying <br/>to match may not have a fixed structure. Attribute iterators introduce a <br/>way of optionally traversing nodes of a tree. The repeat iterator provides <br/>this functionality; related to it are the two forms of the int iterator, which <br/>are both much less common. The semantics are as follows:<br/>
<br/>
repeat(navigate-expression) stop-expression<br/>
r(navigate-expression) stop-expression<br/>
Start by evaluating stop-expression.  If stop-expression <br/>succeeds, return success. Otherwise, evaluate navigate-<br/>expression. If navigate-expression fails, return failure. If <br/>
navigate-expression succeeds, repeat.<br/>
<br/>
int(pattern)<br/>
Execute pattern exactly int times. Succeeds if pattern never fails.<br/>
<br/>
int..(pattern1) pattern2<br/>
Execute pattern1 int times. Then, while pattern2 does not match <br/>the current node, execute pattern1. Succeeds if pattern1 never fails <br/>and pattern2 succeeds once, thus terminating the loop.<br/>
<b>NOTE</b><br/>
Unlike the repeat iterator, the int iterators do not introduce new capability <br/>to attribute expressions—they are merely abbreviations for longer expressions.<br/>
Consider looking for uses of string constants. Strings in C are of type <br/>char const [], which converts readily into char const *—the way <br/>strings are passed in function calls. When looking for use of these string <br/>constants in a particular context, you need a way to skip over these <br/>conversions.<br/>
The AST picks up this conversion as a convert_expr. <br/>
<i><b>71</b></i><br/>
<hr/>
<a name=78></a><i>Chapter 5: Tree Pattern Matching</i><br/>
<b>Variable Capture in Attribute Expressions</b><br/>
At any point in an attribute expression, the value of the current node can <br/>be captured in a Tcl variable for use later in the attribute expression (the <br/>handle is only valid for the duration of the expression, so it cannot be used <br/>outside the attribute expression). This facility makes it easier to describe <br/>more richly the context of an attribute expression.<br/>
The syntax for this is variable_name: [the variable name followed by a <br/>colon].<br/>
Variables may be referenced in attribute expressions by preceding the <br/>variable name with a dollar sign. This variable substitution syntax is <br/>similar to variable substitution in Tcl.<br/>
The following tree find expression finds assignments of a variable to itself <br/>(the results assume your code contains the statement d = ::d;):<br/>
tree find {assign_expr -&gt; x: , $x} /<br/>
returns<br/>
1  assign_expr 291 5 ‘d = ::d’<br/>
<b>NOTE</b><br/>
This attribute expression would only return this hit if the variables d and ::d <br/>are the <i>same variable</i>. If the unqualified d referred to a local variable, then this <br/>match would not succeed.<br/>
Variables are often useful in conjunction with <b>find</b> or <b>search</b>. The <br/>following attribute expression might be used to find unused local <br/>variables:<br/>
tree find {var_decl -&gt; x: &lt;- &lt;- , ! search1($x)} /<br/>
This expression has a notable shortcoming: it finds most global variables. <br/>You can address this by using the global symbol attribute:<br/>
tree find {var_decl -&gt; !s.global x: &lt;- &lt;- , ! <br/>
search1($x)} /<br/>
<i><b>72</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=79></a><img src="AccessGuide-79_1.png"/><br/>
<i>Attribute Expression Actions</i><br/>
<b>Attribute Expression Actions</b><br/>
Access provides a mechanism for evaluating Tcl commands as the attribute <br/>expression is being parsed. These commands are called <i>actions</i>. Actions can <br/>be used to influence the success of an attribute expression, or they can be <br/>executed purely as a side effect, making them useful for debugging and <br/>also for TPM Change Propagation. While actions can be used in any <br/>attribute expression, they are most useful in TPM expressions, hence their <br/>introduction here. Actions have the following syntax:<br/>
<br/>
{ command }<br/>
Neutral action—execute command.<br/>Always succeeds.<br/>
<br/>
[ command ]<br/>
Emphatic action—execute command.<br/>Succeeds if the return value of command is not an<br/>empty string or zero.<br/>
The following expression uses actions to display the number of children a <br/>node has:<br/>
{ set x 0 } -&gt; r(, { incr x }) nil { puts $x }<br/>
The variable x is incremented each time a child is encountered. When there <br/>are no more children, the last term outputs the value of x to the user’s <br/>terminal.<br/>
<b>Writing Efficient TPM Expressions</b><br/>
<b>Optimize the </b><br/>
Use Access queries wherever possible to limit the starting points for a <br/>query. It is much more efficient to run a TPM expression over a few <br/>
<b>Scope of Your </b><br/>
hundred files than on every file in your sources. Remember that TPM is a <br/>
<b>Searches</b><br/>
linear search—it does not capitalize on the indexed database component of <br/>the Information Model.<br/>
<b>Manage the </b><br/>
Second, remember that this linear search involves loading of the parse tree <br/>for the file. The AST is loaded automatically as required. There are two <br/>
<b>ASTs in Memory</b><br/>
things to remember about having these parse trees in memory: a query <br/>runs faster when the AST is already in memory, and if you unload the AST <br/>tree when you are done with a query, DIScover consumes less process <br/>space.<br/>
<b>src_unload module</b> unloads the AST for the file module.<br/>
<i><b>73</b></i><br/>
<hr/>
<a name=80></a><i>Chapter 5: Tree Pattern Matching</i><br/>
If you are running multiple queries, try and write your queries so they can <br/>be run against individual files. Then you can iterate through all the files of <br/>interest, and for each run all your queries and then unload the AST.<br/>
<b>Simple </b><br/>
The following pattern uses iteration to locate plus expressions that operate <br/>directly on the integer constant 1900:<br/>
<b>Examples</b><br/>
plus_expr -&gt; repeat(,) &#34;1900&#34;<br/>
After locating a plus expression and moving to its first child, the cname of <br/>the child is compared to 1900. For more information, see<a href="AccessGuides.html#50"> “Shortcuts” o</a>n <br/><a href="AccessGuides.html#50">page 44. I</a>f it does not match, the same comparison is done for each sibling <br/>until a match is found or there are no more siblings left to compare.<br/>
<b>Advanced </b><br/>
<b>Example 1: Strings in Function Calls</b><br/>
<b>Applications</b><br/>
The task is to locate function calls that pass a string literal in the argument <br/>list. Your first impulse might be to use something like the following TPM <br/>command:<br/>
tree find { call_expr find(string) } /proj<br/>
This, however, matches expressions which contain strings inside of <br/>subexpressions, as well as those that use strings directly. The following <br/>code fragment yields two matches—foo(...) and bar(...):<br/>
foo(bar(&#34;abc&#34;), x)<br/>
In addition, this command is not as efficient as it could be. The domain of <br/>possible matches is every node in the specified scope. To narrow down the <br/>domain, use traditional Access queries in combination with patterns, as in <br/>the following example:<br/>
set strings [ uses -string /proj ]<br/>
set instances [ instances $strings ]<br/>
tree navigate { r(&lt;- ast_expr) call_expr } $instances<br/>
The instances are converted to nodes by <b>tree</b>, which then moves upwards <br/>along the AST until an expression is found. If the expression represents a <br/>function call, then the function call expression is a match.<br/>
The only problem with the above sequence of commands is that when <br/><b>tree</b> converts the instances to nodes, model information for an arbitrary <br/>number of source files may get loaded, depending on how many strings <br/>there are in the project and where these strings are located. This can be <br/>memory intensive if the project is extremely large. In addition, you would <br/>have to unload these files manually after the pattern is executed by using <br/>the <b>src_unload</b> command or <b>File &gt; Unload</b> in the Browser. <br/>
<i><b>74</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=81></a><img src="AccessGuide-81_1.png"/><br/>
<i>Writing Efficient TPM Expressions</i><br/>
The <b>apply_per_file</b> wrapper loads files as necessary, and unloads them <br/>when they are no longer needed. Using the <b>apply_per_file</b> wrapper can <br/>assist in the handling of memory intensive task, as in the preceding <br/>example. The following sequence of commands is a scalable solution for <br/>the task at hand:<br/>
set strings [ uses -string /proj ]<br/>
set instances [ instances $strings ]<br/>
apply_per_file &#34;string args”<br/>
\<br/>
&#34;tree navigate {r (&lt;-ast_expr) call_expr}&#34;\<br/>
$instances<br/>
The <b>apply_per_file </b>command also provides you with the added benefit <br/>of a visual progress indicator and cancel button. For more information on <br/>using the apply_per_file wrapper, see<a href="AccessGuides.html#107"> “Auxiliary Commands” o</a>n <br/><a href="AccessGuides.html#107">page 101.</a><br/>
<b>Example 2: Unterminated Varargs Parameter List</b><br/>
Many functions that take a variable number of arguments require that the <br/>last argument be NULL or some other distinct value to terminate the list of <br/>parameters. If the caller fails to terminate the parameter list, the behavior is <br/>undefined. This type of error could result in data corruption or abnormal <br/>termination of the program. For example, the XtVa family of functions in <br/>the Xt library (available on the Unix platform for use with the X11 <br/>windowing system) are variable argument functions that require the last <br/>argument to be NULL (or simply 0). A properly formed call to an XtVa <br/>routine might look like the following (this example uses identifiers found <br/>in the Motif user interface library):<br/>
Widget frame = XtVaCreateWidget(&#34;frame”,<br/>
xmFrameWidgetClass, base,<br/>
XmNtopAttachment, XmATTACH_FORM,<br/>
XmNtopOffset, 1,<br/>
NULL);<br/>
<i><b>75</b></i><br/>
<hr/>
<a name=82></a><i>Chapter 5: Tree Pattern Matching</i><br/>
To identify malformed calls in which the last argument is not NULL, you <br/>first need to find all of the calls to XtVa functions. Once you have <br/>completed this task, navigate to the last argument, and test if it is zero. <br/>(Since NULL is a macro defined to be 0 or 0L, it is treated as an integer <br/>constant whose cname is 0.) The following is a handy procedure that can <br/>be used to find malformed XtVa calls in any file or project:<br/>
proc dangling_varargs { domain } {<br/>
set func [ uses -functions $domain ]<br/>
set varargs [ filter {regexp(&#34;XtVa”, name)} $func ]<br/>
set inst [ instances $varargs ]<br/>
set calls [ tree navigate {(-- nil) &lt;- call_expr} <br/>
$inst ]<br/>
set bad [ tree filter {-&gt; r(,)(, nil) cname!=”0”} <br/>
$calls ]<br/>
return $bad<br/>
}<br/>
For example:<br/>
% dangling_varargs /proj<br/>
1  call_expr 578 55 `XtVaSetValues ... idget, toolb)’<br/>
2  call_expr 525 51 `XtVaCreateWid ... tClass, base)’<br/>
To avoid cases where an XtVa routine is used in a function call expression, <br/>but is not the target of the function call (for example, passing the address of <br/>an XtVa routine to another function), the first <b>tree</b> command removes <br/>nodes that are not the primary child of a call expression, and then returns <br/>the call expressions themselves. The <b>second tree</b> command filters these <br/>call expression nodes for argument lists that are not terminated by zero.<br/>
The <b>dangling_varargs</b> procedure could be easily modified to handle any <br/>function declared with variable arguments by defining the following <br/>procedure:<br/>
proc is_varargs { func } {<br/>
set inst [ instances $func ]<br/>
set decl [ tree navigate &lt;-function_decl $inst ]<br/>
set va [ tree filter {regexp(&#34;\.\.\.”,ast_text)} <br/>
$decl ]<br/>
return [ size $va ]<br/>
}<br/>
<i><b>76</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=83></a><img src="AccessGuide-83_1.png"/><br/>
<i>Writing Efficient TPM Expressions</i><br/>
This searches the declaration of a function for the ellipsis (...) construct <br/>and returns a value greater than zero if the function is elliptical. To use this <br/>procedure in dangling_varargs, remove the attribute filter statement <br/>and replace it with a loop that collects the elliptical functions:<br/>
proc dangling_varargs { domain } {<br/>
set func [ uses -functions $domain ]<br/>
set varargs [ nil_set ]<br/>
foreach f $func {<br/>
if { [ is_varargs $f ] } {<br/>
sappend $varargs $f<br/>
}<br/>
}<br/>
set inst [ instances $varargs ]<br/>
set calls [ tree navigate {(-- nil) &lt;- call_expr} <br/>
$inst ]<br/>
set bad [ tree filter {-&gt; r(,)(, nil) cname!=”0”} <br/>
$calls ]<br/>
return $bad<br/>
}<br/>
<i><b>77</b></i><br/>
<hr/>
<a name=84></a><i>Chapter 5: Tree Pattern Matching</i><br/>
<i><b>78</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=85></a><img src="AccessGuide-85_1.png"/><br/>
<img src="AccessGuide-85_2.png"/><br/>
<b>Change Propagation</b><br/>
<i>6</i><br/>
<b>KEY TERMS: </b>change propagation, TPM expression, diff, conflict<br/>
TPM Change Propagation (CP) is a facility for automatically modifying <br/>source text, based on the structured information available in the <br/>Information Model, particularly in the Abstract Syntax Tree. You can use <br/>this tool to automate tedious and error-prone operations. Conversion <br/>scripts that are based on the program structure instead of text strings are <br/>much more reliable than automated conversions using text-driven tools <br/>like sed or perl that do not model the source syntax.<br/>
This chapter covers the following topics:<br/>
<br/>
<a href="AccessGuides.html#86">“Event Sequence” o</a>n<a href="AccessGuides.html#86"> page 80</a><br/>
<br/>
<a href="AccessGuides.html#86">“Diff Initialization and Finalization” on page 80</a><br/>
<br/>
<a href="AccessGuides.html#87">“Making Changes” o</a>n<a href="AccessGuides.html#87"> page 81</a><br/>
<br/>
<a href="AccessGuides.html#88">“Applying Diffs” </a>on<a href="AccessGuides.html#88"> page 82</a><br/>
<br/>
<a href="AccessGuides.html#91">“diff_tpm_all” on page 85</a><br/>
<i><b>79</b></i><br/>
<hr/>
<a name=86></a><i>Chapter 6: Change Propagation</i><br/>
<b>Event Sequence</b><br/>
TPM/CP begins by identifying the set of nodes you want to rewrite and <br/>the changes you want to make to these nodes. Usually there is a TPM script <br/>that identifies the nodes, but the set of nodes may be generated through <br/>other means (a simple Access script, or even user input).<br/>
Changes are computed on a file-by-file basis. TPM/CP begins with the <br/>creation of a “diff file” for the source file. The TPM expression (or other <br/>script) then records the requested changes in this diff file. After all changes <br/>for the file are recorded, the diff file is closed and the cycle starts again on <br/>the next source file.<br/>
Multiple diff files are allowed per source file, so if you have multiple <br/>changes to make, you have the option of making all the changes to one file <br/>in one operation, or you can make each change in a separate pass over the <br/>entire source.<br/>
Once all the change requests have been recorded in the diff files, they are <br/>applied using the DIScover Browser. At this point, any conflicts that <br/>arise may be resolved by the user.<br/>
<b>Diff Initialization and Finalization</b><br/>
The actual diff commands to request modification operate on global <br/>structures. Each structure is capable of accepting requests for modification <br/>of a single file at a time; requests to modify nodes in a different file are <br/>silently ignored.<br/>
Initialization of the internal data structure requires two commands:<br/>
<b>diff_new <i>file</i></b><br/>
This command returns a handle to the internal structure. You then need to <br/>open the diff file and associate it with the handle using <b>diff_start</b>.<br/>
<b>diff_start <i>diff_handle change-id file</i></b><br/>
Change-id is a comment used to identify the changes and must be <br/>supplied to the <b>diff_finish</b> command.<br/>
After running the <b>diff*</b> commands to make the changes, this file must be <br/>closed before going on to the next file.<br/>
<i><b>80</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=87></a><img src="AccessGuide-87_1.png"/><br/>
<i>Making Changes</i><br/>
<b>diff_finish <i>diff_handle change-id file</i></b><br/>
<b>diff_finish</b> returns the number of changes recorded for the file, or a <br/>negative value on error.<br/>
You can reduce the memory requirements of your TPM/CP session by <br/>unloading the pset after analyzing the file using src_unload <i>file</i>.<br/>
For example:<br/>
set diff_data [diff_new $file]<br/>
set diff_comment “remove unused declarations”<br/>
diff_start $diff_data $diff_comment $file<br/>
# perform diff_commands for $file here<br/>
set diff_status [diff_finish $diff_data $diff_comment <br/>
$file<br/>
if {$diff_status &lt; 0} {<br/>
puts &#34;error applying diffs for file [name $file]&#34;<br/>
} else {<br/>
puts &#34;made $diff_status changes to [name $file]&#34;<br/>
}<br/>
src_unload $file<br/>
All these steps are performed automatically when using the <br/><b>diff_tpm_all</b> command.<br/>
<b>Making Changes</b><br/>
You can make changes by calling <b>diff</b> commands after the diff structures <br/>for the file to be changed have been initialized. You can call these <br/>commands from actions inside TPM expressions (in this case, the side-<br/>effects of the TPM expression become more interesting than the resulting <br/>selection), or directly from Access procedures. In either case, they take as <br/>arguments AST nodes that map to a region of source text, and optionally <br/>take a text string that should be added to the original source.<br/>
<b>diff_replace</b><br/>
<br/>
diff_replace string node<br/>
Replaces the text of node with the contents of string.<br/>
<br/>
diff_replace string node1 node2<br/>
Replaces the text of a region from the start of node1 to the end of <br/>node_2, using the contents of string.<br/>
<i><b>81</b></i><br/>
<hr/>
<a name=88></a><i>Chapter 6: Change Propagation</i><br/>
<b>diff_insert_before</b><br/>
<br/>
diff_insert_before string node<br/>
Inserts string before node.<br/>
<b>diff_insert_after</b><br/>
<br/>
diff_insert_after string node<br/>
Inserts string after node.<br/>
<b>diff_delete</b><br/>
<br/>
diff_delete node<br/>
Deletes node and replaces it with an empty string.<br/>
<br/>
diff_delete node1 node_n<br/>
Deletes a region from the start of node1 to the end of node_n.<br/>
<b>Applying Diffs</b><br/>
Procedures for viewing, merging, and applying diffs, as well as for <br/>resolving conflicts are included in this section.<br/>
<b>Viewing Diff Files</b><br/>
You can view diff files in two ways:<br/>
<br/>
within the Browser <b>Results</b> panel<br/>
<br/>
by using the <b>TPM</b> menu<br/>
<b>To view diffs using the Results Panel</b><br/>
Double-click a diff file in the <b>Results</b> panel to display the file in a view.<br/>
<b>To view diffs using the TPM Menu</b><br/>
<b>1 </b>Select <b>TPM &gt; View/Merge Diffs</b>.<br/>
A dialog box displays the source and diff files.<br/>
<b>2 </b>Select a diff file to view the changes in the <b>Change Information</b> panel.<br/>
<i><b>82</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=89></a><img src="AccessGuide-89_1.png"/><br/>
<img src="AccessGuide-89_2.png"/><br/>
<img src="AccessGuide-89_3.png"/><br/>
<i>Applying Diffs</i><br/>
<b>3 </b>Select <b>View/Change</b> to view the code.<br/>
<i><b>83</b></i><br/>
<hr/>
<a name=90></a><i>Chapter 6: Change Propagation</i><br/>
<b>4 </b>Select <b>Previous</b> or <b>Next</b> to view other diff files.<br/>
<b>To merge diff files</b><br/>
<b>1 </b>Select <b>TPM &gt; View/Merge Diffs</b>.<br/>
The <b>File Chooser</b> dialog box displays the source and diff files.<br/>
<b>2 </b>Select <b>Merge</b>.<br/>
The <b>mrg_ui</b> dialog box displays the changes and lists the number of <br/>changes, conflicts, and current change number in the status bar.<br/>
<b>3 </b>Select <b>Previous</b> or <b>Next</b> to view other diff files.<br/>
<b>To apply diffs</b><br/>
<b>1 </b>Select the files (scope) you want to apply the diff files to.<br/>
<b>2 </b>Select <b>TPM &gt; Apply Diffs</b>.<br/>
The <b>mrg_ui</b> dialog box displays the source and diff files.<br/>
<b>3 </b>View the changes and exit the dialog boxes to apply the changes to the <br/>
scope.<br/>
<b>Resolving Conflicts</b><br/>
When a conflict occurs, the <b>mrg_ui</b> dialog boxes are invoked to enable you <br/>to resolve the conflicts before merging the files.<br/>
<b>To resolve conflicts</b><br/>
<b>1 </b>From the first <b>mrg_ui</b> dialog box, select a file from the list for which <br/>
conflicting change instructions exist.<br/>
Conflicts as they appear in your source code display in a second <br/><b>mrg_ui</b> dialog box.<br/>
<b>2 </b>Click <b>Accept</b> to accept that the conflicts exist.<br/>
DIScover maintains the original source code file. You can also <br/>use this dialog box to make manual modifications.<br/>
<b>3 </b>Once you have resolved all of the conflicts, exit the dialog box to <br/>
merge the diff files.<br/>
<i><b>84</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=91></a><img src="AccessGuide-91_1.png"/><br/>
<i>diff_tpm_all</i><br/>
<b>diff_tpm_all</b><br/>
The following example demonstrates how you can search for a function <br/>call, <b>pdstrcmp</b>, and replace it with a new function call, <b>new_pdstrcmp</b>.<br/>
<b>NOTE</b><br/>
Executing this command does not change your source code; it creates a diff file <br/>containing the delta between your original code and the changes that the <br/>command represents.<br/>
diff_tpm_all {call_expr -&gt; c: &#34;pdstrcmp” {diff_replace <br/>
&#34;new_pdstrcmp&#34; $c}} /selected_files<br/>
You can execute a single command or a series. You may find it convenient <br/>to create a script containing a series of commands. A separate diff file is <br/>created with each execution of <b>diff_tpm_all</b>.<br/>
<i><b>85</b></i><br/>
<hr/>
<a name=92></a><i>Chapter 6: Change Propagation</i><br/>
<i><b>86</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=93></a><img src="AccessGuide-93_1.png"/><br/>
<img src="AccessGuide-93_2.png"/><br/>
<b>Source Mode Queries</b><br/>
<i>7</i><br/>
<b>KEY TERMS: </b>source mode tree, #ifdef, smt node, smt navigation, smt attributes<br/>
During the model build process, C/C++ programs are transformed by <br/>the C preprocessor prior to syntactic analysis by the compiler. Access <br/>components covered so far—Access, TPM, Change Propagation—are <br/>primarily concerned with compiler’s view of your source: DIScover <br/>understands what all your macros expand to, where your include files <br/>come from, what overloaded operator to call, and so on.<br/>
However, there is a different perspective on the source—the one <br/>developers see every day. It is the flat-text, string-of-characters, edit with <br/>an editor model of the source, complete with confusing macros, <br/>conditionally compiled code, comments, and so on.<br/>
DIScover connects these two perspectives with its source mode tree, a <br/>mapping between the source text, and the elements in the information <br/>model. The source mode tree is how DIScover identifies information <br/>model entities from text selections in the editor.<br/>
This chapter covers the following topics:<br/>
<br/>
<a href="AccessGuides.html#94">“SMT Structure” o</a>n<a href="AccessGuides.html#94"> page 88</a><br/>
<br/>
<a href="AccessGuides.html#94">“Obtaining an SMT Node” o</a>n<a href="AccessGuides.html#94"> page 88</a><br/>
<br/>
<a href="AccessGuides.html#95">“SMT Navigation” o</a>n<a href="AccessGuides.html#95"> page 89</a><br/>
<br/>
<a href="AccessGuides.html#96">“SMT Attributes” </a>on<a href="AccessGuides.html#96"> page 90</a><br/>
<br/>
<a href="AccessGuides.html#98">“SMT/CP Operations” o</a>n<a href="AccessGuides.html#98"> page 92</a><br/>
The Abstract Syntax Tree (AST) penetrates all the conditional compilation <br/>(#ifdefs and #includes) and macro expansion to the actual as-built core <br/>of your code. At times, however, you need to understand how the <br/>preprocessor is affecting your source. For this you need the Source Mode <br/>Tree (SMT).<br/>
<i><b>87</b></i><br/>
<hr/>
<a name=94></a><i>Chapter 7: Source Mode Queries</i><br/>
<b>SMT Structure</b><br/>
The SMT is created as a result of a parse-phase, model build process. In <br/>contrast to the rich, relationship-bearing structure of the AST, the SMT is <br/>flat, maintaining only an inventory of where each entity exists in your <br/>source and where it is defined. Because the SMT records the line number <br/>and offset of each symbol of your source, you can see your code as it exists <br/>prior to preprocessing and learn more about how preprocessing has <br/>affected your source. <br/>
For example, the SMT displays the existence of multiple #ifdef conditions <br/>in your source even when the #ifdef resolution that occurs during <br/>preprocessing resolves to one; while the AST contains the one symbol, the <br/>SMT helps you to understand the rest of the #ifdef construct. This is <br/>especially helpful while using DIScover for tasks such as code <br/>comprehension.<br/>
<b>Obtaining an SMT Node</b><br/>
The <b>get_smt</b> command converts a symbol or an instance to an SMT node <br/>that corresponds to that symbol’s definition or the span of source <br/>represented by the instance.<br/>
<b>get_smt</b><br/>
get_smt symbol|instance<br/>
Returns the SMT node that spans symbol or instance.<br/>
<b>NOTE</b><br/>
The <b>data</b> command—which converts between symbols, instances, AST nodes, <br/>and data nodes—is not used to convert to or from SMT nodes.<br/>
<i><b>88</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=95></a><img src="AccessGuide-95_1.png"/><br/>
<i>SMT Navigation</i><br/>
<b>SMT Navigation</b><br/>
Compared to navigation of the AST, navigation of the SMT is primitive. <br/>Tree navigation is accomplished through Tcl procedures that act as <br/>iterators, instead of through attributes functioning in an attribute <br/>expression. Because attribute-expressions cannot be used, there is no <br/>“find” functionality—if you are looking for a particular type of node, you <br/>need to walk the tree using TPM.<br/>
<b>smt_first</b><br/>
smt_first smt_node<br/>
Returns the first child of smt_node.  If smt_node has no children, <br/><b>smt_first</b> returns nothing.<br/>
<b>smt_last</b><br/>
smt_last smt_node<br/>
Returns the last child of smt_node<i>.</i> If smt_node has no children, <br/>smt_last returns nothing.<br/>
<b>smt_next</b><br/>
smt_next smt_node<br/>
Returns the next sibling of smt_node.<br/>
<b>smt_parent</b><br/>
smt_parent smt_node<br/>
Returns the parent smt node of smt_node.<br/>
<b>smt_prev</b><br/>
smt_prev smt_node<br/>
Returns the previous sibling of smt_node.<br/>
<b>smt_root</b><br/>
smt_root smt_node<br/>
Returns the root node representing the entire file smt_node appears in.<br/>
<i><b>89</b></i><br/>
<hr/>
<a name=96></a><i>Chapter 7: Source Mode Queries</i><br/>
<b>SMT Attributes</b><br/>
The following table lists the attributes applicable to SMT nodes:<br/>
<b>Attribute</b><br/>
<b>Description</b><br/>
smt_text<br/>
String. Returns an abbreviated (whitespace <br/>removed) string representation of the source text <br/>spanned by the SMT node.<br/>
smt_native_text<br/>
Like smt_text, but returns original source text.<br/>
smt_type<br/>
String. Returns an enumeration describing the type <br/>of the SMT node.<br/>
smt_extype<br/>
String. Returns extended SMT type for SMT node.  <br/>SMT types are usually specialized only for <br/>SMT_tokens.<br/>
smt_offset<br/>
Integer. Returns offset of beginning of SMT.<br/>
smt<br/>
Boolean. Returns true if operand is an SMT node; <br/>false otherwise.<br/>
<b>NOTE</b><br/>
These are actual Tcl commands, not AST attributes . You should call these <br/>commands directly, and not use “apply.”<br/>
<i><b>90</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=97></a><img src="AccessGuide-97_1.png"/><br/>
<i>Printing the SMT Example</i><br/>
<b>Printing the SMT Example</b><br/>
The following procedures make use of the navigation commands to print <br/>an indented structure of the SMT.<br/>
proc print_smt sel {<br/>
    global indent_level<br/>
    set indent_level &#34;&#34;<br/>
    set root [get_smt $sel]<br/>
    print_smt_internal $root<br/>
}<br/>
 <br/>
proc print_smt_internal node {<br/>
    global indent_level<br/>
    # increment the indent level:<br/>
    append indent_level &#34; &#34;<br/>
 <br/>
    while {[size $node]} {<br/>
        if {[size [smt_first $node]]} {<br/>
            puts &#34;$indent_level[smt_type $node] <br/>
[smt_extype $node]&#34;<br/>
            print_smt_internal [smt_first $node]<br/>
        } else {<br/>
            puts &#34;$indent_level[smt_type $node] <br/>
[smt_extype $node] [smt_native_text $node]&#34;<br/>
        }<br/>
        set node [smt_next $node]<br/>
    }<br/>
 <br/>
    # decrement the indent level:<br/>
    regsub . $indent_level {} indent_level<br/>
}<br/>
<i><b>91</b></i><br/>
<hr/>
<a name=98></a><i>Chapter 7: Source Mode Queries</i><br/>
In the output, note the difference between the smt_type and the more <br/>specific smt_extype attributes:<br/>
print_smt /xip/src/pipeline.c<br/>
returns<br/>
 SMT_file SMT_file<br/>
  SMT_token SMTT_untok /* File: pipeline.c */<br/>
...<br/>
  SMT_comment SMT_comment<br/>
   SMT_token SMTT_el <br/>
  SMT_m_define SMT_m_define<br/>
   SMT_token SMTT_untok #define<br/>
   SMT_token SMTT_ident  _NO_PROTO<br/>
  SMT_comment SMT_comment<br/>
   SMT_token SMTT_el <br/>
...<br/>
<b>SMT/CP Operations</b><br/>
It is possible to make changes to the source text from the SMT. Like most <br/>SMT operations, the procedure for making SMT changes differs from <br/>TPM/CP. You should be aware that the process for SMT/CP requires an <br/>up-to-date model, that it does not offer a process for managing merges or <br/>merge conflicts, and that it is generally much less robust than TPM/CP.  <br/>However, for some operations it is essential, so it is presented here.<br/>
<b>To perform SMT/CP</b><br/>
<b>1 </b>Ensure that all files that are the subject of SMT/CP are checked out <br/>
and updated.<br/>
<b>2 </b>Sort the changes to be made by file, and within file by offset.<br/>
<b>3 </b>For each file, call the smt_[change]_text functions to make the <br/>
changes.<br/>
<b>4 </b>Save the modified files.<br/>
<i><b>92</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=99></a><img src="AccessGuide-99_1.png"/><br/>
<i>SMT/CP Operations</i><br/>
<b>SMT Change </b><br/>
There are three commands for making changes to the source text based on <br/>the SMT:<br/>
<b>Commands</b><br/>
<b>smt_insert_text_after</b><br/>
smt_insert_text_after text smt_node<br/>
Inserts text after the node represented by smt_node.<br/>
<b>smt_insert_text_before</b><br/>
smt_insert_text_before text smt_node<br/>
Inserts text before the node represented by smt_node.<br/>
<b>smt_replace_text</b><br/>
smt_replace text smt_node<br/>
Replaces smt_node with text.<br/>
<b>Auxiliary </b><br/>
The following commands may also be useful for SMT/CP:<br/>
<b>Commands</b><br/>
<b>cm_get</b><br/>
cm_get module_name<br/>
Makes module_name available for writing using the CM interface <br/>(checkout). <br/>
<b>save</b><br/>
save module_name [module_name1...]<br/>
Writes the changes made during SMT/CP to disk. Note that module_name <br/>must be a string, not a DIScover handle or set. You should use the <br/>name attribute when saving a DIScover module: <br/>
save [apply name $module].<br/>
<i><b>93</b></i><br/>
<hr/>
<a name=100></a><i>Chapter 7: Source Mode Queries</i><br/>
<i><b>94</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=101></a><img src="AccessGuide-101_1.png"/><br/>
<img src="AccessGuide-101_2.png"/><br/>
A P P E N D I X<br/>
<b>Access Commands</b><br/>
<i>A</i><br/>
This appendix provides an extensive resource of all available Access <br/>commands and attribute descriptions, divided into the following <br/>categories:<br/>
<a href="AccessGuides.html#102"><b>Project Commands</b></a><br/>
<br/>
<a href="AccessGuides.html#102">Query Commands</a><br/>
<br/>
<a href="AccessGuides.html#105">Set Operation Commands</a><br/>
<br/>
<a href="AccessGuides.html#107">Auxiliary Commands</a><br/>
<br/>
<a href="AccessGuides.html#108">Kind Attributes</a><br/>
<br/>
<a href="AccessGuides.html#110">Integer Attributes</a><br/>
<br/>
<a href="AccessGuides.html#111">Boolean Attributes</a><br/>
<br/>
<a href="AccessGuides.html#114">String Attributes</a><br/>
<br/>
<a href="AccessGuides.html#116">Metric Attributes</a><br/>
<br/>
<a href="AccessGuides.html#118">Applying Attributes</a><br/>
<a href="AccessGuides.html#118"><b>Attribute Expressions</b></a><br/>
<br/>
<a href="AccessGuides.html#119">C Function Attribute Expressions</a><br/>
<br/>
<a href="AccessGuides.html#120">Miscellaneous Commands and Expressions</a><br/>
<br/>
<a href="AccessGuides.html#121">Interface Commands</a><br/>
<i><b>95</b></i><br/>
<hr/>
<a name=102></a><i>Appendix A: Access Commands</i><br/>
<b>Project Commands</b><br/>
Project commands let you walk through the projects and logical paths that <br/>your PDF establishes. These commands are as follows:<br/>
<b>Project Command</b><br/>
<b>Description and Syntax</b><br/>
contents<br/>
Returns the logically defined projects and files one <br/>level below the specified project.<br/>
contents <i>project_name</i><br/>
home_proj<br/>
Returns the home project for the current DIScover <br/>session.<br/>
home_proj<br/>
modules<br/>
Returns all files contained in the specified project and <br/>in all of the specified project’s subprojects.<br/>
modules <i>project_name</i> <br/>
parent<br/>
Returns the parent project of the specified project.<br/>
parent <i>project_pathname</i> <br/>
roots<br/>
Identifies the root project(s) of the current Information <br/>Model.<br/>
roots<br/>
subprojects<br/>
Returns all subprojects of the specified project.<br/>
subprojects <i>project_name</i> <br/>
<b>Query </b><br/>
Query commands find entities in the Information Model. The following <br/>table describes query commands and their syntax.<br/>
<b>Commands </b><br/>
<b>Query Command</b><br/>
<b>Description and Syntax</b><br/>
argument_of<br/>
Returns all functions that take the specified <br/>argument.<br/>
argument_of <i>argument</i> <br/>
declarations<br/>
Returns all of the specified instances that <br/>are declarations.<br/>
declarations <i>instance_name</i> <br/>
defines<br/>
Returns all functions that the specified file <br/>defines. <br/>
defines [function] <i>file_name</i> <br/>
or<br/>
Returns all inner classes of the specified <br/>class.<br/>
defines [classes] class_name<br/>
<i><b>96</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=103></a><img src="AccessGuide-103_1.png"/><br/>
<i>Project Commands</i><br/>
<b>Query Command</b><br/>
<b>Description and Syntax</b><br/>
friend_of<br/>
Returns the classes of which the specified <br/>entity is a friend.<br/>
friend_of <i>class</i> <br/>
get_declares<br/>
Returns all entities declared but not defined <br/>in the specified file.<br/>
get_declares <i>logical_pathname</i> <br/>
get_friends<br/>
Returns the classes and functions that have <br/>access to the private and protected <br/>members of the specified class.<br/>
get_friends <i>class_name</i> <br/>
get_include_files<br/>
Returns the include files that the specified <br/>source file or header file includes.<br/>
get_include_files <br/>
<i>logical_pathname</i> <br/>
get_instance_scope<br/>
Returns the project level of the specified <br/>instance.<br/>
get_instance_scope <br/>
<i>instance_name</i> <br/>
get_instance_statement<br/>
Returns the statement containing the <br/>specified instance. This command does not <br/>work for macros.<br/>
get_instance_statement <br/>
<i>instance_name</i> <br/>
get_instance_symbol<br/>
Returns the symbol associated with the <br/>specified instance.<br/>
get_instance_symbol <br/>
<i>instance_name</i> <br/>
get_member_data<br/>
Returns the member data (or fields) of the <br/>specified class or structure.<br/>
get_member_data [<i>class_name</i> | <br/>
<i>structure_name</i>]<br/>
get_member_functions<br/>
Returns the member functions of the <br/>specified class.<br/>
get_member_functions <br/>
<i>class_name</i> <br/>
get_related_classes<br/>
Returns all classes that are related to the <br/>specified class. DIScover Related <br/>classes are those for which a DIScover <br/>built-in relation exists (as assigned in an <br/>ERD).<br/>
get_related_classes <i>class_name</i> <br/>
<i><b>97</b></i><br/>
<hr/>
<a name=104></a><i>Appendix A: Access Commands</i><br/>
<b>Query Command</b><br/>
<b>Description and Syntax</b><br/>
get_sub_classes<br/>
Returns the classes that inherit from the <br/>specified class.<br/>
get_sub_classes <i>class_name</i> <br/>
get_super_classes<br/>
Returns the classes from which the <br/>specified class inherits.<br/>
get_super_classes <i>class_name</i> <br/>
instances<br/>
Returns the instances of the specified entity.<br/>
instances <i>entity_name</i> <br/>
modified_entities<br/>
Returns all the entities that have been <br/>modified since the last incremental model <br/>build for the specified file. <br/>
modified_entities <br/>
<i>logical_pathname</i> <br/>
modified_objects<br/>
Returns all the objects that have been <br/>modified since the last incremental model <br/>build for the specified file. <br/>
modified_objects <br/>
<i>logical_pathname</i> <br/>
uses<br/>
Returns all entities that the specified entity <br/>uses. If a type of entity is specified (for <br/>example, uses -classes) then only entities <br/>of that type are returned.<br/>
uses -all -classes <i>entity_name</i> <br/>
<i><b>98</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=105></a><img src="AccessGuide-105_1.png"/><br/>
<i>Project Commands</i><br/>
<b>Query Command</b><br/>
<b>Description and Syntax</b><br/>
where<br/>
Collective command for where queries. <br/>
where [declared | defined | <br/>
included | referenced | used] <br/>
<i>entity_name</i> <br/>
 where declared <i>entity_name</i> <br/>
returns the class that the entity is <br/>declared in <br/>
 where defined <i>entity_name</i> returns <br/>
the file using the entity <br/>
 where included <i>entity_name</i> <br/>
returns files that the file is included in (C <br/>and C++ only) <br/>
 where used <i>entity_name</i> returns <br/>
functions, structures, and packages using <br/>the entity <br/>
 where referenced <i>entity_name</i> <br/>
returns files containing references to this <br/>function<br/>
The following limitations apply to Java <br/>entities:<br/> where declared and where <br/>
included do not return any results<br/>
 where referenced <i>file</i> returns the <br/>
specified file<br/>
 where used <i>package</i> returns <br/>
functions<br/>
 where used <i>interface</i> returns the <br/>
package <br/>
<b>Set Operation </b><br/>
Set operation commands manipulate Access sets, sending their output to <br/>the current set ($CurSet).<br/>
<b>Commands</b><br/>
<b>Set Operation </b><br/>
<b>Description and Syntax</b><br/>
<b>Command</b><br/>
attribute<br/>
Define an attribute.<br/>
attribute enum <i>attribute_name</i> <br/>
&#34;value...&#34; [enum | info | int | print | <br/>
set | string]<br/>
nil_set<br/>
Makes a null (empty) set.<br/>
nil_set<br/>
sappend<br/>
Appends the specified entities or instances to the <br/>specified set.<br/>
sappend <i>set_name new_entities</i> <br/>
<i><b>99</b></i><br/>
<hr/>
<a name=106></a><i>Appendix A: Access Commands</i><br/>
<b>Set Operation </b><br/>
<b>Description and Syntax</b><br/>
<b>Command</b><br/>
set_add<br/>
Adds the contents of two sets without removing <br/>duplicates; the result becomes the current set.<br/>
set_add <i>set_name_1</i> <i>set_name_2</i> <br/>
set_copy<br/>
Creates a “deep copy” of the contents of the specified <br/>set to the current set<br/>
set_copy <i>set_name</i> <br/>
set_intersect<br/>
Returns the elements common to two sets; the result <br/>becomes the current set. Duplicates are removed.<br/>
set_intersect <i>set_name_1</i> <i>set_name_2</i><br/>
set_subtract<br/>
For two sets, A and B, removes the elements of A that <br/>are also in B; the remaining elements of A become the <br/>current set. Duplicates are removed.<br/>
set_subtract <i>set_name_A</i> <i>set_name_B</i><br/>
set_union<br/>
Combines the contents of two sets, removing all <br/>duplicates; the result becomes the current set. <br/>
set_union <i>set_name_1</i> <i>set_name_2</i><br/>
set_unique<br/>
For two sets, A and B, returns the elements of each set <br/>that are not in the other set.<br/>
set_unique <i>set_name_1</i> <i>set_name_2</i><br/>
<b>Group </b><br/>
While a set in Access offers much of the functionality of a group, it is only a <br/>temporary object and is not part of the Information Model. Group <br/>
<b>Operation </b><br/>
operation commands provide a subset of the Group Manager’s <br/>
<b>Commands</b><br/>
functionality. You can use these commands to group entities or use <br/>grouped entities. Remember that DIScover does not allow projects as <br/>group members. <br/>
<b>Group Operation </b><br/>
<b>Description and Syntax</b><br/>
<b>Command</b><br/>
group<br/>
Collective command for group functions; supersedes <br/>next.<br/>
group [info | new | tmp | save | saveas <br/>
| rename | set | get | size | exists | <br/>
add | remove | delete] <i>group_name</i> <br/>
group info<br/>
Lists names of existing groups; command takes no <br/>arguments.<br/>
group info<br/>
group new<br/>
Creates a new group with the given name containing <br/>the specified elements. <br/>
group new group_name elements<br/>
<i><b>100</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=107></a><img src="AccessGuide-107_1.png"/><br/>
<i>Project Commands</i><br/>
<b>Group Operation </b><br/>
<b>Description and Syntax</b><br/>
<b>Command</b><br/>
group get<br/>
Returns the elements of the specified group<br/>
group get <i>group_name</i><br/>
group save<br/>
Saves the group <i>group_name</i>  to disk<br/>
group save <i>group_name</i><br/>
group add<br/>
Adds elements to the specified group.<br/>
group add group_name elements<br/>
group remove<br/>
Removes elements from the specified group.<br/>
group remove group_name elements<br/>
group delete<br/>
Permanently removes the stored group from memory.<br/>
group delete group_name<br/>
Once created, you can reference groups like any entity; they act as sets but <br/>do not take a $ prior to their name, for example:<br/>
% group create var [defines -variables /xip_shared]<br/>
% print var<br/>
(var)  reglist<br/>
(var)  reglist_num<br/>
(var)  CommandLineOptions<br/>
(var)  GPL<br/>
(var)  G_dbFileList<br/>
[...]   <br/>
<b>Auxiliary </b><br/>
Auxiliary commands do not fit into any one category, but help manage set <br/>input and output. The following table describes auxiliary commands and <br/>
<b>Commands</b><br/>
their syntax.<br/>
<b>Auxiliary Command</b><br/>
<b>Description and Syntax</b><br/>
&gt;<br/>
Direct command output to a file.<br/>
&gt; filename command<br/>
&gt;&gt;<br/>
Append command output to a file.<br/>
&gt;&gt; filename command<br/>
add-attribute<br/>
Creates a new attribute using the specified attribute <br/>expression.<br/>
add_attribute <i>attribute_name</i> <br/>
<i>attribute_expression</i><br/>
<i><b>101</b></i><br/>
<hr/>
<a name=108></a><i>Appendix A: Access Commands</i><br/>
<b>Auxiliary Command</b><br/>
<b>Description and Syntax</b><br/>
apply<br/>
Applies the specified attributes to each entity or <br/>instance in the specified set, removing duplicate <br/>entities or instances. Returns a list of unique attribute <br/>values.<br/>
apply <i>attribute_name</i> <i>set_name</i> <br/>
apply_per_file <br/>
Loads files as necessary, and unloads them when they <br/>are no longer needed.<br/>
apply_per_file &#34;string args” <br/>
filter<br/>
Return those members of the set for which <br/><i>attribute-expression,</i> applied to that member, <br/>returns true.<br/>
filter <i>attribute-expression set_name</i><br/>
foreach<br/>
For every element in <i>set</i>, set <i>var </i>to the element and <br/>perform <i>action</i>.<br/>
foreach <i>var set { action }</i><br/>
new_set<br/>
Makes the specified set the current set (same as <br/>set_copy).<br/>
new_set <i>set_name</i> <br/>
print<br/>
Prints the entities contained in the specified set using <br/>the current print format.<br/>
print <i>set_name</i> <br/>
printformat<br/>
Determines the format of printed output.<br/>
printformat <i>formatstring</i> [<i>attribute</i> <br/>
[<i>attribute</i>...]]<br/>
size<br/>
Returns the size of the specified set.<br/>
size <i>set</i><br/>
sort<br/>
Returns the specified set according to a specified sort <br/>attribute (default is alphabetical).<br/>
sort [-a | -d] <i>sort_attribute </i><br/>
<b>Kind Attributes</b><br/>
Kind attributes return a string that describes the category of the ast_node.<br/>
<b>Java Kind Attribute</b><br/>
<b>Description</b><br/>
package<br/>
Java package definition.<br/>
module<br/>
Java source file.<br/>
struct<br/>
Java class. Can be an import statement or class <br/>definition.<br/>
interface<br/>
Java interface. Can be interface definition, or <br/>implements statement.<br/>
<i><b>102</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=109></a><img src="AccessGuide-109_1.png"/><br/>
<i>Project Commands</i><br/>
<b>Java Kind Attribute</b><br/>
<b>Description</b><br/>
funct<br/>
Returns a Java method. Can be a method <br/>definition or method declaration, or method call in <br/>expression.<br/>
field<br/>
Field of class.<br/>
static field<br/>
Static field of a class.<br/>
local<br/>
Local variables in method. Can also be parameter <br/>of method.<br/>
string<br/>
Text literal in code (string constant).<br/>
constant<br/>
Constant expression.<br/>
var<br/>
Variable. Can be field definition in interface.<br/>
exception<br/>
Exception in Java.<br/>
<b>C++ Kind Attribute</b><br/>
<b>Description</b><br/>
class<br/>
Class definition.<br/>
enum<br/>
Enumeration.<br/>
enumeration value<br/>
A value of enumeration.<br/>
exception<br/>
Exception in C++/C.<br/>
extern reference<br/>
Reference to extern variable.<br/>
field<br/>
Field of class, structure, union.<br/>
function<br/>
Method of class. Can be method or function <br/>definition, method declaration in class, or method <br/>call in call expression.<br/>
function list<br/>
List of functions.<br/>
instance<br/>
Instance of variable, object, and so on.<br/>
label<br/>
Label in code.<br/>
local<br/>
Local variables in method. Can also be a <br/>parameter of method.<br/>
macro<br/>
MACRO variable.<br/>
macro list<br/>
List of macros.<br/>
module<br/>
C++/C source file.<br/>
namespace<br/>
Namespace.<br/>
number<br/>
Numeric statement in code.<br/>
project<br/>
C++/C project file.<br/>
<i><b>103</b></i><br/>
<hr/>
<a name=110></a><i>Appendix A: Access Commands</i><br/>
<b>C++ Kind Attribute</b><br/>
<b>Description</b><br/>
scope<br/>
Scope of visibility for variable, object and so on.<br/>
string<br/>
Text literal in code (string constant).<br/>
template<br/>
Template.<br/>
typedef<br/>
typedef statement in C/C++<br/>
typedef list<br/>
List of typedefs.<br/>
union<br/>
Union definition or declaration.<br/>
variable list<br/>
List of variables.<br/>
<b>Common Kind Attribute</b><br/>
<b>Description</b><br/>
language<br/>
Possible values are: C++/C, Java, SQL.<br/>
root<br/>
Root node of AST tree.<br/>
unknown<br/>
Unknown kind of node (possibly experienced <br/>some problem during parsing).<br/>
version<br/>
<b>Integer </b><br/>
Integer attributes return an integer representing the attribute that a symbol <br/>possesses:<br/>
<b>Attributes</b><br/>
<b>Integer Attribute</b><br/>
<b>Description and Syntax</b><br/>
inst_line<br/>
Returns the line number of the specified instance.<br/>
inst_line <i>instance_name</i> <br/>
inst_offset<br/>
Returns the offset (from the beginning of the containing <br/>file) of the specified instance.<br/>
inst_offset <i>instance_name</i> <br/>
numargs<br/>
Returns the number of arguments taken by a specified <br/>function.<br/>
numargs <i>function_name</i> <br/>
<i><b>104</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=111></a><img src="AccessGuide-111_1.png"/><br/>
<i>Project Commands</i><br/>
<b>Boolean </b><br/>
Boolean attributes return a zero or one (false or true, respectively) for a <br/>specified entity.<br/>
<b>Attributes</b><br/>
<b>Boolean Attribute</b><br/>
<b>Description and Syntax</b><br/>
call<br/>
Returns 1 if the specified entity or instance is called in <br/>the execution of a function; returns 0 if it is not.<br/>
call <i>entity_name</i><br/>
cfunction<br/>
Returns 1 if the specified entity or instance is a C <br/>function; returns 0 if it is not.<br/>
cfunction <i>entity_name</i> <br/>
class<br/>
Returns 1 if the specified entity or instance is a class; <br/>returns 0 if it is not.<br/>
class <i>entity_name</i> <br/>
constant<br/>
Returns 1 if the specified entity or instance is a <br/>constant; returns 0 if it is not.<br/>
constant <i>entity_name</i><br/>
constructor<br/>
Returns 1 if the specified entity is a constructor, returns <br/>0 if it is not.<br/>
constructor <i>entity_name</i><br/>
declaration<br/>
Returns 1 if the specified entity or instance is a <br/>declaration; returns 0 if it is not.<br/>
declaration <i>entity_name</i><br/>
destructor<br/>
Returns 1 if the specified entity is a destructor; returns <br/>0 if it is not.<br/>
destructor entity_name<br/>
enum<br/>
Returns 1 if the specified entity or instance is an <br/>enumerated list; returns 0 if it is not.<br/>
enum <i>entity_name</i><br/>
evalue<br/>
Returns 1 if the specified entity or instance is an <br/>enumerated value; returns 0 if it is not.<br/>
evalue <i>entity_name</i><br/>
field<br/>
Returns 1 if the specified entity or instance is a field; <br/>returns 0 if it is not.<br/>
field <i>entity_name</i><br/>
funct<br/>
Returns 1 if the specified entity or instance is a <br/>function; returns 0 if it is not (same as function).<br/>
funct <i>entity_name</i><br/>
function<br/>
Returns 1 if the specified entity or instance is a <br/>function; returns 0 if it is not (same as funct).<br/>
funct <i>entity_name</i><br/>
<i><b>105</b></i><br/>
<hr/>
<a name=112></a><i>Appendix A: Access Commands</i><br/>
<b>Boolean Attribute</b><br/>
<b>Description and Syntax</b><br/>
generated<br/>
Returns 1 if the specified function is compiler-<br/>generated; returns 0 if it is not.<br/>
generated <i>function_name</i><br/>
group<br/>
Returns 1 if the specified entity or instance is a group; <br/>returns 0 if it is not.<br/>
group <i>entity_name</i><br/>
haspmod<br/>
Returns 1 if the specified entity or instance has a global <br/>Information Model file (pmod file); display 0 if it does <br/>not.<br/>
haspmod <i>entity_name</i><br/>
header<br/>
Returns 1 if the specified entity or instance is a header <br/>file; returns 0 if it is not.<br/>
header <i>logical_pathname</i><br/>
included<br/>
Returns 1 if the specified file is included in another file; <br/>returns 0 if it is not.<br/>
included <i>logical_pathname</i><br/>
inline<br/>
Returns 1 if the specified function is an inline function; <br/>returns 0 if it is not.<br/>
inline <i>function_name</i><br/>
instance<br/>
Returns 1 if the specified entity or instance is an <br/>instance; returns 0 if it is not.<br/>
instance <i>entity_name</i><br/>
local<br/>
Returns 1 if the specified entity or instance is a local <br/>variable; returns 0 if it is not.<br/>
local <i>entity_name</i> <br/>
macro<br/>
Returns 1 if the specified entity or instance is a macro; <br/>returns 0 if it is not.<br/>
macro <i>entity_name</i> <br/>
member<br/>
Returns 1 if the specified entity or instance is a <br/>member function (method) or a data member; returns 0 <br/>if it is not.<br/>
member <i>entity_name</i><br/>
method<br/>
Returns 1 if the specified function is a method (member <br/>function); returns 0 if it is not.<br/>
member <i>function_name</i><br/>
module<br/>
Returns 1 if the specified entity or instance is a module; <br/>returns 0 if it is not.<br/>
module entity_name<br/>
<i><b>106</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=113></a><img src="AccessGuide-113_1.png"/><br/>
<i>Project Commands</i><br/>
<b>Boolean Attribute</b><br/>
<b>Description and Syntax</b><br/>
pointer<br/>
Returns 1 if the specified entity or instance is a pointer; <br/>returns 0 if it is not<br/>
pointer <i>entity_name</i><br/>
private<br/>
Returns 1 if the specified method (member function) <br/>has private access status; returns 0 if it does not.<br/>
private <i>function_name</i><br/>
proj<br/>
Returns 1 if the specified entity or instance is a project; <br/>returns 0 if it is not (same as project).<br/>
proj <i>entity_name</i><br/>
project<br/>
Returns 1 if the specified entity or instance is a project; <br/>returns 0 if it is not (same as proj).<br/>
project <i>entity_name</i><br/>
protected<br/>
Returns 1 if the specified method (member function) <br/>has protected access status; returns 0 if it does not.<br/>
protected <i>function_name</i> <br/>
public<br/>
Returns 1 if the specified method (member function) <br/>has public access status; returns 0 if it does not.<br/>
public <i>function_name</i><br/>
purevirt<br/>
Returns 1 if the specified entity or instance is a pure <br/>virtual function; returns 0 if it is not.<br/>
purevirt <i>function_name</i><br/>
reference<br/>
Returns 1 if the specified entity or instance is a <br/>reference; returns 0 if it is not.<br/>
reference <i>entity_name</i><br/>
region<br/>
Returns 1 if the specified entity or instance is a region; <br/>returns 0 if it is not.<br/>
region <i>entity_name</i><br/>
static<br/>
Returns 1 if the specified entity or instance is static; <br/>returns 0 if it is not.<br/>
static <i>entity_name</i><br/>
stringl<br/>
Returns 1 if the specified entity or instance is a string <br/>literal; returns 0 if it is not.<br/>
stringl <i>entity_name</i><br/>
struct<br/>
Returns 1 if the specified entity or instance is a <br/>structure or class; returns 0 if it is not (same as <br/>structure).<br/>
struct <i>entity_name</i><br/>
structure<br/>
Returns 1 if the specified entity or instance is a <br/>structure; returns 0 if it is not (same as struct).<br/>
structure <i>entity_name</i><br/>
<i><b>107</b></i><br/>
<hr/>
<a name=114></a><i>Appendix A: Access Commands</i><br/>
<b>Boolean Attribute</b><br/>
<b>Description and Syntax</b><br/>
templ<br/>
Returns 1 if the specified entity or instance is a <br/>template; returns 0 if it is not (same as template).<br/>
templ <i>entity_name</i><br/>
template<br/>
Returns 1 if the specified entity or instance is a <br/>template; returns 0 if it is not (same as templ).<br/>
template <i>entity_name</i><br/>
typedef<br/>
Returns 1 if the specified entity or instance is a typedef; <br/>returns 0 if it is not.<br/>
typedef <i>entity_name</i><br/>
union<br/>
Returns 1 if the specified entity or instance is a union; <br/>returns 0 if it is not.<br/>
union <i>entity_name</i><br/>
var<br/>
Returns 1 if the specified entity or instance is a <br/>variable; returns 0 if it is not (same as variable.<br/>
var <i>entity_name</i><br/>
variable<br/>
Returns 1 if the specified entity or instance is a <br/>variable; returns 0 if it is not (same as var).<br/>
variable <i>entity_name</i><br/>
virtual<br/>
Returns 1 if the specified method (member function) or <br/>class is a virtual function or class; returns 0 if it is not.<br/>
virtual <i>function_name</i><br/>
volatile<br/>
Returns 1 if the specified entity or instance is volatile; <br/>returns 0 if it is not.<br/>
volatile <i>entity_name</i><br/>
writable<br/>
Returns 1 if the specified file has write access; returns <br/>0 if it does not.<br/>
writable <i>file_name</i><br/>
<b>String </b><br/>
String attributes return a text string for an entity. <br/>
<b>Attributes</b><br/>
<b>String Attribute</b><br/>
<b>Description and Syntax</b><br/>
argof<br/>
Returns the function of which the specified entity or <br/>instance is argument.<br/>
argof <i>entity_name</i><br/>
args<br/>
Returns the argument string of the specified function <br/>(same as arguments).<br/>
args <i>function_name</i><br/>
<i><b>108</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=115></a><img src="AccessGuide-115_1.png"/><br/>
<i>Project Commands</i><br/>
<b>String Attribute</b><br/>
<b>Description and Syntax</b><br/>
arguments<br/>
Returns the argument string of the specified function <br/>(same as args).<br/>
arguments <i>function_name</i><br/>
cname<br/>
Returns the name of the specified entity or instance as <br/>it appears in the source code (without arguments and <br/>scope).<br/>
cname <i>entity_name</i><br/>
etag<br/>
Returns a string that uniquely identifies the specified <br/>entity or instance.<br/>
etag <i>entity_name</i><br/>
fname<br/>
Returns the physical filename of the specified entity’s or <br/>instance’s defining file.<br/>
fname <i>entity_name</i><br/>
inst_info<br/>
Returns information about the specified instance.<br/>
inst_info <i>instance_name</i><br/>
inst_scope<br/>
Returns the scope containing the specified instance.<br/>
inst_scope <i>instance_name</i><br/>
itag<br/>
Returns a string that uniquely identifies the specified <br/>instance.<br/>
itag instance_name<br/>
kind<br/>
Returns the kind (category type, e.g project or module) <br/>of the specified entity or instance.<br/>
kind entity_name<br/>
language<br/>
Returns the language used to write the specified file.<br/>
language <i>logical_pathname</i><br/>
lname<br/>
Returns the logical filename of the specified entity’s or <br/>instance’s defining file.<br/>
lname <i>entity_name</i><br/>
name<br/>
Returns the fully qualified name (with class name, <br/>arguments, and so on) of the specified entity or <br/>instance.<br/>
name <i>entity_name</i><br/>
pname<br/>
Returns the project filename of the specified file.<br/>
pname <i>logical_pathname</i><br/>
psetfile<br/>
Returns the pset filename of the specified file.<br/>
psetfile <i>logical_pathname</i><br/>
rscope<br/>
Returns the root-level scope of the specified entity or <br/>instance.<br/>
rscope <i>entity_name</i><br/>
<i><b>109</b></i><br/>
<hr/>
<a name=116></a><i>Appendix A: Access Commands</i><br/>
<b>String Attribute</b><br/>
<b>Description and Syntax</b><br/>
type<br/>
Returns the return type of the specified function or <br/>variable.<br/>
type <i>function_name</i><br/>
vname<br/>
Returns the name of the specified entity or instance, <br/>with arguments; returns the name of the specified C++ <br/>member function (method) without its class name.<br/>
vname [<i>entity_name</i> | <i>function_name</i>]<br/>
xscope<br/>
Returns the full scope path of the specified entity or <br/>instance.<br/>
xscope <i>entity_name</i><br/>
<b>Metric </b><br/>
DIScover supports metric analysis, dynamically generated statistics <br/>on the entities in your software.  Metric attributes have integer values.<br/>
<b>Attributes</b><br/>
<b>NOTE</b><br/>
Incalculable metrics have a value of -1. <br/>
<b>Metric Attribute</b><br/>
<b>Description and Syntax</b><br/>
met_BYTES<br/>
Returns an integer representing the size in bytes of the <br/>specified file or function.<br/>
met_BYTES [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_CC<br/>
Returns an integer representing the Cyclomatic <br/>Complexity of the specified file or function.<br/>
met_CC [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_DANG_EI<br/>
Returns the number of dangling ELSE-IFS in the <br/>specified function or file.<br/>
met_DANG_EI [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_DANG_SW<br/>
Returns the number of dangling switch statements in <br/>the specified function or file.<br/>
met_DANG_SW [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_DEFAULTS<br/>
Returns the number of default statements in the <br/>specified function or file.<br/>
met_DEFAULTS [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
<i><b>110</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=117></a><img src="AccessGuide-117_1.png"/><br/>
<i>Project Commands</i><br/>
<b>Metric Attribute</b><br/>
<b>Description and Syntax</b><br/>
met_DEPTH<br/>
Returns an integer representing the depth of nested <br/>control structures in the specified function or file.<br/>
met_DEPTH [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_FANIN<br/>
Returns the number of superclasses (base classes) in <br/>the specified class.<br/>
met_FANIN [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_FANOUT<br/>
Returns the number of subclasses (derived classes) in <br/>the specified class.<br/>
met_FANOUT [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_IFS<br/>
Returns the number of IF statements in the specified <br/>function or file.<br/>
met_IFS [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_LOC<br/>
Returns the number of lines of code in the specified <br/>function or file.<br/>
met_LOC [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_LOOPS<br/>
Returns the number of loops in the specified file or <br/>function.<br/>
met_LOOPS [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_MEYERS<br/>
Returns an integer representing the Meyers Complexity <br/>of the specified function or file.<br/>
met_MEYERS [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_RETURNS<br/>
Returns the number of return statements in the <br/>specified function or file.<br/>
met_RETURNS [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_START_LN<br/>
Returns the starting line number of the specified <br/>function or entity.<br/>
met_START_LN [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_SWITCHES<br/>
Returns the number of switch statements in the <br/>specified function or file.<br/>
met_SWITCHES [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
<i><b>111</b></i><br/>
<hr/>
<a name=118></a><i>Appendix A: Access Commands</i><br/>
<b>Metric Attribute</b><br/>
<b>Description and Syntax</b><br/>
met_ULOC<br/>
Returns the number of uncommented lines of code in <br/>the specified  function or file.<br/>
met_ULOC [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
met_XLOC<br/>
Returns the number of executable lines of code in the <br/>specified file or function.<br/>
met_XLOC [<i>logical_pathname</i> | <br/>
<i>function_name</i>]<br/>
<b>Applying </b><br/>
You can use attributes as though they were commands; however, if you <br/>apply an attribute to a set without using a command to iterate the set, the <br/>
<b>Attributes</b><br/>
attribute looks only at the first entity in the set, for example:<br/>
% numargs ticTacToeGame::nextTurn()<br/>
0<br/>
% numargs get_path(char *)<br/>
1<br/>
In this example, the numargs attribute predictably shows how many <br/>arguments the functions take. Now try applying this to a set:<br/>
% size $func<br/>
59<br/>
% numargs $func<br/>
2<br/>
Now numargs says that the first entity in the set $func has two arguments. <br/>This says nothing of the other 58 entities in the set. Using the <b>apply</b> <br/>command, though, you can get this information:<br/>
% apply numargs $func<br/>
0 1 2 3 4<br/>
% <br/>
The <b>apply</b> command applies the numargs attribute to all entities in the set, <br/>but removes duplicates. Therefore, the $func set has functions that take 1, <br/>2, 3, and 4 arguments.<br/>
<b>Attribute Expressions</b><br/>
Attribute expressions are much like attributes.  They have integer, boolean, <br/>and string return values. As with attributes, you can use attribute <br/>expressions with commands to increase the depth of your navigation/<br/>query capabilities.  Using attribute expressions, you can even create new <br/>attributes.<br/>
<i><b>112</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=119></a><img src="AccessGuide-119_1.png"/><br/>
<i>Attribute Expressions</i><br/>
This section explains available attribute expressions and their allowable <br/>syntax, including:<br/>
<br/>
C functions<br/>
<br/>
operators<br/>
<br/>
miscellaneous<br/>
<b>C Function </b><br/>
Several Access attribute expressions are C functions. Some of these are <br/>pattern-matching tools specific to Access, but most are legitimate C <br/>
<b>Attribute </b><br/>
functions, both in appearance and in functionality.<br/>
<b>Expressions</b><br/>
<b>C Function <br/>Attribute </b><br/>
<b>Description and Syntax</b><br/>
<b>Expression</b><br/>
arg<br/>
Shows the argument for a function in the <b>n</b>th position; <br/>returns a string. Starts from 1.<br/>
arg(<i>int</i>)<br/>
count<br/>
Returns the number of occurrences of a character in a <br/>string.<br/>
count (<i>attribute, char</i>)<br/>
match<br/>
Wildcard matching; returns a boolean; works best with <br/>the <b>filter</b> command.<br/>
match (<i>string </i>[, <i>attribute</i>])<br/>
regexp<br/>
Regular expression pattern matching; returns a <br/>boolean; works best with the filter command. <br/>
regexp(<i>string </i>[, <i>attribute</i>])<br/>
strchr<br/>
Compares two strings; returns an integer.<br/>
strchr(<i>string, char</i>)<br/>
strcmp<br/>
Compares two strings; returns an integer.<br/>
strcmp(<i>string,string</i>)<br/>
strcspn<br/>
Returns the length of a string from characters not in the <br/>second string.<br/>
strcspn(<i>string</i>, <i>string</i>)<br/>
strlen<br/>
Shows the length of a symbol’s string (such as name); <br/>returns an integer.<br/>
strlen(<i>string</i>)<br/>
strnchr<br/>
Similar to strchr, but returns a string beginning at the <br/>nth occurrence of a character.<br/>
strnchr (<i>string</i>, <i>char, int n</i>)<br/>
<i><b>113</b></i><br/>
<hr/>
<a name=120></a><i>Appendix A: Access Commands</i><br/>
<b>C Function <br/>Attribute </b><br/>
<b>Description and Syntax</b><br/>
<b>Expression</b><br/>
strncmp<br/>
Compares two strings up to <i>n</i> characters; returns an <br/>integer.<br/>
(string, string, int)<br/>
strpbrk<br/>
For two given strings, returns the substring of string 1 <br/>with the first character of string 2 found in string 1.<br/>
strpbrk (<i>string</i>, <i>string</i>)<br/>
strrchr<br/>
Returns a string starting from the last matching <br/>character in a provided string (through an attribute).<br/>
strrchr (<i>string</i>, char)<br/>
strspn<br/>
Returns the length of a string based on a full match from <br/>a second string.<br/>
strspn(<i>string</i>, <i>string</i>)<br/>
strstr<br/>
Locates in the second attribute the first match from the <br/>first attribute; string return.<br/>
strstr(string, <i>string</i>)<br/>
<b>Miscellaneous </b><br/>
The following is a collection of expressions that fit no one category, but <br/>work as or in attribute expressions:<br/>
<b>Commands and <br/>Expressions</b><br/>
<b>Miscellaneous <br/>Attribute </b><br/>
<b>Description and Syntax</b><br/>
<b>Expressions</b><br/>
?:<br/>
If-then expression.<br/>
(Not applicable)<br/>
<i>attribute</i>  <br/>
String offset: return a character at the integer’s position; <br/>a second form of <i>attribute</i>  returns the length of a <br/>string based on a full match from a second string.<br/>
<i>attribute</i>[<i>int</i>]<br/>
<i>attribute</i>[<i>int</i>, <i>int</i>]<br/>
<i>string</i> <br/>
Wildcard subexpression: returns a string.<br/>
<i>string</i>[<i>attribute</i>, <i>attribute</i>]<br/>
<i><b>114</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=121></a><img src="AccessGuide-121_1.png"/><br/>
<i>Attribute Expressions</i><br/>
The following table shows a list of Access menu commands:<br/>
<b>Menu Command</b><br/>
<b>Description and Syntax</b><br/>
add_item<br/>
Adds an item to one of the browser menus where <br/><i>command_string </i> is the action initiated by the item.<br/>
add_item <br/>
<i>menu_name.submenu_1_name.item_name</i> <br/>
<i>command_string</i><br/>
add_menu<br/>
Adds a menu to the Browser’s menu bar; allows <br/>cascading menus. The add_menu command has its own <br/>syntax:<br/>
add_menu tag [selection] [display]<br/>
add_menu <i>menu_name.submenu_1_name. </i><br/>
<i>submenu_2_name</i><br/>
add_separator<br/>
Adds a graphical separator at the bottom of a menu; all <br/>subsequently added items appear below the separator.<br/>
add_separator <i>menu_name.submenu_1_name</i><br/>
<b>Interface </b><br/>
There is an additional set of commands that serve to communicate with the <br/>Browser or a user.  These commands are:<br/>
<b>Commands</b><br/>
<b>Interface </b><br/>
<b>Description and Syntax</b><br/>
<b>Command</b><br/>
change_prompt<br/>
Change the prompt that appears in the Access Emacs <br/>buffer. Use “\” to precede special characters like spaces.<br/>
change_prompt <i>new_prompt</i><br/>
do_dormant<br/>
Executes a dormant code analysis on the specified <br/>entity.<br/>
do_dormant <i>entity_name</i> <br/>
emacs_command<br/>
Executes an Emacs command.<br/>
emacs_command <i>command</i> <i>args</i><br/>
filesb<br/>
Invokes a graphical file selection Browser.<br/>
filesb<br/>
get_selection<br/>
Returns the entities currently selected in the Browser.<br/>
get_selection<br/>
msg<br/>
Generates a text message in awarning or dialog box.<br/>
msg [-warning | -error] &#34;<i>message</i>&#34; <br/>
open_view<br/>
Opens the source of the specified entity.<br/>
open_view [-flowchart | -dependency |  <br/>
-inheritance | -datachart | -reltions | <br/>
-outline] <i>entity_name</i><br/>
<i><b>115</b></i><br/>
<hr/>
<a name=122></a><i>Appendix A: Access Commands</i><br/>
<b>Interface </b><br/>
<b>Description and Syntax</b><br/>
<b>Command</b><br/>
prompt<br/>
Generates a prompt dialog box (with the information text <br/>contained in <i>text_string</i>) that accepts text input.<br/>
prompt <i>text_string</i> <br/>
set_elements<br/>
Populates the Browser’s Elements column with the <br/>contents of the specified set.<br/>
set_elements <i>set_name</i> <br/>
set_result<br/>
Copies the contents of the specified set into the <br/>Browser’s Results column.<br/>
set_result <i>set_name</i><br/>
src_update<br/>
Parses the specified modules, updating the Information <br/>Model.<br/>
src_update <i>set</i> <br/>
These commands use the following syntax:<br/>
selection<br/>
set_result [set1 set2 ...]<br/>
emacs_command (emacs-command)<br/>
message &#34;text&#34;<br/>
open_view [set1 set2 ...]<br/>
prompt [ -title message_text] [-errmsg error_text]<br/>
<i><b>116</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=123></a><img src="AccessGuide-123_1.png"/><br/>
<img src="AccessGuide-123_2.png"/><br/>
A P P E N D I X<br/>
<b>Attribute Expression </b><br/>
<i>B</i><br/>
<b>Grammar</b><br/>
This appendix describes the complete attribute-expression grammar, <br/>using Backus-Naur form (BNF).  Note that TPM expressions are a subset of <br/>the resulting language.<br/>
This appendix covers the following topics:<br/>
<br/>
<a href="AccessGuides.html#124">“Typographical Conventions for Backus-Naur Form” on page 118</a><br/>
<br/>
<a href="AccessGuides.html#124">“TPM Expression Syntax” o</a>n<a href="AccessGuides.html#124"> page 118</a><br/>
<br/>
<a href="AccessGuides.html#124">“TPM Expression Variables”</a> on<a href="AccessGuides.html#124"> page 118</a><br/>
<i><b>117</b></i><br/>
<hr/>
<a name=124></a><i>Appendix B: Attribute Expression Grammar</i><br/>
<b>Typographical Conventions for <br/>Backus-Naur Form</b><br/>
Use the following conventions to interpret the components of the TPM <br/>grammar. These BNF conventions differ somewhat from the typographical <br/>conventions in the remainder of this manual.<br/>
&lt;<i>bracketed italic</i>&gt;<br/>
variables; can consist of literal text, other <br/>variables, or a combination of literal text <br/>and variables<br/>
EROG<br/>
literal text; must be entered exactly as <br/>shown<br/>
...<br/>
(ellipsis): a range—for example, <br/>0|1|...|9<br/>
{...}<br/>
(enclosed in braces): zero or more <br/>occurrences (unless the braces are bold)<br/>
<b>TPM </b><br/>
Every valid TPM expression is a tree, of the following form:<br/>
<b>Expression </b><br/>
<b>&lt;<i>tree</i></b><b>&gt; </b>→<br/>
<b>Syntax</b><br/>
&lt;<i>tpm term</i>&gt; |<br/>
&lt;<i>tpm term</i>&gt; &lt;<i>tree</i>&gt; |<br/>
&lt;<i>repeat expression</i>&gt; |<br/>
&lt;<i>directional operator</i>&gt; |<br/>
&lt;<i>directional operator</i>&gt; &lt;<i>tree</i>&gt;<br/>
The following subsection expands the variables available for TPM <br/>expressions.<br/>
<b>TPM </b><br/>
<b>&lt;<i>tpm term</i></b><b>&gt; </b>→<br/>
<b>Expression </b><br/>
&lt;<i>string expression</i>&gt; |<br/>
&lt;<i>boolean expression</i>&gt; |<br/>
<b>Variables</b><br/>
&lt;<i>unquoted string</i>&gt; |<br/>
&lt;<i>quoted string</i>&gt; |<br/>
&lt;<i>variable reference</i>&gt; |<br/>
&lt;<i>variable assignment</i>&gt;<br/>
<b>&lt;<i>directional operator</i></b><b>&gt; </b>→<br/>
-&gt; |<br/>
&lt;- |<br/>
,  |<br/>
-- <br/>
<i><b>118</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=125></a><img src="AccessGuide-125_1.png"/><br/>
<i>Typographical Conventions for Backus-Naur Form</i><br/>
<b>&lt;<i>repeat expression</i></b><b>&gt; </b>→<br/>
U &lt;<i>subtree</i>&gt; &lt;<i>tree</i>&gt; |<br/>UHSHDW &lt;<i>subtree</i>&gt; &lt;<i>tree</i>&gt; |<br/>&lt;<i>integer</i>&gt; &lt;<i>subtree</i>&gt; &lt;<i>tree</i>&gt; |<br/>
&lt;<i>integer</i>&gt;  &lt;<i>subtree</i>&gt;  |<br/>&lt;<i>integer</i>&gt;  &lt;<i>subtree</i>&gt;<br/>
<b>&lt;<i>subtree</i></b><b>&gt; </b>→<br/>
&lt;<i>directional operator</i>&gt; |<br/> &lt;<i>tree</i>&gt;  <br/>
<b>&lt;<i>variable reference</i></b><b>&gt; </b>→<br/>
&lt;<i>identifier</i>&gt;<br/>
<b>&lt;<i>identifier</i></b><b>&gt; </b>→<br/>
&lt;<i>letter</i>&gt; { &lt;letter or digit&gt; }<br/>
<b>&lt;<i>letter or digit</i></b><b>&gt; </b>→<br/>
&lt;<i>letter</i>&gt; | &lt;<i>digit</i>&gt;<br/>
<b>&lt;<i>letter</i></b><b>&gt; </b>→<br/>
a | b | ... | z |<br/>
A | B | ... | Z <br/>
<b>&lt;<i>digit</i></b><b>&gt;</b><br/>
0 | 1 | ... | 9 <br/>
<b>&lt;<i>variable assignment</i></b><b>&gt; </b>→<br/>
&lt;<i>identifier</i>&gt; <br/>
<b>&lt;<i>string expression</i></b><b>&gt; </b>→<br/>
V &lt;<i>expression</i>&gt; |<br/>&lt;<i>unquoted string</i>&gt; |<br/>
&lt;<i>access C-function attribute expression</i>&gt; |<br/>
&lt;<i>trinary operator</i>&gt;<br/>
<b>&lt;<i>trinary operator</i></b><b>&gt; </b>→<br/>
&lt;<i>expression</i>&gt; &#34; &lt;<i>expression</i>&gt;  &lt;<i>expression</i>&gt;<br/>
<b>&lt;<i>unquoted string</i></b><b>&gt; </b>→<br/>
&lt;<i>letter</i>&gt; { &lt;<i>letter or digit</i>&gt; }<br/>
<b>&lt;<i>integer</i></b><b>&gt; </b>→<br/>
&lt;<i>digit</i>&gt; | &lt;<i>digit</i>&gt; &lt;<i>integer</i>&gt;<br/>
<i><b>119</b></i><br/>
<hr/>
<a name=126></a><i>Appendix B: Attribute Expression Grammar</i><br/>
<b>&lt;<i>boolean expression</i></b><b>&gt; </b>→<br/>
&lt;<i>expression</i>&gt;    &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt;   &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt;   &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt; !  &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt;  &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt; ! &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt; 		 &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt; __ &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt;  &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt; !! &lt;<i>expression</i>&gt; |<br/> &lt;<i>expression</i>&gt; |<br/>&gt; &lt;<i>access command</i>&gt; @ |<br/> &lt;<i>tree</i>&gt;  |<br/>ILQG  &lt;<i>tree</i>&gt;  |<br/>VHDUFK  &lt;<i>tree</i>&gt;  |<br/>ILQG  &lt;<i>tree</i>&gt;  |<br/>VHDUFK  &lt;<i>tree</i>&gt;  |<br/>^ &lt;<i>optional access command</i>&gt; ` |<br/> |<br/>QLO <br/>
<b>&lt;expression&gt; </b>→<br/>
&lt;<i>integer expression</i>&gt; |<br/>
&lt;<i>boolean expression</i>&gt; |<br/>
&lt;<i>string expression</i>&gt; |<br/>
&lt;<i>quoted string</i>&gt; |<br/>
&lt;<i>integer</i>&gt;<br/>
<b>&lt;integer expression&gt; </b>→<br/>
 &lt;<i>expression</i>&gt; |<br/> &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt;  &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt;  &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt;  &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt;  &lt;<i>expression</i>&gt; |<br/>&lt;<i>expression</i>&gt;  &lt;<i>expression</i>&gt; |<br/>&lt;<i>array reference</i>&gt;<br/>
<b>&lt;<i>array reference</i></b><b>&gt; </b>→<br/>
&lt;<i>string expression</i>&gt; &gt; &lt;<i>expression</i>&gt; @ |<br/>&lt;<i>string expression</i>&gt; &gt; &lt;<i>expression</i>&gt;  &lt;<i>expression</i>&gt; @ <br/>
<b>&lt;<i>quoted string</i></b><b>&gt; </b>→<br/>
Any characters <br/>
<b>&lt;<i>optional Access command</i></b><b>&gt; </b>→<br/>
{ &lt;<i>access command</i>&gt; }<br/>
<i><b>120</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=127></a><img src="AccessGuide-127_1.png"/><br/>
<i>Typographical Conventions for Backus-Naur Form</i><br/>
<b>&lt;Access command&gt; </b>→<br/>
Any valid Access command.<br/>
<b>&lt;Access C-function attribute expression&gt; </b>→<br/>
Any Access C-function attribute expression, such as regexp or <br/>match.<br/>
<i><b>121</b></i><br/>
<hr/>
<a name=128></a><i>Appendix B: Attribute Expression Grammar</i><br/>
<i><b>122</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=129></a><img src="AccessGuide-129_1.png"/><br/>
<img src="AccessGuide-129_2.png"/><br/>
A P P E N D I X<br/>
<b>AST_node Attributes</b><br/>
<i>C</i><br/>
This appendix provides a comprehensive resource of AST_node <br/>attributes. The information is divided into two tables:<br/>
<br/>
<a href="AccessGuides.html#130">AST_node Attribute Codes, w</a>hich lists all attributes in alphabetical <br/>order<br/>
<br/>
<a href="AccessGuides.html#135">Samples for C++, Java, and SQL,</a> which illustrate how syntax varies <br/>for each programming language<br/>
<i><b>123</b></i><br/>
<hr/>
<a name=130></a><i>Appendix C: AST_node Attributes</i><br/>
<b>AST_node Attribute Codes </b><br/>
<b>Attribute Code</b><br/>
<b>Description</b><br/>
[list_decl]<br/>
list declaration<br/>
addr_expr<br/>
take the address of an object<br/>
alshift_assign_expr<br/>
shift left and assignment expression<br/>
alshift_expr<br/>
shift left expression<br/>
anonymous_class<br/>
anonymous class (Java only)<br/>
array_ref<br/>
array reference<br/>
arshift_assign_expr<br/>
arithmetic (sign extend) shift right and <br/>assignment expression<br/>
arshift_expr<br/>
arithmetic (sign extend) shift right expression<br/>
asm_stmt<br/>
embedded assembly language statement<br/>
assign_expr<br/>
simple assignment expression <br/>
ast_block<br/>
body inside braces { } for function, class, <br/>enum, if statement, .... For SQL usually points <br/>to any body between keywords “BEGIN” and <br/>“END” or inside parentheses (). <br/>
ast_declspec<br/>
type declaration<br/>
ast_root<br/>
node for file<br/>
ast_superclass<br/>
class or list of classes from which original <br/>class is derived<br/>
bit_and_assign_expr<br/>
bitwise AND and assignment expression<br/>
bit_and_expr<br/>
bitwise AND expression<br/>
bit_field_ref<br/>
field reference (C++ only)<br/>
bit_ior_expr<br/>
bitwise inclusive OR expression<br/>
bit_xor_assign_expr<br/>
bitwise exclusive OR and assignment <br/>expression<br/>
bit_ior_assign_expr<br/>
bitwise inclusive OR and assignment <br/>expression<br/>
bit_xor_expr<br/>
bitwise exclusive OR expression<br/>
call_expr<br/>
call expression<br/>
case_default<br/>
default case<br/>
case_label<br/>
label of case<br/>
<i><b>124</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=131></a><img src="AccessGuide-131_1.png"/><br/>
<i>AST_node Attribute Codes</i><br/>
<b>Attribute Code</b><br/>
<b>Description</b><br/>
case_stmt<br/>
case statement<br/>
case_value<br/>
value of case<br/>
catch<br/>
catch or microsoft finally expressions<br/>
class_literal<br/>
reference to the specified class (Java only)<br/>
component_ref<br/>
component reference<br/>
compound_expr<br/>
sequence (comma) operator<br/>
cond_expr<br/>
conditional expression<br/>
const_decl<br/>
constant identifier or declaration (C++ only)<br/>
or<br/>
const_id<br/>
convert_expr<br/>
conversion of value of an operand from one <br/>type to another<br/>
ctor_init<br/>
constructor initialization<br/>
cursor_decl<br/>
(SQL only)<br/>
cursor_def<br/>
(SQL only)<br/>
dimensions<br/>
array size declaration (Java only)<br/>
div_assign_expr<br/>
integer divide and assign<br/>
or<br/>
trunc_div_assign_expr<br/>
div_expr<br/>
divide expression (SQL only)<br/>
dl_expr<br/>
delete expression<br/>
do_while_stmt<br/>
do while expression<br/>
dynamic_init<br/>
dynamic initialization<br/>
easy_new<br/>
create an object of the type_name to which it <br/>is applied (Java only)<br/>
eq_expr<br/>
equal expression<br/>
exit_stmt<br/>
break or continue statement (loop exits)<br/>
expr_stmt<br/>
expression statement<br/>
field_decl<br/>
field declaration<br/>
finally<br/>
finally expression (Java only)<br/>
for_expr<br/>
for expression<br/>
function_decl<br/>
function declaration<br/>
function_def<br/>
function definition<br/>
<i><b>125</b></i><br/>
<hr/>
<a name=132></a><i>Appendix C: AST_node Attributes</i><br/>
<b>Attribute Code</b><br/>
<b>Description</b><br/>
ge_expr<br/>
greater than or equal expression<br/>
global_id<br/>
global identifier<br/>
goto_stmt<br/>
goto statement<br/>
gt_expr<br/>
greater than expression<br/>
if_stmt<br/>
if statement<br/>
implements<br/>
interfaces that original class implements <br/>(Java only) <br/>
in_expr<br/>
SQL in<br/>
indirect_ref<br/>
indirect reference<br/>
initialization_block<br/>
initialization block (Java only)<br/>
inner_join_expr<br/>
SQL inner join<br/>
instanceof<br/>
instanceof (Java only)<br/>
java_component_ref<br/>
component reference for JAVA<br/>
java_vec_new<br/>
create vector of the type_name to which it is <br/>applied (Java only)<br/>
label_decl<br/>
pointer to label declaration<br/>
le_expr<br/>
less than or equal expression<br/>
left_join_expr<br/>
(SQL only)<br/>
local_id<br/>
local identifier<br/>
lrshift_assign_expr<br/>
logical (zero pad) right shift and assignment <br/>expr. (Java only)<br/>
lrshift_expr<br/>
logical (zero pad) right shift expression (Java <br/>only)<br/>
lt_expr<br/>
less than expression<br/>
microsoft_try<br/>
Microsoft-style try block<br/>
minus_assign_expr<br/>
subtract and assign expression<br/>
minus_expr<br/>
subtract (minus) expression<br/>
mod_assign_expr<br/>
modulo and assignment expression<br/>
or<br/>
trunc_mod_assign_expr<br/>
mult_assign_expr<br/>
multiply and assignment expression<br/>
mult_expr<br/>
multiply expression<br/>
name_clause<br/>
name for class, enum, ...<br/>
<i><b>126</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=133></a><img src="AccessGuide-133_1.png"/><br/>
<i>AST_node Attribute Codes</i><br/>
<b>Attribute Code</b><br/>
<b>Description</b><br/>
namespace_decl<br/>
namespace declaration (C++ only)<br/>
ne_expr<br/>
not equal expression<br/>
negate_expr<br/>
unary minus expression<br/>
no_operand<br/>
placeholder when function has no return type, <br/>as in constructors<br/>
nw_expr<br/>
call to new<br/>
parens<br/>
parentheses (Java only)<br/>
parm_decl<br/>
parameter declaration<br/>
plus_assign_expr<br/>
add and assign expression<br/>
plus_expr<br/>
add (plus) expression<br/>
pm_field_ref<br/>
pointer to member implicit field<br/>
postdecrement_expr<br/>
post-decrement expression<br/>
postincrement_expr<br/>
post-increment expression<br/>
predecrement_expr<br/>
pre-decrement expression<br/>
preincrement_expr<br/>
pre-increment expression<br/>
rdif_expr<br/>
floating point divide expressions<br/>
rdiv_assign_expr<br/>
floating point divide and assign<br/>
return_stmt<br/>
return statement<br/>
super<br/>
reference to the parent class through super <br/>(Java only)<br/>
template_body<br/>
function or class template body (C++ only)<br/>
template_class<br/>
template class<br/>
template_fcn<br/>
template function (C++ only)<br/>
template_static_data_<br/>
template static data members (C++ only)<br/>
mbr<br/>
template_struct<br/>
template structure (C++ only)<br/>
template_union<br/>
template union (C++ only)<br/>
this<br/>
use of the this pointer/object reference<br/>
throw_expr<br/>
throw exception<br/>
throw_spec<br/>
throw exception declaration in the function <br/>signature (Java only)<br/>
trunc_div_expr<br/>
integer divide expression<br/>
<i><b>127</b></i><br/>
<hr/>
<a name=134></a><i>Appendix C: AST_node Attributes</i><br/>
<b>Attribute Code</b><br/>
<b>Description</b><br/>
trunc_mod_expr<br/>
modulo (remainder) expression<br/>
truth_and_expr<br/>
logical AND for SQL<br/>
truth_andif_expr<br/>
logical AND for if expression<br/>
truth_not_expr<br/>
not expression<br/>
truth_or_expr<br/>
logical inclusive OR for SQL source code<br/>
truth_orif_expr<br/>
logical inclusive OR for if expression<br/>
try_block<br/>
try block<br/>
type_decl<br/>
declaration for class, structure enum, ...<br/>
type_decl_modified<br/>
class declaration (Java only)<br/>
typespec<br/>
type declaration (Java only)<br/>
unary_plus<br/>
unary plus expression (appears only in Java)<br/>
using_decl<br/>
import class declaration using in the original <br/>class (Java only)<br/>
var_decl<br/>
variable declaration<br/>
vec_dl_expr<br/>
vector delete expression<br/>
vec_nw_expr<br/>
create vector of the type_name to which it is <br/>applied<br/>
where<br/>
(SQL only)<br/>
while_expr<br/>
while expression<br/>
<i><b>128</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=135></a><img src="AccessGuide-135_1.png"/><br/>
<i>Samples for C++, Java, and SQL</i><br/>
<b>Samples for C++, Java, and SQL</b><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
[list_dec<br/>
foo(){<br/>
public class block <br/>
CREATE TABLE <br/>
l]<br/>
 int A,B,C,B;<br/>
extends jPanel <br/>
#Tresults<br/>
 char word;<br/>
implements Runnable{<br/>
   (Column_Nbr <br/>
}<br/>
public int offset;<br/>
tinyint,<br/>
or<br/>
public int size;<br/>
   Counter tinyint)<br/>
try{<br/>
 public block(int <br/>
or<br/>
  int&amp; loc=current-<br/>
offset, int<br/>
IF 1&lt;2 <br/>
&gt;loc();<br/>
     size){<br/>
  BEGIN<br/>
  game[0]-<br/>
   this.offset=offset;<br/>
   declare @i int <br/>
&gt;active(loc);<br/>
   this.size=size;<br/>
   select @I = <br/>
}<br/>
 }<br/>
@vglobal<br/>
};<br/>
  END<br/>
addr_expr<br/>
log.GetData();<br/>
or<br/>
_AFT pS= _afx;<br/>
alshift <br/>
A &lt;&lt;= B<br/>
A &lt;&lt;= B<br/>
_assign<br/>
_expr<br/>
alshift<br/>
A &lt;&lt; B<br/>
A &lt;&lt; B<br/>
_expr<br/>
anonymous <br/>
fField.addActionListe<br/>
_class<br/>
ner(new<br/>
        <br/>
ActionListener(){<br/>
public void <br/>
actionPerformed <br/>
(ActionEvent e){}<br/>
});<br/>
array_ref<br/>
game[0]-&gt;active(loc);<br/>
current = block[i];<br/>
arshift <br/>
A &gt;&gt;= B<br/>
A &gt;&gt;= B<br/>
_assign <br/>
_expr<br/>
arshift <br/>
A&gt;&gt;B<br/>
A&gt;&gt;B<br/>
_expr<br/>
asm_stmt<br/>
assign_ex<br/>
A=B<br/>
A=B<br/>
A=B<br/>
pr<br/>
<i><b>129</b></i><br/>
<hr/>
<a name=136></a><i>Appendix C: AST_node Attributes</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
ast_block<br/>
    {<br/>
              {<br/>
 BEGIN<br/>
public:<br/>
public int offset;<br/>
    RAISERROR 90125<br/>
 day(int i);<br/>
public int size;<br/>
    RETURN (-101)<br/>
 void show ();<br/>
  public block(int <br/>
 END<br/>
 void getNext();<br/>
offset, int<br/>
or<br/>
 void getPrevious();<br/>
         size){<br/>
(Chain_org_id <br/>
protected:<br/>
      <br/>
numeric(10,0),<br/>
 weekDay m_Day;<br/>
this.offset=offset;<br/>
 Column_Nbr <br/>
};<br/>
      this.size=size;<br/>
tinyint,<br/>
  }<br/>
 Counter tinyint)<br/>
 };<br/>
or<br/>
IF A != NULL<br/>
   PRINT <br/>
‘&lt;&lt;&lt;FAILED&gt;&gt;&gt;’<br/>
ELSE<br/>
   PRINT <br/>
‘&lt;&lt;&lt;PASSED&gt;&gt;&gt;’<br/>
ast <br/>
int i<br/>
public static int <br/>
@name char (10)<br/>
_declspec<br/>
offset<br/>
ast_root<br/>
ast <br/>
class day : public <br/>
public class block <br/>
_supercla<br/>
week{}<br/>
extends jPanel <br/>
ss<br/>
implements Runnable{<br/>
bit_and <br/>
A &amp;= B<br/>
A &amp;= B<br/>
_assig <br/>
n_expr<br/>
bit_and <br/>
A &amp; B<br/>
A &amp; B<br/>
_expr<br/>
bit_field <br/>
struct A{<br/>
_ref<br/>
unsigned int x : 2;<br/>
};<br/>
void foo(){<br/>
A a;<br/>
a.x = 1;<br/>
}<br/>
bit_ior <br/>
A |= B<br/>
A |= B<br/>
_assign <br/>
_expr<br/>
bit_ior <br/>
A | B<br/>
A | B<br/>
_expr<br/>
bit_xor <br/>
A ^= B<br/>
A ^= B<br/>
_assign <br/>
_expr<br/>
<i><b>130</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=137></a><img src="AccessGuide-137_1.png"/><br/>
<i>Samples for C++, Java, and SQL</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
bit_xor <br/>
A ^ B<br/>
A ^ B<br/>
_expr<br/>
call_expr<br/>
  int&amp; loc=current-<br/>
Vector array = new <br/>
SELECT I<br/>
&gt;loc();<br/>
Vector();<br/>
FROM<br/>
or<br/>
or<br/>
WHERE I&gt;0<br/>
  game[0]-<br/>
  super.setSize(max);<br/>
&gt;active(loc);<br/>
case <br/>
default: break;<br/>
default: break;<br/>
_default<br/>
case_labe<br/>
case 1: <br/>
case 3: <br/>
l<br/>
     cout&lt;&lt;&#34;Sunday&#34;;<br/>
     <br/>
     break; <br/>
newNode.setName();<br/>
     break;<br/>
case_stmt<br/>
switch (m_Day){<br/>
switch (current){<br/>
  case 1: <br/>
  case 1: <br/>
     cout&lt;&lt;&#34;Sunday&#34;;<br/>
     <br/>
     break; <br/>
newNode.setKind();<br/>
  case 2: <br/>
     break; <br/>
     cout&lt;&lt;&#34;Monday&#34;;<br/>
  case 2: <br/>
     break;     <br/>
     <br/>
  case 3: <br/>
newNode.setOffset();<br/>
     cout&lt;&lt;&#34;Tuesday&#34;;<br/>
     break;     <br/>
     break; <br/>
  case 3: <br/>
  default: break;<br/>
     <br/>
}<br/>
newNode.setName();<br/>
     break; <br/>
  default: break;<br/>
}<br/>
case_valu<br/>
case 1: <br/>
case 1: <br/>
e<br/>
     cout&lt;&lt;&#34;Sunday&#34;;<br/>
     <br/>
     break;<br/>
newNode.setKind();<br/>
     break; <br/>
catch<br/>
catch(char cCode){<br/>
catch (Exception e){<br/>
  cout&lt;&lt;cCode&lt;&lt; “is <br/>
   <br/>
not valid “;<br/>
e.printStrackTrace();<br/>
}<br/>
}<br/>
or<br/>
__finally{<br/>
  cout&lt;&lt;cCode&lt;&lt; “is <br/>
not valid “;<br/>
}<br/>
<i><b>131</b></i><br/>
<hr/>
<a name=138></a><i>Appendix C: AST_node Attributes</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
class <br/>
if <br/>
_literal<br/>
(node.getClass(AstTre<br/>
e.class)<br/>
       ==false){<br/>
   return <br/>
super.getTree();<br/>
}<br/>
component <br/>
game[0]-&gt;active(loc);<br/>
_ref<br/>
compound <br/>
void foo1(){<br/>
_expr<br/>
   int x, y;<br/>
   x = 2, y = 3;<br/>
}<br/>
cond_expr<br/>
A ? B : C<br/>
A ? B : C<br/>
const_dec<br/>
enum weekDay <br/>
l<br/>
{1,2,3,4,5, 6,7}<br/>
or<br/>
const_id<br/>
convert <br/>
class x{};<br/>
class foo{<br/>
_expr<br/>
class y : public x{};<br/>
  double A;<br/>
int foo(x);<br/>
  double B;<br/>
int bar (){<br/>
  int C=(int) (A/B);<br/>
    y ii;<br/>
}<br/>
    return foo(ii);<br/>
}<br/>
ctor_init<br/>
class x{<br/>
  int y;<br/>
  x(){y=2;}<br/>
};<br/>
static x foo;<br/>
int A(){<br/>
  x bar;<br/>
  return bar.y;<br/>
}<br/>
cursor_de<br/>
DECLARE St_Cur <br/>
cl<br/>
cursor<br/>
cursor_de<br/>
DECLARE St_Cur <br/>
f<br/>
cursor for<br/>
 SELECT C.Initials<br/>
 FROM #Store S<br/>
 WHERE S.Chain = <br/>
C.Chain<br/>
dimension<br/>
byte [ ] block=new <br/>
s<br/>
byte[size];<br/>
<i><b>132</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=139></a><img src="AccessGuide-139_1.png"/><br/>
<i>Samples for C++, Java, and SQL</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
div_assig<br/>
int A;<br/>
int A;<br/>
n _expr<br/>
A /= 2;<br/>
A /= 2;<br/>
or<br/>
trunc_div <br/>
_assign_e<br/>
xpr<br/>
div_expr<br/>
double A,B<br/>
A/B<br/>
dl_expr<br/>
delete turn;<br/>
do_while_<br/>
do{<br/>
do{<br/>
stmt<br/>
    A=B+1;<br/>
    A=B+1;<br/>
    i=0.1*A;<br/>
    i=0.1*A;<br/>
} while (i&lt;1);<br/>
} while (i&lt;1);<br/>
dynamic_i<br/>
class x{<br/>
nit<br/>
  int y;<br/>
  x(){y=2;}<br/>
};<br/>
static x foo;<br/>
int A(){<br/>
  x bar;<br/>
  return bar.y;<br/>
}<br/>
easy_new<br/>
Vector array = new <br/>
Vector();<br/>
eq_expr<br/>
m_day == Saturday<br/>
A == B<br/>
A_b = ISNULL or A is <br/>
null<br/>
or<br/>
IF A = B or WHERE A <br/>
= B<br/>
exit_stmt<br/>
break;<br/>
break;<br/>
BREAK<br/>
continue;<br/>
continue;<br/>
expr_stmt<br/>
game[0]-&gt;active(loc);<br/>
setLayout(EditorPanel<br/>
SELECT I<br/>
Layout)<br/>
show();<br/>
GO<br/>
super.setSize(max);<br/>
field_dec<br/>
class foo(){<br/>
public int offset;<br/>
CREATE TABLE <br/>
l<br/>
  int i;<br/>
public int size;<br/>
#Tresults<br/>
  int happy();<br/>
      (Column_Nbr <br/>
};<br/>
tinyint,<br/>
      Counter <br/>
tinyint)<br/>
<i><b>133</b></i><br/>
<hr/>
<a name=140></a><i>Appendix C: AST_node Attributes</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
finally<br/>
finally {<br/>
theDemo.doUnStuff();<br/>
}<br/>
for_expr<br/>
for (int i=0; i&lt;MAX; <br/>
for (int i=0; i&lt;MAX; <br/>
i++){<br/>
i++){<br/>
   A=B*C;<br/>
   A=B*C;<br/>
   return A;<br/>
   return A;<br/>
}<br/>
}<br/>
function_ <br/>
day(int i);<br/>
block(int offset, int <br/>
create proc x @name <br/>
decl<br/>
size)<br/>
char (10)<br/>
function <br/>
day(int i)<br/>
public block(int <br/>
create proc x @name <br/>
_def<br/>
{<br/>
offset, int size){<br/>
char (10)<br/>
     setDay(i);<br/>
      <br/>
SELECT l<br/>
}<br/>
this.offset=offset;<br/>
IF 1&lt;2 <br/>
      this.size=size;<br/>
   BEGIN<br/>
  }<br/>
      declare @i int  <br/>
      select @I = <br/>
@vglobal<br/>
   END       <br/>
ge_expr<br/>
dayNum &gt;= NULL<br/>
A &gt;= <br/>
A&gt;=B<br/>
global_id<br/>
day(int i);<br/>
block(int offset, int <br/>
create proc x @name <br/>
size)<br/>
char (10)<br/>
goto_stmt<br/>
goto default;<br/>
GOTO ERROR<br/>
gt_expr<br/>
dayNum &gt; 7<br/>
A &gt; C<br/>
A &gt; C<br/>
if_stmt<br/>
if(dayNum&gt;=NULL &amp;&amp; <br/>
if(A&gt;=B &amp;&amp;A&lt;=C){<br/>
IF CHAR_S !&gt; 0<br/>
dayNum&lt;7){<br/>
 return A;<br/>
 BEGIN<br/>
   <br/>
}<br/>
    RAISERROR 90125<br/>
m_Day=weekDay(dayNum);<br/>
    RETURN (-101)<br/>
}else{<br/>
 END<br/>
   m_Day=Sunday;<br/>
}<br/>
implement<br/>
public class block <br/>
s<br/>
extends jPanel <br/>
implements Runnable{<br/>
in_expr<br/>
New_Offer NOT IN <br/>
      (SELECT Offer <br/>
       FROM #OFFERS)<br/>
indirect <br/>
int* i;<br/>
_ref<br/>
int foo(){<br/>
   return *x;<br/>
}<br/>
<i><b>134</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=141></a><img src="AccessGuide-141_1.png"/><br/>
<i>Samples for C++, Java, and SQL</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
initializ<br/>
{<br/>
ation <br/>
n=m+5;<br/>
_block<br/>
  }<br/>
inner_joi<br/>
FROM Zip_code Z<br/>
n _expr<br/>
  INNER JOIN Address <br/>
A<br/>
  ON <br/>
Z.Zip_Code=A.Zip_Co<br/>
de<br/>
WHERE Z.Zip_Code != <br/>
‘98789’<br/>
instanceo<br/>
if (eData.get(i) <br/>
f<br/>
instanceof                     <br/>
                <br/>
TextTreeNode){<br/>
java_comp<br/>
setLayout(EditorPanel<br/>
onent_ref<br/>
Layout)<br/>
java_vec_<br/>
byte [ ] block=new <br/>
new<br/>
byte[size];<br/>
label_dec<br/>
RestoreAndReturn:<br/>
ERROR:<br/>
l<br/>
le_expr<br/>
DayNum &lt;= NULL<br/>
A &lt;= C<br/>
A &lt;= C <br/>
or <br/>
A !&gt; 0<br/>
left_join<br/>
FROM SESSION S<br/>
_expr<br/>
  LEFT JOIN Status C<br/>
  ON <br/>
ESSION=C.SESSION<br/>
WHERE S.SESSION != <br/>
NULL<br/>
local_id<br/>
i<br/>
offset<br/>
@name<br/>
lrshift <br/>
A &gt;&gt;&gt;= B<br/>
_assign_e<br/>
xpr<br/>
lrshift_e<br/>
A=A&gt;&gt;&gt;B<br/>
xpr<br/>
lt_expr<br/>
dayNum &lt; 7<br/>
A &lt; B<br/>
A &lt; B<br/>
microsoft<br/>
__try{<br/>
_try<br/>
    x=y+z<br/>
}<br/>
<i><b>135</b></i><br/>
<hr/>
<a name=142></a><i>Appendix C: AST_node Attributes</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
minus_ass<br/>
A -= B<br/>
A -= B<br/>
ign _expr<br/>
minus_exp<br/>
A - B<br/>
A - B<br/>
A-B<br/>
r<br/>
mod_assig<br/>
A %= B<br/>
A%=B<br/>
n _expr<br/>
or<br/>
trunc_mod <br/>
_assign_e<br/>
xpr<br/>
mult_assi<br/>
A *= B<br/>
A *= B<br/>
gn _expr<br/>
mult_expr<br/>
A * B<br/>
A * B<br/>
A*B<br/>
name_clau<br/>
class day{<br/>
public class block <br/>
se<br/>
extends jPanel <br/>
implements Runnable{<br/>
namespace<br/>
namespace T{<br/>
_decl<br/>
   int x;<br/>
};<br/>
ne_expr<br/>
m_day != Saturday<br/>
A != B<br/>
@Initial1 IS NOT <br/>
NULL<br/>
or A&lt;&gt;B or A!=B<br/>
negate_ex<br/>
B=-A<br/>
B=-A<br/>
-A<br/>
pr<br/>
no_operan<br/>
day::day(int i)<br/>
class foo{}<br/>
d<br/>
or<br/>
foo()<br/>
nw_expr<br/>
int turn = new game();<br/>
parens<br/>
A=B+C+D-E<br/>
parm_decl<br/>
void foo(int i);<br/>
@name char (10)<br/>
plus_assi<br/>
A += B<br/>
A += B<br/>
gn _expr<br/>
plus_expr<br/>
A + B<br/>
A + B<br/>
A+B<br/>
pm_field_<br/>
int foo2( C &amp;c, int <br/>
ref<br/>
C::*m ){<br/>
return c.*m;<br/>
}<br/>
postdecre<br/>
i--<br/>
i--<br/>
ment <br/>
_expr<br/>
<i><b>136</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=143></a><img src="AccessGuide-143_1.png"/><br/>
<i>Samples for C++, Java, and SQL</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
postincre<br/>
i++<br/>
i++<br/>
ment <br/>
_expr<br/>
predecrem<br/>
--i<br/>
--i<br/>
ent _expr<br/>
preincrem<br/>
++i<br/>
++i<br/>
ent _expr<br/>
rdif_expr<br/>
double A, B;<br/>
double A, B;<br/>
A / B<br/>
A / B<br/>
rdiv_assi<br/>
double A;<br/>
double A;<br/>
gn _expr<br/>
A /= 3.9;<br/>
A/=3.9;<br/>
return_st<br/>
RETURN correct()-<br/>
RETURN <br/>
RETURN (-102)<br/>
mt<br/>
&gt;loc();<br/>
newNode.setKind(); <br/>
super<br/>
return <br/>
super.getTree();<br/>
or<br/>
super();<br/>
template_<br/>
{<br/>
body<br/>
public:<br/>
   A(){}<br/>
   ~A();<br/>
 };<br/>
template_<br/>
template&lt;class <br/>
class<br/>
_F,const I* _I&gt;<br/>
class A:public _<i>A&lt;_</i>F, <br/>
_I&gt; {<br/>
public:<br/>
   A(){}<br/>
   ~A();<br/>
 };<br/>
template_<br/>
template&lt;class <br/>
fcn<br/>
_F,const I* _I&gt;<br/>
A&lt;_F, _I&gt;::~A(){}<br/>
template <br/>
template&lt;class <br/>
_header<br/>
_F,const I* _I&gt;<br/>
class A:public _<i>A&lt;_</i>F, <br/>
_I&gt;<br/>
<i><b>137</b></i><br/>
<hr/>
<a name=144></a><i>Appendix C: AST_node Attributes</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
template <br/>
template &lt;class T&gt; <br/>
_static_d<br/>
class A {static T* foo <br/>
ata _mbr<br/>
;<br/>
};<br/>
template&lt;class T&gt; T* <br/>
A&lt;T&gt;::foo;<br/>
template <br/>
template &lt;class T&gt; <br/>
_struct<br/>
struct A {<br/>
    int b;<br/>
};<br/>
template <br/>
template &lt;class T&gt; <br/>
_union<br/>
union A {<br/>
    int b;<br/>
};<br/>
this<br/>
this.setModel(model);<br/>
this.setModel(model);<br/>
 <br/>
 <br/>
this.addMouseListener(<br/>
this.addMouseListener<br/>
this);<br/>
(this);<br/>
throw_exp<br/>
void A(){<br/>
r<br/>
pExcep* Excep =new <br/>
pExcep();<br/>
throw (Excep);<br/>
}<br/>
throw_spe<br/>
void jbInit() throw <br/>
c<br/>
Exception{<br/>
  <br/>
this.setModel(model); <br/>
this.addMouseListener<br/>
(this);<br/>
}<br/>
trunc_div<br/>
int A, B;<br/>
int A, B;<br/>
A/B<br/>
_expr<br/>
A / B<br/>
A /B<br/>
trunc_mod<br/>
A % B<br/>
A % B<br/>
_expr<br/>
truth_and<br/>
A AND B<br/>
_expr<br/>
truth_and<br/>
dayNum&gt;=NULL &amp;&amp; <br/>
A&gt;=B &amp;&amp;A&lt;=C<br/>
if _expr<br/>
dayNum&lt;7<br/>
truth_not<br/>
!status<br/>
!status<br/>
_expr<br/>
truth_or_<br/>
A &gt;= B or C &lt; D<br/>
expr<br/>
<i><b>138</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=145></a><img src="AccessGuide-145_1.png"/><br/>
<i>Samples for C++, Java, and SQL</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
truth_ori<br/>
dayNum&gt;=NULL || <br/>
A&gt;=B || A&lt;=C<br/>
f _expr<br/>
dayNum&lt;7<br/>
try_block<br/>
try{<br/>
try{<br/>
   int&amp; loc=current-<br/>
   JbInit();<br/>
&gt;loc();<br/>
}<br/>
   game[0]-<br/>
catch (Exception e){<br/>
&gt;active(loc);<br/>
   <br/>
}<br/>
e.printStrackTrace();<br/>
}<br/>
or<br/>
try {<br/>
     <br/>
theDemo.doStuff();<br/>
} finally {<br/>
    <br/>
theDemo.doUnStuff();<br/>
}<br/>
type_decl<br/>
class day{<br/>
CREATE TABLE <br/>
public:<br/>
#Tresults<br/>
  day();<br/>
  (Chain_org_id  <br/>
  void show ();<br/>
          <br/>
  void getNext();<br/>
numeric(10,0),<br/>
  void getPrevious();<br/>
  Column_Nbr <br/>
protected:<br/>
tinyint,<br/>
  weekDay m_Day;<br/>
  Counter tinyint)<br/>
};<br/>
or <br/>
class day;<br/>
type_decl <br/>
public class block <br/>
_modified<br/>
extends jPanel <br/>
implements Runnable{<br/>
public int offset;<br/>
public int size;<br/>
  public block(int <br/>
offset, int size){<br/>
      <br/>
this.offset=offset;<br/>
      this.size=size;<br/>
  }<br/>
};<br/>
typespec<br/>
int offset<br/>
unary_plu<br/>
B = +A;<br/>
s<br/>
using-<br/>
import javax.swing.*;<br/>
decl<br/>
import java.land.*;<br/>
<i><b>139</b></i><br/>
<hr/>
<a name=146></a><i>Appendix C: AST_node Attributes</i><br/>
<b>Attribute Code</b><br/>
<b>C++</b><br/>
<b>Java</b><br/>
<b>SQL</b><br/>
var_decl<br/>
int&amp; loc=current-<br/>
for (int i=0; i&lt;MAX; <br/>
declare @i int<br/>
&gt;loc();<br/>
i++){<br/>
vec_dl_ex<br/>
delete [] scores;<br/>
pr<br/>
vec_nw_ex<br/>
return new int [5];<br/>
pr<br/>
where<br/>
 SELECT C.Initials<br/>
 FROM #Store S<br/>
 WHERE S.Chain = <br/>
C.Chain<br/>
while_exp<br/>
WHILE(i&lt;1){<br/>
WHILE(i&lt;1){<br/>
WHILE @Lp &lt;= 7<br/>
r<br/>
    A=B+1;<br/>
    A=B+1;<br/>
  BEGIN<br/>
    i=0.1*A; <br/>
    i=0.1*A; <br/>
    SELECT @Lp = <br/>
}<br/>
}<br/>
@Lp+ 1<br/>
  END<br/>
<i><b>140</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=147></a><img src="AccessGuide-147_1.png"/><br/>
<img src="AccessGuide-147_2.png"/><br/>
A P P E N D I X<br/>
<b>Access Quick Reference</b><br/>
<i>D</i><br/>
This appendix provides the most commonly used Access commands, <br/>queries, and attributes.<br/>
<b>Invoking Access</b><br/>
<b>From Windows:</b><br/>
Use one of the following methods:<br/>
<br/>
From the Model Browser, select the <b>Access</b> menu.<br/>
<br/>
As a standalone: dish2 <i>&lt;service&gt;</i> -connect <i>&lt;host1&gt;</i><br/>
<br/>
If you do not know what host or service to connect to: dish2 -hosts<br/>
<b>From Unix:</b><br/>
<b>1 </b>In the Model Browser, select <b>Viewer &gt; New Viewer</b>.<br/>
<b>2 </b>Click in the Emacs session.<br/>
<b>3 </b>Type Esc-x dish and press RETURN.<br/>
<i><b>141</b></i><br/>
<hr/>
<a name=148></a><i>Appendix D: Access Quick Reference</i><br/>
<b>Access Menu Commands</b><br/>
<b>Command</b><br/>
<b>Action</b><br/>
add_action <i>action command-</i><br/>
Add item to the action menu in the <br/>
<i>string</i><br/>
Browser.<br/>
add_category <i>category </i><br/>
Add item to the category menu in the <br/>
<i>command-string</i><br/>
Browser.<br/>
add_item [query | category <br/>
Add item to one of the Browser <br/>
| filter | action | project <br/>
menus where <i>command-string</i> is <br/>
| user_def_menu] <i>item </i><br/>
the action initiated by the item.<br/>
<i>command-string</i><br/>
add_menu <br/>
Add menu to the Browser’s menu bar; <br/>
<i>menu.submenu1.submenu2</i><br/>
allows cascading menus<br/>
add_query <i>query command-</i><br/>
Add query to the query menu in the <br/>
<i>string</i><br/>
Browser.<br/>
<b>Access-Specific Commands</b><br/>
<b>Command</b><br/>
<b>Action</b><br/>
apply <i>attribute set</i><br/>
Apply specified attribute to each entity <br/>or instance in specified set, remove <br/>duplicate entities or instances.<br/>
data [symbol | instance | <br/>
Convert specified entity from one <br/>
node | cell] <i>entity</i><br/>
Access data type to another.<br/>
filter <i>set filter</i><br/>
Prevent display of member matching <br/>criteria defined in specified filter, for <br/>the specified set.<br/>
print <i>set</i><br/>
Print entities contained in specified <br/>set.<br/>
printformat [-s [-a | -d] <br/>
Determines format of printed output:<br/>
<i>format-string attribute-</i><br/>
-s -a: sort in ascending order<br/>
<i>list</i><br/>
-s -d: sort in descending order.<br/>
size <i>set</i><br/>
Return size of specified set.<br/>
sort <i>sort-attribute</i><br/>
Return specified set according to <br/>specified sort attribute (alphabetical is <br/>default).<br/>
<i><b>142</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=149></a><img src="AccessGuide-149_1.png"/><br/>
<b>Attribute Expression Navigation</b><br/>
<b>Character</b><br/>
<b>Action</b><br/>
- &gt;<br/>
Move down to current node’s first child.<br/>
&lt; -<br/>
Move to current node’s parent.<br/>
,<br/>
Move to current node’s next sibling.<br/>
- -<br/>
Move to current node’s previous sibling.<br/>
<b>Boolean Attributes</b><br/>
<b>Command</b><br/>
<b>Action</b><br/>
function<br/>
Return 1 if specified entity or instance is a function.<br/>
inline<br/>
Return 1 if specified function is an inline function.<br/>
local<br/>
Return 1 if specified entity or instance is a local variable.<br/>
private<br/>
Return 1 if specified method or member function has private <br/>access status.<br/>
public<br/>
Return 1 if specified method or member function has public <br/>access status.<br/>
static<br/>
Return 1 if specified entity or instance is static.<br/>
virtual<br/>
Return 1 if specified method or member function is a virtual <br/>function or class.<br/>
volatile<br/>
Return 1 if specified entity or instance is volatile.<br/>
<b>Group Operation Commands</b><br/>
<b>Command</b><br/>
<b>Action</b><br/>
group [info | new | tmp | <br/>
Collective command for group <br/>
save | saveas | rename | <br/>
functions applied to a specified group. <br/>
set | get | size | exists | <br/>
Each command supersedes the next <br/>
delete] <i>group</i><br/>
command.<br/>
group new <i>name elements</i><br/>
Create new group with the given name <br/>containing the specified elements.<br/>
<i><b>143</b></i><br/>
<hr/>
<a name=150></a><i>Appendix D: Access Quick Reference</i><br/>
<b>Interface Commands</b><br/>
<b>Command</b><br/>
<b>Action</b><br/>
emacs_command <i>command args</i><br/>
Execute an Emacs command.<br/>
message <i>path options</i><br/>
Generate a message relevant to the <br/>current operation in the Browser’s <br/>status bar.<br/>
open_view <i>entity</i><br/>
Open the source of the specified <br/>entity.<br/>
prompt <i>text-string</i><br/>
Generate a prompt dialog box with <br/>information contained in specified <br/>text string.<br/>
selection<br/>
Place entities selected in Browser <br/><b>Elements</b> or <b>Results</b> pane into the <br/>current set.<br/>
set_result <i>set</i><br/>
Copy contents of specified set into <br/>Browser’s Results column.<br/>
<b>Project Structure Queries</b><br/>
<b>Command</b><br/>
<b>Action</b><br/>
contents<i> project</i><br/>
Return all logically defined projects <br/>and files one level below the specified <br/>project.<br/>
modules <i>project</i><br/>
Return all files in specified project and <br/>specified project’s subprojects.<br/>
parent <i>project-path</i><br/>
Return parent project of specified <br/>project.<br/>
roots<br/>
Return a list of top-level modules.<br/>
subprojects<i> project</i><br/>
Return all subprojects of the specified <br/>project.<br/>
<i><b>144</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=151></a><img src="AccessGuide-151_1.png"/><br/>
<b>Set Operations</b><br/>
<b>Command</b><br/>
<b>Action</b><br/>
new_set <i>set</i><br/>
Make specified set the current set.<br/>
nil_set<br/>
Make a null set the current set.<br/>
set_copy <i>set</i><br/>
Copy contents of specified set to <br/>current set.<br/>
set_intersect <i>set1 set2</i><br/>
Return elements common to two sets, <br/>result becomes the current set.<br/>
set_subtract <i>set1 set2</i><br/>
Remove elements of <i>set1</i> that are <br/>also in <i>set2</i>, remaining elements of <br/><i>set1</i> become the current set.<br/>
set_union <i>set1 set2</i><br/>
Combine contents of two sets.<br/>
set_unique <i>set1 set2</i><br/>
Display elements of each of two sets <br/>that are not in the other set.<br/>
<b>String Attributes</b><br/>
<b>Command</b><br/>
<b>Action</b><br/>
args <i>function</i><br/>
Return the argument string of specified function.<br/>
cname <i>entity</i><br/>
Return name of specified entity or instance as it <br/>appears in the source code.<br/>
kind entity<br/>
Return category type of specified entity or <br/>instance.<br/>
type<br/>
Return return type of specified function or variable.<br/>
<b>Tree Subcommands</b><br/>
Command<br/>
<b>Action</b><br/>
tree filter <i>attribute-</i><br/>
Return a set of nodes that match the <br/>
<i>expression scope</i><br/>
specified <i>attribute-expression</i>.<br/>
tree find <i>attribute-</i><br/>
Apply the specified <i>attribute-</i><br/>
<i>expression ast_node</i><br/>
<i>expression</i> to the specified AST <br/>node and its descendants. If the <br/><i>attribute-expression</i> returns <br/>true, that node is added to the return <br/>set.<br/>
<i><b>145</b></i><br/>
<hr/>
<a name=152></a><i>Appendix D: Access Quick Reference</i><br/>
Command<br/>
<b>Action</b><br/>
tree navigate <i>attribute-</i><br/>
Apply the specified <i>attribute-</i><br/>
<i>expression scope</i><br/>
<i>expression</i> to each node in scope <br/>and return a node each time the <br/><i>attribute-expression</i> succeeds.<br/>
tree print <i>ast_nodes</i><br/>
Print a graphical representation of the <br/>specified AST node and its <br/>descendants.<br/>
<b>Miscellaneous Commands</b><br/>
<b>Command</b><br/>
<b>Action</b><br/>
&gt; <i>file command</i><br/>
Redirect output of specified <i>command</i> <br/>to the specified <i>file</i>.<br/>
&gt; &gt; <i>file command</i><br/>
Append output of specified <i>command</i> <br/>to the specified <i>file</i>.<br/>
describe <i>command</i><br/>
Print a short description and usage for <br/>the specified Access command.<br/>
info attributes [<i>pattern</i>]<br/>
Return complete list of Access <br/>attributes. If <i>pattern</i> is specified, <br/>return only attributes that match <br/>specified <i>pattern</i>.<br/>
info commands [<i>pattern</i>]<br/>
Return complete list of Access <br/>commands. If <i>pattern</i> is specified, <br/>return only commands that match <br/>specified <i>pattern</i>.<br/>
<i><b>146</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=153></a><img src="AccessGuide-153_1.png"/><br/>
<img src="AccessGuide-153_2.png"/><br/>
A P P E N D I X<br/>
<b>Glossary of Terms</b><br/>
<i>E</i><br/>
<b>Abstract Syntax Tree</b><br/>
The <i>Abstract Syntax Tree</i> (AST) is a structure representing the meaningful <br/>segments of a source file, such as declarations, class definitions, function <br/>definitions, statements, expressions, identifiers, operators, and constants. <br/>The AST indicates how the larger segments of a source file are composed of <br/>smaller segments. <br/>
<b>Access</b><br/>
<i>Access</i> is a TCL-based language that allows you to write scripts that <br/>perform complex operations with DIScover. The Access client <br/>communicates directly with the Information Model through a command <br/>line interface and enables enterprise-level features and functionality not <br/>available through the Browser.<br/>
<b>build server</b><br/>
Similar to a model server, a <i>build server</i> runs on a host machine. Its purpose, <br/>however, is to manage Submission Check communications between the <br/>information model and your source code. A feature of the Developer <br/>Xpress client, Submission Check verifies the source code file’s existence in <br/>the information model and allows you to apply standard quality filters <br/>against it prior to its check in to your SCM system.<br/>
<b>caliper</b><br/>
An analysis and reporting tool for C, C++, and Java programming projects. <br/>Caliper applies a series of predefined ANSI and industry accepted <br/>programming rules and metrics to produce a <i><b>Q</b>uality <b>A</b>ssessment <b>R</b>eport</i>, or <br/>QAR. <br/>
<b>call tree</b><br/>
A schematic diagram representing the call dependencies of selected <br/>entities.<br/>
<b>configuration</b><br/>
A source control system set up to manage the configuration and <br/>
<b>management (CM)</b><br/>
transparent source sharing of your files (i.e. Source Integrity, Rational <br/>
<b>system</b><br/>
ClearCase).<br/>
<b>cyclomatic complexity</b><br/>
A measure of complexity within a specified function; a higher value means <br/>greater complexity.<br/>
<i><b>147</b></i><br/>
<hr/>
<a name=154></a><i>Appendix E: Glossary of Terms</i><br/>
<b>Developer Xpress</b><br/>
<i>Developer Xpress</i> is a lightweight, easy-to-use browsing and query tool that <br/>enables you to navigate through your application’s project structure and <br/>query your information model.<br/>
<b>dormant</b><br/>
<i>Dormant</i> is a code analysis utility that identifies unused source code <br/>entities in your application<br/>
<b>DSIM</b><br/>
<i>DISIM</i> (short for DISCOVER—now named DIScover—Information <br/>Model) refers to the scripts and underlying command-line tools that are <br/>aware of the information model repository. Previously, DISIM was the <br/>unique, simple, automated procedure for creating an information model.<br/>
<b>entity</b><br/>
An <i>entity</i> describes any individual element of your source code maintained <br/>in the AST. An entity may be as large as an entire file or as small as a <br/>variable. In the Browser, entities are categorized by name: file, function, <br/>class, variable, method, enum, string. Selecting one category displays all <br/>entities of that type that appear in your source code.<br/>
<b>entity relation diagram</b><br/>
An <i>Entity Relation Diagram</i> (ERD) helps you to interpret C++ or Java <br/>classes. It shows the relationships between C structures or C++ classes <br/>consisting of either. Symbols and color-coded lines indicate the nature of <br/>the relationships.<br/>
<b>function path mapping</b><br/>
The process of looking at source and target functions to see if there are <br/>paths between them for a function query.<br/>
<b>group</b><br/>
A <i>group</i> is a useful collection of files or entities that you can create for your <br/>convenience. A group can contain any entity, instance, or combination of <br/>entities and instances.<br/>
<b>group member</b><br/>
A <i>group member</i> is an entity or instance in a group<br/>
<b>hits</b><br/>
A quantity of violations.<br/>
<b>impact analysis</b><br/>
<i>Impact Analysis</i> allows you to examine the options for and consequences of <br/>performing proposed changes to your source code. DIScover <br/>illustrates how change will affect, or impact, your source, enabling you to <br/>make intelligent decisions about whether or not you should make a <br/>change. <br/>
<b>impact analysis report</b><br/>
A comprehensive document that details proposed changes as well as the <br/>affected entities and files. <br/>
<i><b>148</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=155></a><img src="AccessGuide-155_1.png"/><br/>
<b>information model</b><br/>
An <i>information model</i> is a data repository created when DIScover <br/>examines your source, parses the code, and instead of creating object files, <br/>saves it in two language-independent formats: the Source Mode Tree <br/>(SMT) and the Abstract Syntax Tree (AST).<br/>
<b>include files</b><br/>
Source files inserted into a compilation unit during preprocessing.<br/>
<b>inheritance</b><br/>
The relationship between base and derived classes.<br/>
<b>instance</b><br/>
An <i>instance</i> refers to a single occurrence of an entity in your source. A <br/>single entity may very well have multiple instances. For example, a single <br/>function may be called in multiple source files; in this case, the function has <br/>a single instance in each place in the source where it is called. <br/>
<b>Integrated</b><br/>
A supported development application, such as Borland JBuilder, that <br/>
<b>Development</b><br/>
allows you to access DIScover functionality.<br/>
<b>Environment (IDE)</b><br/>
<b>local variable</b><br/>
A variable that can be accessed only by instructions within a particular <br/>subroutine.<br/>
<b>logical file name</b><br/>
A file name that allows you to refer to multiple physical paths with a single <br/>name. Two different versions of the same file in different directories can <br/>share the same logical name; therefore, you can create a logical name and <br/>define multiple physical paths equivalent to it.<br/>
<b>metrics</b><br/>
<i>Metrics</i> measure code entities and files. Metric data helps you make <br/>intelligent decisions based on the size and scope of your code. For <br/>example, you may ask: <i>Is a function too complex? How many bytes does a file <br/>comprise? How many loops, defaultless switches, or lines of code are present?</i><br/>
<b>model browser</b><br/>
The <i>DIScover Browser</i> is the primary graphical user interface (GUI) for <br/>exploring and querying your information model. It allows you to scan <br/>existing projects and to browse your information model to collect data <br/>about your source.<br/>
<b>model server</b><br/>
A <i>model server</i> is a process that runs on a host machine serving the DIScover enterprise environment. This process makes information models <br/>readily and conveniently available to end users who connect through a <br/>Developer Xpress or Access client. Model servers communicate directly <br/>with the Information Model data structure.<br/>
<b>model version</b><br/>
A <i>model version</i> is a new build of an information model.<br/>
<i><b>149</b></i><br/>
<hr/>
<a name=156></a><i>Appendix E: Glossary of Terms</i><br/>
<b>Myer’s Complexity</b><br/>
A measure of complexity for a function or file.<br/>
<b>nested structures</b><br/>
The DIScover term for nested entities in source code.<br/>
<b>persistent group</b><br/>
A saved group.<br/>
<b>physical file name</b><br/>
The actual name for a file as it appears in the file directory (i.e. /user/<br/>source/test.c).<br/>
\<b>project</b><br/>
A DIScover<i> project</i> defines the content of an individual information <br/>model, and is designed to mirror your organization’s software <br/>development projects. Selecting a project sets the scope of your browsing <br/>activities, as only files and entities included in that project are available for <br/>browsing and querying.<br/>
<b>pruning</b><br/>
<i>Pruning</i> removes selected branches from a Call Tree View.<br/>
<b>quality assessment</b><br/>
A <i><b>Q</b>uality <b>A</b>ssessment <b>R</b>eport</i>, or QAR, provides quantitative information in <br/>
<b>report</b><br/>
both graphical and textual forms about the structure and compliance of a <br/>software development project to these rules, plus a list of non-compliant <br/>instances for review and remediation.<br/>
<b>quality filter sets</b><br/>
<i><b>Q</b>uality <b>F</b>ilter <b>S</b>ets</i>, or QFS, are a collection of weighted filters used by <br/>Caliper to access a particular aspect of development.<br/>
<b>query</b><br/>
The <i>query</i> is the central activity of DIScover browsing tools. A query <br/>allows you to discover information about your source code—”show me <br/>where this function is defined in my source,” or ”show me everywhere this <br/>class is used.” A single query can tell you such things as the number of <br/>entities of a specific type that occur in your source, location of a specific <br/>entity, how it is used, and how it relates to other entities in your source. <br/>You can also employ a series of queries to create a more complex analysis <br/>of your source.<br/>
<b>repository</b><br/>
A <i>repository</i> is the directory containing available information models and <br/>model versions (previously referred to as DISIM).<br/>
<b>scratch group</b><br/>
A temporary group that has not been saved.<br/>
<b>simplify.h</b><br/>
<i>Simplify.h</i> is a quick and effective way to prevent header files from being <br/>included unnecessarily in your source files.<br/>
<b>subclass</b><br/>
A class that inherits variables and methods defined in a superclass that has <br/>the basic required properties.<br/>
<i><b>150</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=157></a><img src="AccessGuide-157_1.png"/><br/>
<b>superclass</b><br/>
A dominant class from which variables and methods are defined to be <br/>inherited by other subclasses.<br/>
<b>submission check</b><br/>
A feature in Developer Xpress that allows the user to subject files that are <br/>going to be submitted to a series of tests, called <i>queries</i>.<br/>
<b>transform</b><br/>
Functionality in Developer Xpress that allows it to recognize files in those <br/>cases in which the file paths differ between the server and client, or <br/>between shared and local versions of a file.<br/>
<b>tree pattern matching</b><br/>
A tool for searching parse trees that are constructed and saved while <br/>
<b>(TPM)</b><br/>
building your information model. TPM can find many different <br/>constructions of interest such as coding standards violations, portability or <br/>threading concerns, and internationalization. TPM also includes a change <br/>propagation feature that facilitates automating code changes.<br/>
<b> violation</b><br/>
An area in your source code that does not meet defined programming <br/>standards.<br/>
<b>windowing</b><br/>
<i>Windowing</i> allows you to maintain a set number of separate versions of the <br/>same model for historical purposes, and serve a set number of those <br/>models to your end users. <br/>
<i><b>151</b></i><br/>
<hr/>
<a name=158></a><i>Appendix E: Glossary of Terms</i><br/>
<i><b>152</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=159></a><img src="AccessGuide-159_1.png"/><br/>
<img src="AccessGuide-159_2.png"/><br/>
<b>Index</b><br/>
<b>Symbols</b><br/>
described <a href="AccessGuides.html#12"><i>6</i></a><br/>
applications<br/>
? : attribute expression<br/>
<a href="AccessGuides.html#120"><i>114</i></a><br/>
Acces<a href="AccessGuides.html#19">s <i>13</i></a><br/>
apply comman<a href="AccessGuides.html#57">d <i>51</i></a><br/>
<b>A</b><br/>
applying<br/>
diff<a href="AccessGuides.html#88">s <i>82</i></a><br/>
about this guide<br/>
<a href="AccessGuides.html#8"><i>2</i></a><br/>
applying attribut<a href="AccessGuides.html#118">es <i>112</i></a><br/>
Abstract Syntax Tree<br/>
argument_of command <a href="AccessGuides.html#102"><i>96</i></a><br/>
describe<a href="AccessGuides.html#153">d <i>147</i></a><br/>
assumption<a href="AccessGuides.html#12">s <i>6</i></a><br/>
abstract syntax trees<br/>
AST menus <a href="AccessGuides.html#38"><i>32</i></a><br/>
describe<a href="AccessGuides.html#66">d <i>60</i></a><br/>
AST node<br/>
Access<br/>
displayi<a href="AccessGuides.html#68">ng <i>62</i></a><br/>
abou<a href="AccessGuides.html#18">t <i>12</i></a><br/>
AST nodes<br/>
applying attributes<br/>
<a href="AccessGuides.html#118"><i>112</i></a><br/>
attribute<a href="AccessGuides.html#69">s</a><br/>
<a href="AccessGuides.html#69"><i>63</i></a><br/>
attribute expressions<br/>
<a href="AccessGuides.html#119"><i>113</i></a><br/>
described <a href="AccessGuides.html#45"><i>39, 61</i></a><br/>
autoloading commands<br/>
<a href="AccessGuides.html#27"><i>21</i></a><br/>
AST_node attribute code<a href="AccessGuides.html#130">s <i>124</i></a><br/>
auxiliary commands<br/>
<a href="AccessGuides.html#107"><i>101</i></a><br/>
C++ <a href="AccessGuides.html#135"><i>129</i></a><br/>
describe<a href="AccessGuides.html#153">d <i>147</i></a><br/>
Java <a href="AccessGuides.html#135"><i>129</i></a><br/>
fundamentals<br/>
<a href="AccessGuides.html#43"><i>37</i></a><br/>
SQ<a href="AccessGuides.html#135">L <i>129</i></a><br/>
getting started<br/>
<a href="AccessGuides.html#23"><i>17</i></a><br/>
AST_node attrib<a href="AccessGuides.html#129">utes <i>123</i></a><br/>
interpreting buffers<br/>
<a href="AccessGuides.html#26"><i>20</i></a><br/>
attribute attribute expression <a href="AccessGuides.html#120"><i>114</i></a><br/>
men<a href="AccessGuides.html#34">u</a><br/>
<a href="AccessGuides.html#34"><i>28</i></a><br/>
attribute codes<br/>
navigation commands<br/>
<a href="AccessGuides.html#102"><i>96</i></a><br/>
AST_nodes <a href="AccessGuides.html#130"><i>124</i></a><br/>
overview<br/>
<a href="AccessGuides.html#18"><i>12</i></a><br/>
attribute expression actions <a href="AccessGuides.html#79"><i>73</i></a><br/>
programming sample<a href="AccessGuides.html#19">s</a><br/>
<a href="AccessGuides.html#19"><i>13</i></a><br/>
attribute expression grammar <a href="AccessGuides.html#123"><i>117</i></a><br/>
query commands<br/>
<a href="AccessGuides.html#102"><i>96</i></a><br/>
attribute expression<a href="AccessGuides.html#118">s <i>112</i></a><br/>
quick referenc<a href="AccessGuides.html#147">e</a><br/>
<a href="AccessGuides.html#147"><i>141</i></a><br/>
described <a href="AccessGuides.html#46"><i>40</i></a><br/>
set operation commands<br/>
<a href="AccessGuides.html#105"><i>99</i></a><br/>
navigatio<a href="AccessGuides.html#74">n <i>68</i></a><br/>
starting from a command prompt<br/>
<a href="AccessGuides.html#33"><i>27</i></a><br/>
variable capture <a href="AccessGuides.html#78"><i>72</i></a><br/>
starting from the model browser<br/>
<a href="AccessGuides.html#32"><i>26</i></a><br/>
attribute functions<br/>
starting session<br/>
<a href="AccessGuides.html#24"><i>18</i></a><br/>
described <a href="AccessGuides.html#47"><i>41</i></a><br/>
understandin<a href="AccessGuides.html#17">g <i>11</i></a><br/>
find <a href="AccessGuides.html#76"><i>70</i></a><br/>
Access applications<br/>
<a href="AccessGuides.html#19"><i>13</i></a><br/>
search <a href="AccessGuides.html#76"><i>70</i></a><br/>
Access commands<br/>
<a href="AccessGuides.html#101"><i>95</i></a><br/>
attribute iterator<a href="AccessGuides.html#77">s <i>71</i></a><br/>
Access mode<br/>
attributes<br/>
starting<br/>
<a href="AccessGuides.html#25"><i>19</i></a><br/>
applyin<a href="AccessGuides.html#118">g <i>112</i></a><br/>
Access specific commands<br/>
<a href="AccessGuides.html#57"><i>51</i></a><br/>
AST nodes<br/>
<a href="AccessGuides.html#69"><i>63</i></a><br/>
accessing<br/>
boolean <a href="AccessGuides.html#111"><i>105</i></a><br/>
symbol attributes<br/>
<a href="AccessGuides.html#71"><i>65</i></a><br/>
described <a href="AccessGuides.html#46"><i>40</i></a><br/>
Action<a href="AccessGuides.html#36"> menu</a><br/>
<a href="AccessGuides.html#36"><i>30</i></a><br/>
intege<a href="AccessGuides.html#110">r <i>104</i></a><br/>
actions<br/>
kind <a href="AccessGuides.html#108"><i>102</i></a><br/>
attribute expressio<a href="AccessGuides.html#79">n</a><br/>
<a href="AccessGuides.html#79"><i>73</i></a><br/>
metric <a href="AccessGuides.html#116"><i>110</i></a><br/>
administrator<br/>
string <a href="AccessGuides.html#114"><i>108</i></a><br/>
<i><b>153</b></i><br/>
<hr/>
<a name=160></a><i>Index</i><br/>
automatic conversions<br/>
<a href="AccessGuides.html#68"><i>62</i></a><br/>
connecting<br/>
auxiliary commands<br/>
<a href="AccessGuides.html#107"><i>101</i></a><br/>
model server <a href="AccessGuides.html#28"><i>22</i></a><br/>
auxillary SMT command<a href="AccessGuides.html#99">s</a><br/>
<a href="AccessGuides.html#99"><i>93</i></a><br/>
Convert menu<br/>
<a href="AccessGuides.html#38"><i>32</i></a><br/>
converting<br/>
entities <a href="AccessGuides.html#67"><i>61</i></a><br/>
<b>B</b><br/>
CP operations<br/>
<a href="AccessGuides.html#98"><i>92</i></a><br/>
creating sets<br/>
<a href="AccessGuides.html#52"><i>46</i></a><br/>
Backus-Naur form<br/>
typographical convention<a href="AccessGuides.html#124">s</a><br/>
customizing<br/>
<a href="AccessGuides.html#124"><i>118</i></a><br/>
boolean attributes<br/>
UNIX user interfac<a href="AccessGuides.html#29">e <i>23</i></a><br/>
<a href="AccessGuides.html#111"><i>105</i></a><br/>
browse mode queries<br/>
<a href="AccessGuides.html#54"><i>48</i></a><br/>
build server<br/>
<b>D</b><br/>
described <a href="AccessGuides.html#153"><i>147</i></a><br/>
data cells<br/>
described <a href="AccessGuides.html#45"><i>39</i></a><br/>
<b>C</b><br/>
data type conversions<br/>
C function attribute expressions<br/>
described <a href="AccessGuides.html#45"><i>39</i></a><br/>
strcspn<br/>
data types<br/>
<a href="AccessGuides.html#119"><i>113</i></a><br/>
described <a href="AccessGuides.html#44"><i>38</i></a><br/>
strlen<br/>
<a href="AccessGuides.html#119"><i>113</i></a><br/>
strnch<a href="AccessGuides.html#119">r</a><br/>
declarations comman<a href="AccessGuides.html#102">d <i>96</i></a><br/>
<a href="AccessGuides.html#119"><i>113</i></a><br/>
strncm<a href="AccessGuides.html#120">p</a><br/>
defines command <a href="AccessGuides.html#102"><i>96</i></a><br/>
<a href="AccessGuides.html#120"><i>114</i></a><br/>
Developer Xpress<br/>
strpbrk<br/>
<a href="AccessGuides.html#120"><i>114</i></a><br/>
strrchr<br/>
described <a href="AccessGuides.html#154"><i>147</i></a><br/>
<a href="AccessGuides.html#120"><i>114</i></a><br/>
strspn<br/>
diff commands <a href="AccessGuides.html#87"><i>81</i></a><br/>
<a href="AccessGuides.html#120"><i>114</i></a><br/>
diff finalizatio<a href="AccessGuides.html#86">n</a><br/>
<a href="AccessGuides.html#86"><i>80</i></a><br/>
strstr <a href="AccessGuides.html#120"><i>114</i></a><br/>
C function attributes<br/>
diff initialization<br/>
<a href="AccessGuides.html#86"><i>80</i></a><br/>
<a href="AccessGuides.html#119"><i>113</i></a><br/>
call tree<br/>
diffs<br/>
applyin<a href="AccessGuides.html#88">g <i>82</i></a><br/>
described <a href="AccessGuides.html#153"><i>147</i></a><br/>
capturing<br/>
displaying<br/>
variables in attribute expressions<br/>
an AST node <a href="AccessGuides.html#68"><i>62</i></a><br/>
<a href="AccessGuides.html#78"><i>72</i></a><br/>
Dis-Tcl-Mode menu<br/>
<a href="AccessGuides.html#26"><i>20</i></a><br/>
Category menu<br/>
menus<br/>
do_dormant command<br/>
<a href="AccessGuides.html#121"><i>115</i></a><br/>
catego<a href="AccessGuides.html#40">ry</a><br/>
documentation<br/>
<a href="AccessGuides.html#40"><i>34</i></a><br/>
DIScover<br/>
change propogation<br/>
described<br/>
Installation and Administration <br/>
<a href="AccessGuides.html#85"><i>79</i></a><br/>
closure command<br/>
Guide <a href="AccessGuides.html#10"><i>4</i></a><br/>
<a href="AccessGuides.html#63"><i>57</i></a><br/>
release notes <a href="AccessGuides.html#10"><i>4</i></a><br/>
CM<br/>
described<br/>
User Guide for UNIX <a href="AccessGuides.html#10"><i>4</i></a><br/>
<a href="AccessGuides.html#153"><i>147</i></a><br/>
DIScover<br/>
User Guide for Windows <a href="AccessGuides.html#10"><i>4</i></a><br/>
DIScover User Guide <a href="AccessGuides.html#7"><i>1</i></a><br/>
benefits<br/>
<a href="AccessGuides.html#7"><i>1</i></a><br/>
command line acces<a href="AccessGuides.html#28">s</a><br/>
feedback <a href="AccessGuides.html#15"><i>9</i></a><br/>
<a href="AccessGuides.html#28"><i>22</i></a><br/>
command prompt<br/>
online <a href="AccessGuides.html#9"><i>3<br/></i></a>print <a href="AccessGuides.html#9"><i>3</i></a><br/>
starting Acce<a href="AccessGuides.html#33">ss</a><br/>
<a href="AccessGuides.html#33"><i>27</i></a><br/>
commands<br/>
relate<a href="AccessGuides.html#9">d <i>3</i></a><br/>
miscellaneous<br/>
release notes <a href="AccessGuides.html#10"><i>4</i></a><br/>
<a href="AccessGuides.html#59"><i>53</i></a><br/>
DSIM<br/>
commands, Access<br/>
navigation<br/>
described <a href="AccessGuides.html#154"><i>148</i></a><br/>
<a href="AccessGuides.html#102"><i>96</i></a><br/>
complianc<a href="AccessGuides.html#156">e</a><br/>
<a href="AccessGuides.html#156"><i>150</i></a><br/>
compound attribute expressions<br/>
<b>E</b><br/>
described <a href="AccessGuides.html#50"><i>44</i></a><br/>
configuration management system<br/>
education <a href="AccessGuides.html#14"><i>8</i></a><br/>
described <a href="AccessGuides.html#153"><i>147</i></a><br/>
emacs<br/>
<i><b>154</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=161></a><img src="AccessGuide-161_1.png"/><br/>
<i>Index</i><br/>
Access mod<a href="AccessGuides.html#24">e</a><br/>
<a href="AccessGuides.html#24"><i>18</i></a><br/>
groups<br/>
entities<br/>
described <a href="AccessGuides.html#61"><i>55</i></a><br/>
converti<a href="AccessGuides.html#67">ng</a><br/>
<a href="AccessGuides.html#67"><i>61</i></a><br/>
exporting <a href="AccessGuides.html#62"><i>56</i></a><br/>
entity<br/>
importin<a href="AccessGuides.html#62">g <i>56</i></a><br/>
describe<a href="AccessGuides.html#154">d <i>148</i></a><br/>
entity querie<a href="AccessGuides.html#55">s</a><br/>
<a href="AccessGuides.html#55"><i>49</i></a><br/>
entity relationship diagram<br/>
<b>H</b><br/>
describe<a href="AccessGuides.html#154">d <i>148</i></a><br/>
home_project comman<a href="AccessGuides.html#102">d <i>96</i></a><br/>
ERD<br/>
describe<a href="AccessGuides.html#154">d <i>148</i></a><br/>
event sequence<br/>
<b>I</b><br/>
describe<a href="AccessGuides.html#86">d <i>80</i></a><br/>
exporting groups<br/>
<a href="AccessGuides.html#62"><i>56</i></a><br/>
impact analysis<br/>
described <a href="AccessGuides.html#154"><i>148</i></a><br/>
importing grou<a href="AccessGuides.html#62">ps <i>56</i></a><br/>
<b>F</b><br/>
include files<br/>
described <a href="AccessGuides.html#155"><i>148</i></a><br/>
features<br/>
information model<br/>
new<br/>
<a href="AccessGuides.html#12"><i>6</i></a><br/>
described <a href="AccessGuides.html#155"><i>148</i></a><br/>
filter command<br/>
<a href="AccessGuides.html#57"><i>51</i></a><br/>
inheritance<br/>
Filter menu<br/>
described <a href="AccessGuides.html#155"><i>149</i></a><br/>
menus<br/>
instance<br/>
Filter<br/>
<a href="AccessGuides.html#41"><i>35</i></a><br/>
described <a href="AccessGuides.html#155"><i>149</i></a><br/>
find attribute functions<br/>
<a href="AccessGuides.html#76"><i>70</i></a><br/>
instances<br/>
friend_of comman<a href="AccessGuides.html#103">d</a><br/>
<a href="AccessGuides.html#103"><i>97</i></a><br/>
described <a href="AccessGuides.html#44"><i>38</i></a><br/>
fundamentals<br/>
instances command <a href="AccessGuides.html#104"><i>98</i></a><br/>
Access<br/>
<a href="AccessGuides.html#43"><i>37</i></a><br/>
integer attributes <a href="AccessGuides.html#110"><i>104<br/></i></a>integrated development environment<br/>
<b>G</b><br/>
described <a href="AccessGuides.html#155"><i>149</i></a><br/>
interface comma<a href="AccessGuides.html#121">nds <i>115</i></a><br/>
get_declares comman<a href="AccessGuides.html#103">d <i>97<br/></i></a>get_friends comma<a href="AccessGuides.html#103">nd <i>97<br/></i></a>get_include_files comman<a href="AccessGuides.html#103">d <i>97</i></a><br/>
<b>K</b><br/>
get_instance_scope command<br/>
<a href="AccessGuides.html#103"><i>97</i></a><br/>
kind attributes <a href="AccessGuides.html#108"><i>102</i></a><br/>
get_instance_statement command<br/>
<a href="AccessGuides.html#103"><i>97</i></a><br/>
get_instance_symbol command <a href="AccessGuides.html#103"><i>97<br/></i></a>get_member_data command<br/>
<a href="AccessGuides.html#103"><i>97</i></a><br/>
<b>L</b><br/>
get_member_functions command<br/>
<a href="AccessGuides.html#103"><i>97</i></a><br/>
get_related_classes command <a href="AccessGuides.html#103"><i>97</i></a><br/>
local variable<br/>
get_sub_classes command <a href="AccessGuides.html#104"><i>98</i></a><br/>
described <a href="AccessGuides.html#155"><i>149</i></a><br/>
get_super_classes comman<a href="AccessGuides.html#104">d</a><br/>
<a href="AccessGuides.html#104"><i>98</i></a><br/>
logical file name<br/>
getting started with Access<br/>
<a href="AccessGuides.html#23"><i>17</i></a><br/>
described <a href="AccessGuides.html#155"><i>149</i></a><br/>
glossary of terms<br/>
<a href="AccessGuides.html#153"><i>147</i></a><br/>
group<br/>
describe<a href="AccessGuides.html#154">d <i>148</i></a><br/>
<b>M</b><br/>
group commands <a href="AccessGuides.html#61"><i>55</i></a><br/>
menu<br/>
group member<br/>
Acces<a href="AccessGuides.html#34">s <i>28</i></a><br/>
describe<a href="AccessGuides.html#154">d <i>148</i></a><br/>
menus<br/>
group operation commands<br/>
<a href="AccessGuides.html#106"><i>100</i></a><br/>
Actio<a href="AccessGuides.html#36">n <i>30</i></a><br/>
group subcommands <a href="AccessGuides.html#62"><i>56</i></a><br/>
AST <a href="AccessGuides.html#38"><i>32</i></a><br/>
grouping<br/>
Conver<a href="AccessGuides.html#38">t <i>32</i></a><br/>
operands of Access commands<br/>
<a href="AccessGuides.html#52"><i>46</i></a><br/>
Project <a href="AccessGuides.html#42"><i>36</i></a><br/>
<i><b>155</b></i><br/>
<hr/>
<a name=162></a><i>Index</i><br/>
Query <a href="AccessGuides.html#41"><i>35</i></a><br/>
printing<br/>
Report <a href="AccessGuides.html#42"><i>36</i></a><br/>
<a href="AccessGuides.html#97">SMT <i>91</i></a><br/>
TP<a href="AccessGuides.html#39">M</a><br/>
<a href="AccessGuides.html#39"><i>33</i></a><br/>
product terms<br/>
Utilities<br/>
<a href="AccessGuides.html#36"><i>30</i></a><br/>
defined <a href="AccessGuides.html#153"><i>147</i></a><br/>
metric attributes<br/>
<a href="AccessGuides.html#116"><i>110</i></a><br/>
professional services<br/>
<a href="AccessGuides.html#14"><i>8</i></a><br/>
described <a href="AccessGuides.html#49"><i>43</i></a><br/>
project<br/>
metrics<br/>
described <a href="AccessGuides.html#156"><i>150</i></a><br/>
incalculable, values <a href="AccessGuides.html#116">for</a><br/>
<a href="AccessGuides.html#116"><i>110</i></a><br/>
project commands<br/>
<a href="AccessGuides.html#102"><i>96</i></a><br/>
miscellaneous attribute expressions<br/>
Project men<a href="AccessGuides.html#42">u</a><br/>
<a href="AccessGuides.html#42"><i>36</i></a><br/>
?:<br/>
<a href="AccessGuides.html#120"><i>114</i></a><br/>
project structure queries<br/>
<a href="AccessGuides.html#54"><i>48</i></a><br/>
attrib<a href="AccessGuides.html#120">ute</a><br/>
<a href="AccessGuides.html#120"><i>114</i></a><br/>
pruning<br/>
miscellaneous commands<br/>
<a href="AccessGuides.html#59"><i>53, 1</i></a><a href="AccessGuides.html#120"><i>14</i></a><br/>
described <a href="AccessGuides.html#156"><i>150</i></a><br/>
miscellaneous expression<a href="AccessGuides.html#120">s <i>114<br/></i></a><br/>
<a href="AccessGuides.html#13"><i>7</i></a><br/>
model browser<br/>
<b>Q</b><br/>
described <a href="AccessGuides.html#155"><i>149</i></a><br/>
query<br/>
starting Acce<a href="AccessGuides.html#32">ss</a><br/>
<a href="AccessGuides.html#32"><i>26</i></a><br/>
described <a href="AccessGuides.html#156"><i>150</i></a><br/>
model server<br/>
query commands<br/>
<a href="AccessGuides.html#102"><i>96</i></a><br/>
connecting to<br/>
<a href="AccessGuides.html#28"><i>22</i></a><br/>
argument_of <a href="AccessGuides.html#102"><i>96</i></a><br/>
model servers<br/>
declarations <a href="AccessGuides.html#102"><i>96</i></a><br/>
described <a href="AccessGuides.html#155"><i>149</i></a><br/>
defines <a href="AccessGuides.html#102"><i>96</i></a><br/>
model_server<br/>
do_dormant <a href="AccessGuides.html#121"><i>115</i></a><br/>
starting on UN<a href="AccessGuides.html#28">IX</a><br/>
<a href="AccessGuides.html#28"><i>22</i></a><br/>
friend_of <a href="AccessGuides.html#103">97</a><br/>
modified_entities command<br/>
<a href="AccessGuides.html#104"><i>98</i></a><br/>
get_declar<a href="AccessGuides.html#103">es <i>97</i></a><br/>
modified_objects command<br/>
<a href="AccessGuides.html#104"><i>98</i></a><br/>
get_friend<a href="AccessGuides.html#103">s <i>97</i></a><br/>
Myer’s Complexity<br/>
get_include_file<a href="AccessGuides.html#103">s <i>97</i></a><br/>
described <a href="AccessGuides.html#156"><i>149</i></a><br/>
get_instance_scop<a href="AccessGuides.html#103">e <i>97<br/></i></a>get_instance_statemen<a href="AccessGuides.html#103">t <i>97</i></a><br/>
<b>N</b><br/>
get_instance_symbo<a href="AccessGuides.html#103">l <i>97<br/></i></a>get_member_data <a href="AccessGuides.html#103"><i>97</i></a><br/>
navigating<br/>
get_member_functions <a href="AccessGuides.html#103"><i>97</i></a><br/>
attribute expressions<br/>
<a href="AccessGuides.html#74"><i>68</i></a><br/>
get_related_classes <a href="AccessGuides.html#103">97</a><br/>
trees<br/>
<a href="AccessGuides.html#75"><i>69</i></a><br/>
get_sub_classes <a href="AccessGuides.html#104"><i>98</i></a><br/>
navigation commands<br/>
<a href="AccessGuides.html#102"><i>96</i></a><br/>
get_super_classe<a href="AccessGuides.html#104">s <i>98</i></a><br/>
nested structures<br/>
home_project <a href="AccessGuides.html#102"><i>96</i></a><br/>
described <a href="AccessGuides.html#156"><i>149</i></a><br/>
instance<a href="AccessGuides.html#104">s <i>98</i></a><br/>
new features<br/>
<a href="AccessGuides.html#12"><i>6</i></a><br/>
modified_entitie<a href="AccessGuides.html#104">s <i>98<br/></i></a>modified_objects <a href="AccessGuides.html#104"><i>98<br/></i></a>updat<a href="AccessGuides.html#122">e <i>116</i></a><br/>
<b>O</b><br/>
uses <a href="AccessGuides.html#104"><i>98</i></a><br/>
obtaining<br/>
where <a href="AccessGuides.html#105"><i>99</i></a><br/>
Query men<a href="AccessGuides.html#41">u</a><br/>
<a href="AccessGuides.html#41"><i>35</i></a><br/>
an SMT nod<a href="AccessGuides.html#94">e</a><br/>
<a href="AccessGuides.html#94"><i>88</i></a><br/>
open DIS<a href="AccessGuides.html#35">H</a><br/>
quick reference<br/>
<a href="AccessGuides.html#147"><i>141</i></a><br/>
<a href="AccessGuides.html#35"><i>29</i></a><br/>
overview<br/>
Access<br/>
<a href="AccessGuides.html#18"><i>12</i></a><br/>
<b>R<br/></b>related documentation<br/>
<a href="AccessGuides.html#9"><i>3</i></a><br/>
<b>P</b><br/>
relationship queries<br/>
<a href="AccessGuides.html#55"><i>49</i></a><br/>
release notes<br/>
<a href="AccessGuides.html#10"><i>4</i></a><br/>
physical file name<br/>
described<br/>
Report<br/>
<a href="AccessGuides.html#156"><i>150</i></a><br/>
print procedure<br/>
menu <a href="AccessGuides.html#42"><i>36</i></a><br/>
<a href="AccessGuides.html#53"><i>47</i></a><br/>
<i><b>156</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name=163></a><img src="AccessGuide-163_1.png"/><br/>
<i>Index</i><br/>
resolving<br/>
accessing <a href="AccessGuides.html#71"><i>65</i></a><br/>
TPM expression conflicts<br/>
<a href="AccessGuides.html#90"><i>84</i></a><br/>
symbols<br/>
roles<br/>
described <a href="AccessGuides.html#44"><i>38</i></a><br/>
administrator<br/>
<a href="AccessGuides.html#12"><i>6</i></a><br/>
syntax<br/>
user <a href="AccessGuides.html#12"><i>6</i></a><br/>
TPM expressions <a href="AccessGuides.html#124"><i>118</i></a><br/>
<b>S</b><br/>
<b>T</b><br/>
samples<br/>
Tcl variables<br/>
Access programmin<a href="AccessGuides.html#19">g</a><br/>
<a href="AccessGuides.html#19"><i>13</i></a><br/>
described <a href="AccessGuides.html#51"><i>45</i></a><br/>
search attribute functions<br/>
<a href="AccessGuides.html#76"><i>70</i></a><br/>
terms<br/>
services<br/>
defined <a href="AccessGuides.html#153"><i>147</i></a><br/>
offere<a href="AccessGuides.html#14">d <i>8</i></a><br/>
TPM<br/>
set operation commands<br/>
<a href="AccessGuides.html#105"><i>99</i></a><br/>
described <a href="AccessGuides.html#157"><i>151</i></a><br/>
set operation<a href="AccessGuides.html#57">s</a><br/>
<a href="AccessGuides.html#57"><i>51</i></a><br/>
TPM expression syntax <a href="AccessGuides.html#124"><i>118</i></a><br/>
set semantics<br/>
<a href="AccessGuides.html#53"><i>47</i></a><br/>
TPM expression variables <a href="AccessGuides.html#124"><i>118</i></a><br/>
set_intersect comma<a href="AccessGuides.html#57">nd <i>51</i></a><br/>
TPM expressions<br/>
sets<br/>
<a href="AccessGuides.html#52"><i>46</i></a><br/>
making ch<a href="AccessGuides.html#87">anges <i>81</i></a><br/>
creating<br/>
<a href="AccessGuides.html#52"><i>46</i></a><br/>
resolving conflicts <a href="AccessGuides.html#90"><i>84</i></a><br/>
simple attribute expressions<br/>
writing <a href="AccessGuides.html#79"><i>73</i></a><br/>
describe<a href="AccessGuides.html#47">d <i>41</i></a><br/>
TP<a href="AccessGuides.html#39">M menu <i>33</i></a><br/>
SMT<br/>
training <a href="AccessGuides.html#14"><i>8</i></a><br/>
printing<br/>
<a href="AccessGuides.html#97"><i>91</i></a><br/>
tree navigation <a href="AccessGuides.html#75"><i>69</i></a><br/>
SMT attribute<a href="AccessGuides.html#96">s <i>90</i></a><br/>
tree pattern matching<br/>
SMT change commands<br/>
<a href="AccessGuides.html#99"><i>93</i></a><br/>
described <a href="AccessGuides.html#65"><i>59, 151</i></a><br/>
SMT navigation<br/>
<a href="AccessGuides.html#95"><i>89</i></a><br/>
tree subcommands <a href="AccessGuides.html#71"><i>65</i></a><br/>
SMT node<br/>
typographical conventions <a href="AccessGuides.html#11"><i>5</i></a><br/>
obtaining<br/>
<a href="AccessGuides.html#94"><i>88</i></a><br/>
Backus-Naur for<a href="AccessGuides.html#124">m <i>118</i></a><br/>
SMT operatio<a href="AccessGuides.html#98">ns</a><br/>
<a href="AccessGuides.html#98"><i>92</i></a><br/>
SMT structure<br/>
describe<a href="AccessGuides.html#94">d <i>88</i></a><br/>
<b>U</b><br/>
sort command <a href="AccessGuides.html#57"><i>51</i></a><br/>
update command <a href="AccessGuides.html#122"><i>116</i></a><br/>
source mode queries<br/>
upgrade service<a href="AccessGuides.html#14">s <i>8</i></a><br/>
describe<a href="AccessGuides.html#93">d <i>87</i></a><br/>
useful attributes<br/>
starting<br/>
described <a href="AccessGuides.html#48"><i>42</i></a><br/>
Access mod<a href="AccessGuides.html#25">e</a><br/>
<a href="AccessGuides.html#25"><i>19</i></a><br/>
user<br/>
strcspn attribute expression<br/>
<a href="AccessGuides.html#119"><i>113</i></a><br/>
described <a href="AccessGuides.html#12"><i>6</i></a><br/>
string attrib<a href="AccessGuides.html#114">utes</a><br/>
<a href="AccessGuides.html#114"><i>108</i></a><br/>
user interface<br/>
strlen attribute expressio<a href="AccessGuides.html#119">n</a><br/>
<a href="AccessGuides.html#119"><i>113</i></a><br/>
customizin<a href="AccessGuides.html#29">g <i>23</i></a><br/>
strnchr attribute expressio<a href="AccessGuides.html#119">n <i>113</i></a><br/>
uses command <a href="AccessGuides.html#104"><i>98</i></a><br/>
strncmp attribute expression <a href="AccessGuides.html#120"><i>114</i></a><br/>
Utilities menu <a href="AccessGuides.html#36"><i>30</i></a><br/>
strpbrk attribute expressio<a href="AccessGuides.html#120">n <i>114<br/></i></a>strrchr attribute expression<br/>
<a href="AccessGuides.html#120"><i>114</i></a><br/>
strspn attribute expressio<a href="AccessGuides.html#120">n</a><br/>
<a href="AccessGuides.html#120"><i>114</i></a><br/>
<b>V</b><br/>
strstr attribute expression <a href="AccessGuides.html#120"><i>114<br/></i></a>subclass<br/>
variable capture in attribute expressions <a href="AccessGuides.html#78"><i>72</i></a><br/>
describe<a href="AccessGuides.html#156">d <i>150</i></a><br/>
variables<br/>
superclass<br/>
TPM expressions <a href="AccessGuides.html#124"><i>118</i></a><br/>
describe<a href="AccessGuides.html#157">d <i>150</i></a><br/>
Viewer<br/>
symbol attributes<br/>
Access mode <a href="AccessGuides.html#24"><i>18, 19</i></a><br/>
<i><b>157</b></i><br/>
<hr/>
<a name=164></a><i>Index</i><br/>
<b>W</b><br/>
described <a href="AccessGuides.html#157"><i>151</i></a><br/>
writing<br/>
where command <a href="AccessGuides.html#105"><i>99</i></a><br/>
TPM expression<a href="AccessGuides.html#79">s <i>73</i></a><br/>
windowing<br/>
<i><b>158</b></i><br/>
a c c e s s<br/>
g u i d e<br/>
<hr/>
<a name="outline"></a><h1>Document Outline</h1>
<ul>
<li><a href="AccessGuides.html#7">Welcome to Access</a>
<ul>
<li><a href="AccessGuides.html#8">About This Guide</a></li>
<li><a href="AccessGuides.html#9">Related Documentation</a></li>
<li><a href="AccessGuides.html#11">Typographical Conventions</a></li>
<li><a href="AccessGuides.html#12">What’s New in This Release</a></li>
<li><a href="AccessGuides.html#12">Roles</a></li>
<li><a href="AccessGuides.html#12">Assumptions</a></li>
<li><a href="AccessGuides.html#13">Getting Help</a></li>
<li><a href="AccessGuides.html#14">Professional Services</a></li>
<li><a href="AccessGuides.html#15">Documentation Feedback</a></li>
<li><a href="AccessGuides.html#16">Where To Go From Here</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#17">Understanding Access</a>
<ul>
<li><a href="AccessGuides.html#18">About Access</a></li>
<li><a href="AccessGuides.html#19">Applications of Access</a></li>
<li><a href="AccessGuides.html#19">Samples of Access Programming</a>
<ul>
<li><a href="AccessGuides.html#19">Lines of Code in a Model</a></li>
<li><a href="AccessGuides.html#21">Include File Naming Conventions</a></li>
<li><a href="AccessGuides.html#22">Static Functions Declared in Header Files</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="AccessGuides.html#23">Getting Started With Access</a>
<ul>
<li><a href="AccessGuides.html#24">Interactive Access Sessions on UNIX</a>
<ul>
<li><a href="AccessGuides.html#24">Using Access in a Viewer</a></li>
<li><a href="AccessGuides.html#25">Starting Access Mode</a></li>
<li><a href="AccessGuides.html#26">Interpreting the Access Buffer</a></li>
<li><a href="AccessGuides.html#27">Autoloading Access Commands</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#28">Access from the UNIX Command Line</a>
<ul>
<li><a href="AccessGuides.html#28">Connecting to a model_server Using dish2</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#29">User Interface Customization on UNIX</a>
<ul>
<li><a href="AccessGuides.html#29">Browser Menu Creation Commands</a></li>
<li><a href="AccessGuides.html#30">Menu Creation Example</a></li>
<li><a href="AccessGuides.html#31">Interface Commands</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#31">Interactive Access Sessions on Windows</a>
<ul>
<li><a href="AccessGuides.html#33">Autoloading Access Commands</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#34">Access Menu</a>
<ul>
<li><a href="AccessGuides.html#35">Open DISH</a></li>
<li><a href="AccessGuides.html#36">Utilities</a></li>
<li><a href="AccessGuides.html#36">Action</a></li>
<li><a href="AccessGuides.html#38">Convert</a></li>
<li><a href="AccessGuides.html#38">AST</a></li>
<li><a href="AccessGuides.html#39">TPM</a></li>
<li><a href="AccessGuides.html#40">Category</a></li>
<li><a href="AccessGuides.html#41">Query</a></li>
<li><a href="AccessGuides.html#41">Filter</a></li>
<li><a href="AccessGuides.html#42">Project</a></li>
<li><a href="AccessGuides.html#42">Report</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="AccessGuides.html#43">Access Fundamentals</a>
<ul>
<li><a href="AccessGuides.html#44">Data Types</a>
<ul>
<li><a href="AccessGuides.html#44">Symbols</a></li>
<li><a href="AccessGuides.html#44">Instances</a></li>
<li><a href="AccessGuides.html#45">AST Nodes</a></li>
<li><a href="AccessGuides.html#45">Data Cells</a></li>
<li><a href="AccessGuides.html#45">Data Type Conversions</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#46">Attributes and Attribute Expressions</a>
<ul>
<li><a href="AccessGuides.html#47">Simple Attribute Expressions: Attributes</a></li>
<li><a href="AccessGuides.html#47">Attribute Functions</a></li>
<li><a href="AccessGuides.html#48">Useful Attributes</a></li>
<li><a href="AccessGuides.html#49">Metric Attributes</a></li>
<li><a href="AccessGuides.html#50">Compound Attribute Expressions</a></li>
<li><a href="AccessGuides.html#50">Shortcuts</a></li>
<li><a href="AccessGuides.html#51">Tcl Variables</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#52">Sets</a>
<ul>
<li><a href="AccessGuides.html#52">Set Creation</a></li>
<li><a href="AccessGuides.html#53">Set Semantics</a></li>
<li><a href="AccessGuides.html#53">Iteration</a></li>
<li><a href="AccessGuides.html#53">About the Print Procedure</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#54">Procedures</a>
<ul>
<li><a href="AccessGuides.html#54">Project Structure, or Browse Mode Queries</a></li>
<li><a href="AccessGuides.html#55">Entity and Relationship Queries</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#57">Access Specific Commands</a>
<ul>
<li><a href="AccessGuides.html#57">Set Operations</a></li>
<li><a href="AccessGuides.html#59">Miscellaneous Commands</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#61">Groups</a>
<ul>
<li><a href="AccessGuides.html#61">Group Commands</a></li>
<li><a href="AccessGuides.html#62">Group Subcommands</a></li>
<li><a href="AccessGuides.html#62">Importing and Exporting Groups</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#63">Closure</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#65">Tree Pattern Matching</a>
<ul>
<li><a href="AccessGuides.html#66">Abstract Syntax Trees</a></li>
<li><a href="AccessGuides.html#67">AST Nodes</a>
<ul>
<li><a href="AccessGuides.html#67">Converting Entities</a></li>
<li><a href="AccessGuides.html#68">Automatic Conversions</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#68">Displaying the AST</a></li>
<li><a href="AccessGuides.html#69">Attributes of AST Nodes</a>
<ul>
<li><a href="AccessGuides.html#71">Accessing Symbol Attributes</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#71">Tree Subcommands</a></li>
<li><a href="AccessGuides.html#74">Navigation in Attribute Expressions</a>
<ul>
<li><a href="AccessGuides.html#75">Tree Navigation</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#76">Find and Search Attribute Functions</a></li>
<li><a href="AccessGuides.html#77">Attribute Iterators</a></li>
<li><a href="AccessGuides.html#78">Variable Capture in Attribute Expressions</a></li>
<li><a href="AccessGuides.html#79">Attribute Expression Actions</a></li>
<li><a href="AccessGuides.html#79">Writing Efficient TPM Expressions</a>
<ul>
<li><a href="AccessGuides.html#79">Optimize the Scope of Your Searches</a></li>
<li><a href="AccessGuides.html#79">Manage the ASTs in Memory</a></li>
<li><a href="AccessGuides.html#80">Simple Examples</a></li>
<li><a href="AccessGuides.html#80">Advanced Applications</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="AccessGuides.html#85">Change Propagation</a>
<ul>
<li><a href="AccessGuides.html#86">Event Sequence</a></li>
<li><a href="AccessGuides.html#86">Diff Initialization and Finalization</a></li>
<li><a href="AccessGuides.html#87">Making Changes</a></li>
<li><a href="AccessGuides.html#88">Applying Diffs</a></li>
<li><a href="AccessGuides.html#91">diff_tpm_all</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#93">Source Mode Queries</a>
<ul>
<li><a href="AccessGuides.html#94">SMT Structure</a></li>
<li><a href="AccessGuides.html#94">Obtaining an SMT Node</a></li>
<li><a href="AccessGuides.html#95">SMT Navigation</a></li>
<li><a href="AccessGuides.html#96">SMT Attributes</a></li>
<li><a href="AccessGuides.html#97">Printing the SMT Example</a></li>
<li><a href="AccessGuides.html#98">SMT/CP Operations</a>
<ul>
<li><a href="AccessGuides.html#99">SMT Change Commands</a></li>
<li><a href="AccessGuides.html#99">Auxiliary Commands</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="AccessGuides.html#101">Access Commands</a>
<ul>
<li><a href="AccessGuides.html#102">Project Commands</a>
<ul>
<li><a href="AccessGuides.html#102">Query Commands</a></li>
<li><a href="AccessGuides.html#105">Set Operation Commands</a></li>
<li><a href="AccessGuides.html#106">Group Operation Commands</a></li>
<li><a href="AccessGuides.html#107">Auxiliary Commands</a></li>
<li><a href="AccessGuides.html#108">Kind Attributes</a></li>
<li><a href="AccessGuides.html#110">Integer Attributes</a></li>
<li><a href="AccessGuides.html#111">Boolean Attributes</a></li>
<li><a href="AccessGuides.html#114">String Attributes</a></li>
<li><a href="AccessGuides.html#116">Metric Attributes</a></li>
<li><a href="AccessGuides.html#118">Applying Attributes</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#118">Attribute Expressions</a>
<ul>
<li><a href="AccessGuides.html#119">C Function Attribute Expressions</a></li>
<li><a href="AccessGuides.html#120">Miscellaneous Commands and Expressions</a></li>
<li><a href="AccessGuides.html#121">Interface Commands</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="AccessGuides.html#123">Attribute Expression Grammar</a>
<ul>
<li><a href="AccessGuides.html#124">Typographical Conventions for BackusNaur Form</a>
<ul>
<li><a href="AccessGuides.html#124">TPM Expression Syntax</a></li>
<li><a href="AccessGuides.html#124">TPM Expression Variables</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="AccessGuides.html#129">AST_node Attributes</a>
<ul>
<li><a href="AccessGuides.html#130">AST_node Attribute Codes</a></li>
<li><a href="AccessGuides.html#135">Samples for C++, Java, and SQL</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#147">Access Quick Reference</a></li>
<li><a href="AccessGuides.html#153">Glossary of Terms</a>
<ul>
<li><a href="AccessGuides.html#153">Abstract Syntax Tree</a></li>
<li><a href="AccessGuides.html#153">Access</a></li>
<li><a href="AccessGuides.html#153">build server</a></li>
<li><a href="AccessGuides.html#153">caliper</a></li>
<li><a href="AccessGuides.html#153">call tree</a></li>
<li><a href="AccessGuides.html#153">configuration management (CM) system</a></li>
<li><a href="AccessGuides.html#153">cyclomatic complexity</a></li>
<li><a href="AccessGuides.html#154">Developer Xpress</a></li>
<li><a href="AccessGuides.html#154">dormant</a></li>
<li><a href="AccessGuides.html#154">DSIM</a></li>
<li><a href="AccessGuides.html#154">entity</a></li>
<li><a href="AccessGuides.html#154">entity relation diagram</a></li>
<li><a href="AccessGuides.html#154">function path mapping</a></li>
<li><a href="AccessGuides.html#154">group</a></li>
<li><a href="AccessGuides.html#154">group member</a></li>
<li><a href="AccessGuides.html#154">hits</a></li>
<li><a href="AccessGuides.html#154">impact analysis</a></li>
<li><a href="AccessGuides.html#154">impact analysis report</a></li>
<li><a href="AccessGuides.html#155">information model</a></li>
<li><a href="AccessGuides.html#155">include files</a></li>
<li><a href="AccessGuides.html#155">inheritance</a></li>
<li><a href="AccessGuides.html#155">instance</a></li>
<li><a href="AccessGuides.html#155">Integrated Development Environment (IDE)</a></li>
<li><a href="AccessGuides.html#155">local variable</a></li>
<li><a href="AccessGuides.html#155">logical file name</a></li>
<li><a href="AccessGuides.html#155">metrics</a></li>
<li><a href="AccessGuides.html#155">model browser</a></li>
<li><a href="AccessGuides.html#155">model server</a></li>
<li><a href="AccessGuides.html#155">model version</a></li>
<li><a href="AccessGuides.html#156">Myer’s Complexity</a></li>
<li><a href="AccessGuides.html#156">nested structures</a></li>
<li><a href="AccessGuides.html#156">persistent group</a></li>
<li><a href="AccessGuides.html#156">physical file name</a></li>
<li><a href="AccessGuides.html#156">\project</a></li>
<li><a href="AccessGuides.html#156">pruning</a></li>
<li><a href="AccessGuides.html#156">quality assessment report</a></li>
<li><a href="AccessGuides.html#156">quality filter sets</a></li>
<li><a href="AccessGuides.html#156">query</a></li>
<li><a href="AccessGuides.html#156">repository</a></li>
<li><a href="AccessGuides.html#156">scratch group</a></li>
<li><a href="AccessGuides.html#156">simplify.h</a></li>
<li><a href="AccessGuides.html#156">subclass</a></li>
<li><a href="AccessGuides.html#157">superclass</a></li>
<li><a href="AccessGuides.html#157">submission check</a></li>
<li><a href="AccessGuides.html#157">transform</a></li>
<li><a href="AccessGuides.html#157">tree pattern matching (TPM)</a></li>
<li><a href="AccessGuides.html#157">violation</a></li>
<li><a href="AccessGuides.html#157">windowing</a></li>
</ul>
</li>
<li><a href="AccessGuides.html#159">Index</a>
<ul>
<li><a href="AccessGuides.html#159">Symbols</a></li>
<li><a href="AccessGuides.html#159">A</a></li>
<li><a href="AccessGuides.html#160">B</a></li>
<li><a href="AccessGuides.html#160">C</a></li>
<li><a href="AccessGuides.html#160">D</a></li>
<li><a href="AccessGuides.html#160">E</a></li>
<li><a href="AccessGuides.html#161">F</a></li>
<li><a href="AccessGuides.html#161">G</a></li>
<li><a href="AccessGuides.html#161">H</a></li>
<li><a href="AccessGuides.html#161">I</a></li>
<li><a href="AccessGuides.html#161">K</a></li>
<li><a href="AccessGuides.html#161">L</a></li>
<li><a href="AccessGuides.html#161">M</a></li>
<li><a href="AccessGuides.html#162">N</a></li>
<li><a href="AccessGuides.html#162">O</a></li>
<li><a href="AccessGuides.html#162">P</a></li>
<li><a href="AccessGuides.html#162">Q</a></li>
<li><a href="AccessGuides.html#162">R</a></li>
<li><a href="AccessGuides.html#163">S</a></li>
<li><a href="AccessGuides.html#163">T</a></li>
<li><a href="AccessGuides.html#163">U</a></li>
<li><a href="AccessGuides.html#163">V</a></li>
<li><a href="AccessGuides.html#164">W</a></li>
</ul>
</li>
</ul>
<hr/>
</body>
</html>
